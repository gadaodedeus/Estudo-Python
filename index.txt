Guia Foca Linux

Guia Foca Linux

Gleydson Mazioli da Silva

<gleydson@guiafoca.org>

Versão 5.02 - segunda, 27 de julho de 2020

Copyright © 1999-2020 - Gleydson Mazioli da Silva

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.2 published by the Free
Software Foundation; A copy of the license is included in the section entitled
"GNU Free Documentation License".

segunda, 27 de julho de 2020

Resumo

Este guia tem por objetivo ser uma referência ao aprendizado do usuário e um
manual de consulta, operação e configuração de sistemas Linux (e outros tipos
de *ix). A última versão oficial deste guia pode ser encontrada na Página
Oficial do Foca Linux. Novas versões são lançadas com uma frequência mensal e
você pode receber avisos de novos lançamentos deste guia preenchendo um
formulário na página Web ou assinando o twitter @guiafoca.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Índice

1. Introdução

    Antes de começar
    Pré-requisitos para a utilização deste guia
    Sistema Operacional
    O Linux

        Algumas Características do Linux

    Distribuições do Linux
    Software Livre
    Processamento de Dados
    O Computador
    Conhecendo o Computador

        Tipos de Gabinete
        Painel Frontal
        Monitor de Vídeo

    Placa Mãe

        Alguns componentes da placa mãe

    Memória do Computador

        Memória Principal
        Memória Auxiliar

    Discos

        Discos Flexíveis
        Disco Rígido
        CD/DVD/BluRay

    Cuidados Básicos com o Computador
    Dispositivos de Entrada e Saída
    Ligando o computador
    Desligando o computador
    Reiniciando o computador

2. Explicações Básicas

    Hardware e Software
    Arquivos

        Extensão de arquivos
        Tamanho de arquivos
        Arquivo texto e binário

    Diretório

        Diretório Raíz
        Diretório atual
        Diretório home
        Diretório Superior
        Diretório Anterior
        Caminho na estrutura de diretórios
        Exemplo de diretório
        Estrutura básica de diretórios do Sistema Linux

    Nomeando Arquivos e Diretórios
    Comandos

        Comandos Internos

    Comandos Externos
    Aviso de comando (Prompt)
    Interpretador de comandos
    Terminal Virtual (console)
    Login
    Logout
    coringas

        Exemplo de coringas

3. Para quem esta migrando (ou pensando em migrar) do DOS/Windows para o Linux

    Quais as diferenças iniciais
    Comandos equivalentes entre DOS/CMD do Windows e o Linux

        Arquivos de configuração

    Usando a sintaxe de comandos DOS no Linux
    Programas equivalentes entre Windows/DOS e o Linux

4. Discos e Partições

    Partições
    Formatando Pen-drives/Disquetes

        Formatando pen-drives para serem usados no Linux
        Formatando pen-drives compatíveis com o Windows
        Programas de Formatação Gráficos

    Pontos de Montagem
    Identificação de discos e partições em sistemas Linux
    Montando (acessando) uma partição de disco

        fstab

    Desmontando uma partição de disco

5. Execução de programas

    Executando um comando/programa
    path
    Tipos de Execução de comandos/programas
    Executando programas em seqüência
    ps
    top
    Controle de execução de processos

        Interrompendo a execução de um processo
        Parando momentaneamente a execução de um processo
        jobs
        fg
        bg
        kill
        killall
        killall5
        Sinais do Sistema

    Fechando um programa quando não se sabe como sair
    Eliminando caracteres estranhos

6. Comandos para manipulação de diretório

    ls
    cd
    pwd
    mkdir
    rmdir

7. Comandos para manipulação de Arquivos

    cat
    tac
    rm
    cp
    mv

8. Comandos Diversos

    clear
    date
    df
    ln
    du
    find
    free
    grep
    head
    nl
    more
    less
    sort
    tail
    time
    touch
    uptime
    dmesg
    mesg
    echo
    su
    sync
    uname
    reboot
    shutdown
    wc
    seq
    chattr
    lsattr
    cut
    cmp
    dirname
    diff
    pr
    patch
    whereis
    which
    zforce
    gzexe
    znew

9. Comandos de rede

    who
    telnet
    finger
    ftp
    whoami
    dnsdomainname
    hostname
    talk

10. Comandos para manipulação de contas

    adduser
    addgroup
    passwd
    gpasswd
    newgrp
    userdel
    groupdel
    lastlog
    last
    sg
    Adicionando o usuário a um grupo extra
    chfn
    id
    logname
    users
    groups

11. Permissões de acesso a arquivos e diretórios

    Donos, Grupos e outros usuários
    Tipos de Permissões de Acesso
    Etapas para acesso a um arquivo/diretório
    Exemplos práticos de permissões de acesso

        Exemplo de acesso a um arquivo
        Exemplo de acesso a um diretório

    Permissões de Acesso Especiais
    A conta root
    chmod
    chgrp
    chown
    Modo de permissão octal
    umask

12. Redirecionamentos e Pipe

    >
    >>
    <
    <<
    | (pipe)
    Diferença entre o "|" e o ">"
    tee

13. Impressão

    Portas de impressora
    Imprimindo diretamente para a porta de impressora
    Imprimindo via spool
    Impressão em modo gráfico

        Ghost Script

    Magic Filter

        Instalação e configuração do Magic Filter
        Outros detalhes técnicos sobre o Magic Filter

14. Configuração do sistema

    Acentuação

        Acentuação em modo Texto
        Acentuação em modo gráfico

    Número de Cores do ambiente gráfico

        Configurando o número de cores para quem inicia pelo prompt
        Configurando o número de cores para quem inicia pelo XDM
        Ajustando o alinhamento da imagem no X e outras configurações

15. X Window (ambiente gráfico)

    O que é X Window?
    A organização do ambiente gráfico X Window
    Iniciando o X
    Servidor X

16. Como obter ajuda

    Páginas de Manual
    Info Pages
    Ajuda na própria linha de comandos
    help
    apropos
    whatis
    locate
    which
    Documentos HOWTO's
    Documentação de Programas
    FAQ
    Internet

        Páginas Internet de Referência
        Listas de discussão

    Netiqueta

        Recomendações Gerais sobre a Comunicação Eletrônica
        Email
        Telegram/Whatsapp/Messenger/Gtalk/Skype
        Talk
        Listas de Discussão via Email

17. Apêndice

    Sobre este guia
    Sobre o Autor
    Referências de auxílio ao desenvolvimento do guia
    Onde encontrar a versão mais nova do guia?
    Colaboradores do Guia
    Marcas Registradas
    Futuras versões
    Guia do Linux
    Chave Pública PGP

Capítulo 1. Introdução

Índice

Antes de começar
Pré-requisitos para a utilização deste guia
Sistema Operacional
O Linux

    Algumas Características do Linux

Distribuições do Linux
Software Livre
Processamento de Dados
O Computador
Conhecendo o Computador

    Tipos de Gabinete
    Painel Frontal
    Monitor de Vídeo

Placa Mãe

    Alguns componentes da placa mãe

Memória do Computador

    Memória Principal
    Memória Auxiliar

Discos

    Discos Flexíveis
    Disco Rígido
    CD/DVD/BluRay

Cuidados Básicos com o Computador
Dispositivos de Entrada e Saída
Ligando o computador
Desligando o computador
Reiniciando o computador

Bem vindo ao Guia Foca Linux. O nome FOCA significa FOnte de Consulta e A
prendizado. Este guia está dividido em 3 níveis de aprendizado e versão que
está lendo agora contém os níveis:

  • Iniciante

Entre o conteúdo do guia, você encontrará:

  • Textos explicativos falando sobre o sistema Linux, seus comandos, como
    manusear arquivos, diretórios, etc.

  • Explicações iniciais sobre as partes básicas do computador e periféricos

  • Comandos e Programas equivalentes entre o DOS/Windows e o GNU/Linux

  • Todos os materiais contidos na versão iniciante são ideais para quem está
    tendo o primeiro contato com computadores e/ou com o Linux. A linguagem
    usada é simples com o objetivo de explicar claramente o funcionamento de
    cada comando e evitando, sempre que possível, termos técnicos

Para melhor organização, dividi o guia em 3 versões: Iniciante, Intermediário e
Avançado. Sendo que a versão Iniciante é voltada para o usuário que não tem
nenhuma experiência no GNU/Linux. A última versão deste guia pode ser
encontrada em: Página Oficial do Guia Foca Linux.

Caso tiver alguma sugestão, correção, crítica para a melhoria deste guia,
preencha o formuário de sugestões disponíveis na página oficial do guia ou
envie um e-mail para <gleydson@guiafoca.org>.

O Foca GNU/Linux é atualizado freqüentemente, por este motivo recomendo que
preencha a ficha do aviso de atualizações na página web em Página Oficial do
guia Foca GNU/Linux no fim da página principal. Após preencher a ficha do aviso
de atualizações, você receberá um e-mail sobre o lançamento de novas versões do
guia e o que foi modificado, desta forma você poderá decidir em copia-la caso a
nova versão contenha modificações que considera importantes.

Tenho recebido elegios de pessoas do Brasil (e também de outros países)
elogiando o trabalho e a qualidade da documentação. Agradeço a todos pelo
apoio, tenham certeza que este trabalho é desenvolvido pensando em repassar um
pouco do conhecimento que adquiri ao começar o uso do Linux.

Também recebo e-mails de pessoas comemorando a aprovação na prova LPI nível 1,
2 e 3 após estudar usando o guia Foca GNU/Linux. Fico bastante feliz por saber
disso, pois nunca tive a intenção de tornar o guia uma referência livre para
estudo da LPI e hoje é usado para estudo desta difícil certificação que aborda
comandos, serviços, configurações, segurança, empacotamento, criptografia, etc.

Antes de começar

Os capítulos Introdução e básico contém explicações teóricas sobre o
computador, GNU/Linux, etc., você pode pular este capítulos caso já conheça
estas explicações ou se desejar partir para a prática e quiser vê-los mais
tarde, se lhe interessar.

Se você já é um usuário do DOS e Windows, recomendo ler Capítulo 3, Para quem
esta migrando (ou pensando em migrar) do DOS/Windows para o Linux. Lá você vai
encontrar comparações de comandos e programas DOS/Windows e GNU/Linux.

Para quem está começando, muita teoria pode atrapalhar o aprendizado, é mais
produtivo ver na prática o que o computador faz e depois porque ele faz isto.
Mesmo assim, recomendo ler estes capítulos pois seu conteúdo pode ser útil.

Coloquei abaixo algumas dicas para um bom começo:

  • Recomendo que faça a leitura deste guia e pratique imediatamente o que
    aprendeu. Isto facilita o entendimento do programa/comando/configuração.

  • É preciso ter interesse em aprender, se você tiver vontade em aprender
    algo, você terá menos dificuldade do que em algo que não gosta e está se
    obrigando a aprender.

  • Decorar não adianta, pelo contrário, só atrapalha no aprendizado. Você
    precisa entender o que o comando faz, deste modo você estará estimulando e
    desenvolvendo sua interpretação, e entenderá melhor o assunto (talvez até
    me de uma força para melhorar o guia ;-)

  • Curiosidade também é importante. Você talvez possa estar procurando um
    comando que mostre os arquivos que contém um certo texto, e isto fará você
    chegar até o comando grep, depois você conhecerá suas opções, etc.

  • Não desanime vendo outras pessoas que sabem mais que você, lembre-se que
    ninguém nasce sabendo :-). Uma pessoa pode ter mais experiência em um
    assunto no sistema como compilação de programas, configuração, etc., e você
    pode ter mais interesse em redes.

  • Ninguém pode saber tudo da noite para o dia, não procure saber TUDO sobre o
    sistema de uma só vez, senão não entenderá NADA. Caso tenha dúvidas sobre o
    sistema, procure ler novamente a seção do guia, e caso ainda não tenha
    entendido procure ajuda nas página de manual (veja “Páginas de Manual”), ou
    nas listas de discussão (veja “Listas de discussão”) ou me envie uma
    mensagem <gleydson@guiafoca.org>.

  • Certamente você buscará documentos na Internet que falem sobre algum
    assunto que este guia ainda não explica. Muito cuidado! O GNU/Linux é um
    sistema que cresce muito rapidamente, a cada semana uma nova versão é
    lançada, novos recursos são adicionados, seria maravilhoso se a
    documentação fosse atualizada com a mesma freqüência.

    Infelizmente a atualização da documentação não segue o mesmo ritmo
    (principalmente aqui no Brasil). É comum você encontrar na Internet
    documentos da época quando o kernel estava na versão 2.2.30, 2.4.8, 2.6.28,
    etc. Estes documentos são úteis para pessoas que por algum motivo
    necessitam operar com versões antigas do Kernel Linux, mas pode trazer
    problemas ou causar má impressão do GNU/Linux em outras pessoas.

    Por exemplo, você pode esbarrar pela Internet com um documento que diz que
    o Kernel não tem suporte aos "nomes extensos" da VFAT (Windows 95), isto é
    verdade para kernels anteriores ao 2.0.31, mas as versões mais novas que a
    2.0.31 reconhecem sem problemas os nomes extensos da partição Windows VFAT.

    Uma pessoa desavisada pode ter receio de instalar o GNU/Linux em uma mesma
    máquina com Windows por causa de um documento como este. Para evitar
    problemas deste tipo, verifique a data de atualização do documento, se
    verificar que o documento está obsoleto, contacte o autor original e peça
    para que ele retire aquela seção na próxima versão que será lançada.

  • O GNU/Linux é considerado um sistema mais difícil do que os outros, mas
    isto é porque ele requer que a pessoa realmente aprenda e conheça
    computadores e seus periféricos antes de fazer qualquer coisa
    (principalmente se você é um técnico em manutenção, redes, instalações,
    etc., e deseja oferecer suporte profissional a este sistema).

    Você conhecerá mais sobre computadores, redes, hardware, software, discos,
    saberá avaliar os problemas e a buscar a melhor solução, enfim as
    possibilidades de crescimento neste sistema operacional depende do
    conhecimento, interesse e capacidade de cada um.

  • A interface gráfica existe, mas os melhores recursos e flexibilidade estão
    na linha de comando. Você pode ter certeza que o aprendizado no GNU/Linux
    ajudará a ter sucesso e menos dificuldade em usar qualquer outro sistema
    operacional.

  • Peça ajuda a outros usuários do GNU/Linux quando estiver em dúvida ou não
    souber fazer alguma coisa no sistema. Você pode entrar em contato
    diretamente com outros usuários ou através de listas de discussão (veja
    “Listas de discussão”).

Boa Sorte e bem vindo ao GNU/Linux!

Gleydson (<gleydson@guiafoca.org>).

Pré-requisitos para a utilização deste guia

É assumido que você já tenha seu GNU/Linux instalado e funcionando.

Este guia não cobre a instalação do sistema. Para detalhes sobre instalação,
consulte a documentação que acompanha sua distribuição GNU/Linux.

Sistema Operacional

O Sistema Operacional é o conjunto de programas que fazem a interface do
usuário e seus programas com o computador. Ele é responsável pelo gerenciamento
de recursos e periféricos (como memória, discos, arquivos, impressoras,
CD-ROMs, etc.), interpretação de mensagens e a execução de programas.

No Linux o Kernel mais o conjunto de ferramentas GNU compõem o Sistema
Operacional. O kernel (que é a base principal de um sistema operacional),
poderá ser construído de acordo com a configuração do seu computador e dos
periféricos que possui.

O Linux

O Linux é um sistema operacional criado em 1991 por Linus Torvalds na
universidade de Helsinki na Finlândia. É um sistema Operacional de código
aberto distribuído gratuitamente pela Internet. Seu código fonte é liberado
como Free Software (software livre), sob licença GPL, o aviso de copyright do
kernel feito por Linus descreve detalhadamente isto e mesmo ele não pode fechar
o sistema para que seja usado apenas comercialmente.

Isto quer dizer que você não precisa pagar nada para usar o Linux, e não é
crime fazer cópias para instalar em outros computadores, nós inclusive
incentivamos você a fazer isto. Ser um sistema de código aberto pode explicar a
performance, estabilidade e velocidade em que novos recursos são adicionados ao
sistema.

O requisito mínimo para rodar o Linux depende do kernel que será usado:

  • 2.2.x - Computador 386 SX com 2 MB de memória

  • 2.4.x - Computador 386 SX com 4MB de memória

  • 2.6.x - Computador 486 DX com no mínimo 8MB

  • 3.x.x - Computador 586 com no mínimo 16MB

  • 4.x.x - Computador 586 com no mínimo 32MB

  • 5.x.x - Computador 686 com no mínimo 32MB

Para espaço em disco é requerido 900MB para uma instalação básica usando modo
texto com suporte a rede. Claro que não é considerada a execução de ambiente
gráfico ou serviços de rede em produção, que neste caso é exigido mais memória
RAM e espaço em disco para armazenamento de dados de programas e usuários.

O sistema segue o padrão POSIX que é o mesmo usado por sistemas UNIX e suas
variantes. Assim, aprendendo o Linux você não encontrará muita dificuldade em
operar um sistema do tipo UNIX, FreeBSD, HPUX, SunOS, etc., bastando apenas
aprender alguns detalhes encontrados em cada sistema.

O código fonte aberto permite que qualquer pessoa veja como o sistema funciona
(útil para aprendizado), corrigir algum problema ou fazer alguma sugestão sobre
sua melhoria, esse é um dos motivos de seu rápido crescimento, do aumento da
compatibilidade de periféricos (como novas placas sendo suportadas logo após
seu lançamento) e de sua estabilidade.

Outro ponto em que ele se destaca é o suporte que oferece a placas, CD/DVD-RWs,
BluRay e outros tipos de dispositivos de última geração e mais antigos (a
maioria deles já ultrapassados e sendo completamente suportados pelo sistema
operacional). Este é um ponto forte para empresas que desejam manter seus
micros em funcionamento e pretendem investir em avanços tecnológicos com as
máquinas que possui.

O Linux é desenvolvido por milhares de pessoas espalhadas pelo mundo, cada uma
fazendo sua contribuição ou mantendo alguma parte do kernel gratuitamente. 
Linus Torvalds ainda trabalha em seu desenvolvimento e na coordenação dos
grupos de trabalho do kernel.

O suporte ao sistema também se destaca como sendo o mais eficiente e rápido do
que qualquer programa comercial disponível no mercado. Existem milhares de
consultores e empresas especializadas no suporte e treinamento espalhados ao
redor do mundo. Outra opção de suporte é através da comunidade Linux; você pode
se inscrever em uma lista de discussão e relatar sua dúvida ou alguma falha, e
sua mensagem será vista por centenas de usuários na Internet e algum irá te
ajudar ou avisará as pessoas responsáveis sobre a falha encontrada para devida
correção.

Para detalhes, veja “Listas de discussão”.

Algumas Características do Linux

  • É livre e desenvolvido voluntariamente por programadores experientes,
    hackers, e contribuidores espalhados ao redor do mundo que tem como
    objetivo a contribuição para a melhoria e crescimento deste sistema
    operacional.

    Muitos deles estavam cansados do excesso de propaganda (Marketing) e baixa
    qualidade de sistemas comerciais existentes

  • Também recebe apoio de grandes empresas como IBM, Sun, RedHat, Intel, HP,
    etc. para seu desenvolvimento

  • Convivem sem nenhum tipo de conflito com outros sistemas operacionais (com
    o Windows, OS/2) no mesmo computador.

  • Multitarefa real

  • Multiusuário

  • Suporte a nomes extensos de arquivos e diretórios (255 caracteres)

  • Conectividade com outros tipos de plataformas como Apple, Sun, Macintosh,
    Sparc, Alpha, PowerPc, ARM, Unix, Windows, DOS, etc.

  • Utiliza permissões de acesso a arquivos, diretórios e programas em execução
    na memória RAM.

  • Proteção entre processos executados na memória RAM

  • Suporte a mais de 256 terminais virtuais (consoles)

  • Modularização - O Linux somente carrega para a memória o que é usado
    durante o processamento, liberando totalmente a memória assim que o
    programa/dispositivo é finalizado

  • Devido a modularização, os drivers dos periféricos e recursos do sistema
    podem ser carregados e removidos completamente da memória RAM a qualquer
    momento. Os drivers (módulos) ocupam pouco espaço quando carregados na
    memória RAM (cerca de 6Kb para a Placa de rede NE 2000, por exemplo)

  • Suporte nativo a rede e tecnologias avançadas como: balanceamento de carga,
    ips alias, failover, vlans, bridge, trunking, OSPF, BGP, MPLS.

  • Não há a necessidade de se reiniciar o sistema após a modificar a
    configuração de qualquer periférico ou parâmetros de rede. Somente é
    necessário reiniciar o sistema no caso de uma instalação interna de um novo
    periférico, falha em algum hardware (queima do processador, placa mãe,
    etc.).

  • Excepcional em escalabilidade desde computadores extreamemente
    simples,dispositivos móveis (sistema Android utiliza kernel Linux),
    Raspberry PI, sistemas embarcados, geladeiras inteligentes, carros com
    centrais inteligentes, etc. até sistemas de clusters em núvem gigantescos
    (como Amazon, Digital Ocean, entre maiores datacenters utilizados em núvens
    no mundo).

  • Suporte nativo a múltiplas CPUs e multi threads, assim processadores como
    Dual Core, Core Duo, Athlon Duo, Quad Core, XEON, i3-i9 tem seu poder de
    processamento integralmente aproveitado, tanto em 32 ou 64 bits.

  • Suporte nativo a dispositivos SSD, SATA, PATA, Fiber Channel

  • Suporte nativo a virtualização, onde o Linux se destaca como plataforma
    preferida para execução de múltiplos sistemas operacionais com performance
    e segurança. Nuvens como Amazon, Digital Ocean utilizam nativamente KVM
    para execucução de plataformas, assim como o sistema CGROUPs para execução
    de containers.

  • O crescimento e novas versões do sistema não provocam lentidão, pelo
    contrário, a cada nova versão os desenvolvedores procuram buscar maior
    compatibilidade, acrescentar recursos úteis e melhor desempenho do sistema
    (como o que aconteceu na passagem do kernel 2.0.x para 2.2.x, da 2.2.x para
    a 2.4.x, da 3 para a 4.x.x, da 4.x.x para a 5.x.x)

  • O GNU/Linux é distribuido livremente e licenciado de acordo com os termos
    da GPLv2.

  • Acessa corretamente discos formatados pelo DOS, Windows, Novell, OS/2,
    NTFS, SunOS, Amiga, Atari, Mac, etc.

  • O LINUX POSSUI MECANISMOS DE HARDENING AVANÇADOS CONTRA VÍRUS E MALWARES!
    Devido a separação de privilégios entre processos e respeitadas as
    recomendações padrão de política de segurança e uso de contas privilegiadas
    (como a de root, como veremos adiante), programas como vírus tornam-se
    inúteis pois tem sua ação limitada pelas restrições de acesso do sistema de
    arquivos e execução.

    Qualquer programa (nocivo ou não) poderá alterar partes do sistema que
    possui permissões (será abordado como alterar permissões e tornar seu
    sistema mais restrito no decorrer do guia). Frequentemente são criados
    exploits que tentam se aproveitar de falhas existentes em sistemas
    desatualizados e usa-las para causar danos. Erroneamente este tipo de
    ataque é classificado como vírus por pessoas mal informadas e são
    resolvidas com sistemas bem mantidos. Em geral, usando uma boa distribuição
    que tenha um eficiente sistema de atualização e bem configurado, você terá
    99.9% de sua tranquilidade.

  • Rede TCP/IP mais rápida que no Windows e tem sua pilha constantemente
    melhorada. O GNU/Linux tem suporte nativo a redes TCP/IP e não depende de
    uma camada intermediária como o WinSock. Em acessos via modem a Internet, a
    velocidade de transmissão é 10% maior.

  • Executa outros sistemas operacionais como Windows, MacOS, DOS ou outro
    sistema Linux através de consagrados sistemas de virtualização como KVM, 
    Xen, vmware VirtualBox, ou emulação como o DOSEMU, QEMU, WINE.

  • Suporte completo e nativo a diversos dispositivos de comunicação via
    infravermelho, Bluetooth, Firewire, USB. Basta conectar e o seu dispositivo
    é automaticamente reconhecido. Raramente são necessários drivers externos,
    exceto no caso de dispositivos muito novos que não tenham o suporte ainda
    adicionado no sistema.

  • Suporte a fiber channel.

  • Suporte a rede via rádio amador.

  • Suporte a dispositivos Plug-and-Play.

  • Suporte nativo a pen drivers, dispositivos de armazenamento e cartões de
    memória.

  • Suporte nativo a dispositivos I2C

  • Integração com gerenciamento de energia ACPI e APM

  • Dispositivos de rede Wireless. Tanto com criptografia WEB e WPA2/3 PSK

  • Vários tipos de firewalls avançados de alta qualidade na detecção de
    tráfego indesejável, dando ao administrador uma excelente ferramenta de
    proteção e controle de sua rede.

  • Roteamento estático e dinâmico de pacotes.

  • Ponte entre Redes, proxy arp

  • Proxy Tradicional e Transparente.

  • Possui recursos para atender a mais de um endereço IP na mesma placa de
    rede, sendo muito útil para situações de manutenção em servidores de redes
    ou para a emulação de "múltiplos computadores".

    O servidor WEB e FTP podem estar localizados no mesmo computador, mas o
    usuário que se conecta tem a impressão que a rede possui servidores
    diferentes.

  • Os sistemas de arquivos usados pelo GNU/Linux (Ext2, Ext3, reiserfs, xfs,
    jfs) organiza os arquivos de forma inteligente evitando a fragmentação e
    fazendo-o um poderoso sistema para aplicações multi-usuárias exigentes e
    gravações intensivas.

  • Permite a montagem de um servidor de publicação Web, E-mail, News, etc. com
    um baixo custo e alta performance. O melhor servidor Web do mercado, o 
    Apache, é distribuído gratuitamente junto com a maioria das distribuições
    Linux. O mesmo acontece com o Sendmail.

  • Por ser um sistema operacional de código aberto, você pode ver o que o
    código fonte (instruções digitadadas pelo programador) faz e adapta-lo as
    suas necessidades ou de sua empresa. Esta característica é uma segurança a
    mais para empresas sérias e outros que não querem ter seus dados roubados
    (você não sabe o que um sistema sem código fonte faz na realidade enquanto
    esta processando o programa).

  • Suporte a diversos dispositivos e periféricos disponíveis no mercado, tanto
    os novos como obsoletos.

  • Pode ser executado em 16 arquiteturas diferentes (Intel, Macintosh, Alpha,
    Arm, etc.) e diversas outras sub-arquiteturas.

  • Empresas especializadas e consultores especializados no suporte ao sistema
    espalhados por todo o mundo.

  • Entre muitas outras características que você descobrirá durante o uso do
    sistema (além de poder criar outras, caso seja um administrador avançado ou
    desenvolvedor).

TODOS OS ÍTENS DESCRITOS ACIMA SÃO VERDADEIROS E TESTADOS PARA QUE TIVESSE
PLENA CERTEZA DE SEU FUNCIONAMENTO.

Distribuições do Linux

Só o kernel GNU/Linux não é suficiente para se ter uma sistema funcional, mas é
o principal.

Existem grupos de pessoas, empresas e organizações que decidem "distribuir" o
Linux junto com outros aplicativos (como por exemplo editores gráficos,
planilhas, bancos de dados, ambientes de programação, formatação de documentos,
firewalls, etc).

Este é o significado essencial de distribuição. Cada distribuição tem sua
característica própria, como o sistema de instalação, o objetivo, a localização
de programas, nomes de arquivos de configuração, etc. A escolha de uma
distribuição é pessoal e depende das necessidades de cada um.

Algumas distribuições bastante conhecidas são: Ubuntu, Debian, Slackware, Red
Hat, Gentoo, Suse todas usando o SO Linux como kernel principal (a Debian é uma
distribuição independente de kernel e pode ser executada sob outros kernels,
como o GNU hurd ou o kernel BSD).

A escolha de sua distribuição deve ser feita com muita atenção, não adianta
muita coisa perguntar em canais de IRC sobre qual é a melhor distribuição, ser
levado pelas propagandas, pelo vizinho, etc. O melhor caminho para a escolha da
distribuição, acredito eu, seria perguntar as características de cada uma e
porque essa pessoa gosta dela ao invés de perguntar qual é a melhor, porque
quem lhe responder isto estará usando uma distribuição que se encaixa de acordo
com suas necessidade e esta mesma distribuição pode não ser a melhor para lhe
atender.

Segue abaixo as características de algumas distribuições seguidas do site
principal e endereço para download:

Debian

    http://www.debian.org/ - Distribuição desenvolvida e atualizada através do
    esforço de voluntários espalhados ao redor do mundo, seguindo o estilo de
    desenvolvimento GNU/Linux. Por este motivo, foi adotada como a distribuição
    oficial do projeto GNU. Possui suporte a língua Portuguesa, é a única que
    tem suporte a 9 arquiteturas diferentes (AMD64, i386, ARMEL, ARMHF,
    MIPS,MIPSEL,MIPS64el, etc.) e aproximadamente 15 arquitetura não suportadas
    oficialmente. A instalação da distribuição pode ser feita tanto através de
    flash disks, CD-ROM, Tftp, Ftp, NFS, imagem Docker ou através da combinação
    de vários destes em cada etapa de instalação.

    Acompanha mais de 59000 programas distribuídos em forma de pacotes cada um
    destes programas são mantidos e testados pela pessoa ou grupo responsável
    por seu empacotamento. Os pacotes são divididos em diretórios de acordo com
    sua categoria e gerenciados através de um avançado sistema de gerenciamento
    de pacotes (o apt e o dpkg) facilitando a instalação e atualização de
    pacotes. Possui tanto ferramentas para administração de redes e servidores
    quanto para desktops, estações multimídia, jogos, desenvolvimento, web,
    etc.

    A atualização da distribuição ou de pacotes individuais pode ser feita
    facilmente através de 2 comandos, não requerendo adquirir um novo CD para
    usar a última versão da distribuição. É a única distribuição não comercial
    onde todos podem contribuir usando seu conhecimento para o desenvolvimento.
    Para gerenciar os voluntários, conta com centenas de listas de discussão
    envolvendo determinados desenvolvedores das mais diversas partes do mundo.

    São feitos extensivos testes antes do lançamento de cada versão para
    atingir um alto grau de confiabilidade. As falhas encontradas nos pacotes
    podem ser relatados através de um sistema de tratamento de falhas que
    encaminha a falha encontrada diretamente ao responsável para avaliação e
    correção. Qualquer um pode receber a lista de falhas ou sugestões sobre a
    distribuição cadastrando-se em uma das lista de discussão que tratam
    especificamente da solução de falhas encontradas na distribuição
    (disponível na página principal da distribuição).

    Os pacotes podem ser instalados através de Tarefas contendo seleções de
    pacotes de acordo com a utilização do computador (servidor Web,
    desenvolvimento, TeX, jogos, desktop, etc.), Perfis contendo seleções de
    pacotes de acordo com o tipo de usuário (programador, operador, etc.), ou
    através de uma seleção individual de pacotes, garantindo que somente os
    pacotes selecionados serão instalados fazendo uma instalação enxuta.

    Existe um time de desenvolvedores com a tarefa específica de monitorar
    atualizações de segurança em serviços (apache, sendmail, e todos os outros
    59000 pacotes) que possam comprometer o servidor, deixando-o vulnerável a
    ataques. Assim que uma falha é descoberta, é enviado uma alerta (DSA -
    Debian Security Alert) e disponibilizada uma atualização para correção das
    diversas versões da Debian. Isto é geralmente feito em menos de 48 horas
    desde a descoberta da falha até a divulgação da correção. Como quase todas
    as falhas são descobertas nos programas, este método também pode ser usado
    por administradores de outras distribuições para manterem seu sistema
    seguro e atualizado.

    O suporte ao usuário e desenvolvimento da distribuição são feitos através
    de listas de discussões e canais IRC. Existem uma lista de consultores
    habilitados a dar suporte e assistência a sistemas Debian ao redor do mundo
    na área consultores do site principal da distribuição.

    ftp://ftp.debian.org/ - Endereço para download.

Ubuntu

    http://www.ubuntu.com/ - Variante da distribuição Debian voltada a
    interação mais amigável com o usuário final e facilidade de instalação.
    Atualmente é a melhor para usuários que tem o primeiro contato com o Linux.
    Conta tanto com a instalação do sistema em HD e execução através de Live
    CD.

    http://www.ubuntu.com/getubuntu/download/ - Endereço para download do
    Ubuntu.

Slackware

    http://www.slackware.com/ - Distribuição desenvolvida por Patrick
    Volkerding, desenvolvida para alcançar facilidade de uso e estabilidade
    como prioridades principais. Foi a primeira distribuição a ser lançada no
    mundo e costuma trazer o que há de mais novo enquanto mantém uma certa
    tradição, provendo simplicidade, facilidade de uso e com isso flexibilidade
    e poder.

    Desde a primeira versão lançada em Abril de 1993, o Projeto Slackware Linux
    tem buscado produzir a distribuição Linux mais UNIX-like, ou seja, mais
    parecida com UNIX. O Slackware segue os padrões Linux como o Linux File
    System Standard, que é um padrão de organização de diretórios e arquivos
    para as distribuições.

    Enquanto as pessoas diziam que a Red Hat era a melhor distribuição para o
    usuário iniciante, o Slackware é o melhor para o usuário mais "velho", ou
    seja programadores, administradores, etc.

    ftp://ftp.slackwarebrasil.org/linux/slackware/ - Ftp da distribuição
    Slackware.

SuSE

    http://www.suse.com/ - Distribuição comercial Alemã com a coordenação sendo
    feita através dos processos administrativos dos desenvolvedores e de seu
    braço norte-americano. O foco da Suse é o usuário com conhecimento técnico
    no Linux (programador, administrador de rede, etc.) e não o usuário
    iniciante no Linux. Preferencialmente a administração deve ser feita usando
    o Yast, mas também pode ser feita manualmente através de alteração dos
    arquivos de configuração.

    Possui suporte as arquiteturas Intel x86 e Alpha. Sua instalação pode ser
    feita via CD-ROM ou CD-DVD (é a primeira distribuição com instalação
    através de DVD).

    Uma média de 2000 programas acompanham a versão 10 distribuídos em 6 DVDs.
    O sistema de gerenciamento de pacotes é o RPM padronizado. A seleção de
    pacotes durante a instalação pode ser feita através da seleção do perfil de
    máquina (developer, estação kde, gráficos, estação gnome, servidor de rede,
    etc.) ou através da seleção individual de pacotes.

    A atualização da distribuição pode ser feita através do CD-ROM de uma nova
    versão ou baixando pacotes de ftp://ftp.suse.com/. Usuários registrados
    ganham direito a suporte de instalação via e-mail. A base de dados de
    suporte também é excelente e está disponível na web para qualquer usuário
    independente de registro.

    ftp://ftp.suse.com/ - Ftp da distribuição SuSE.

Red Hat Enterprise Linux

    http://www.redhat.com/ - Distribuição comercial suportada pela Red Hat e
    voltada a servidores de grandes e medias empresas. Também conta com uma
    certificação chamada RHCE específica desta distro.

    Ela não está disponível para download, apenas vendida a custos a partir de
    179 dólares (a versão workstation) até 1499 dólares (advanced server).

Fedora

    http://fedora.redhat.com/ - O Fedora Linux é a distribuição de
    desenvolvimento aberto patrocinada pela RedHat e pela comunidade, originada
    em 2002 e baseada em versão da antiga linha de produtos RedHat Linux. Esta
    distribuição não é suportada pela Red Hat como distribuição oficial (ela
    suporta apenas a linha Red Hat Enterprise Linux), devendo obter suporte
    através da comunidade ou outros meios.

    A distribuição Fedora dá prioridade ao uso do computador como estação de
    trabalho. Além de contar com uma ampla gama de ferramentas de escritório
    possui funções de servidor e aplicativos para produtividade e
    desenvolvimento de softwares. Considerado um dos sistemas mais fáceis de
    instalar e utilizar, inclui tradução para portugês do Brasil e suporte às
    plataformas Intel e 64 bits.

    Por basear-se no RedHat. o Fedora conta com um o up2date, um software para
    manter o sistema atualizado e utiliza pacotes de programas no formato RPM,
    um dos mais comuns.

    O Fedora não é distribuido oficialmente através de mídias ou CDs, se você
    quiser obte-lo terá de procurar distribuidores independentes ou fazer o
    download dos 4 CDs através do site oficial.

    http://download.fedora.redhat.com/pub/fedora/linux/core/2/i386/iso/ -
    Download da distribuição Fedora.

Para contato com os grupos de usuários que utilizam estas distribuições, veja
“Listas de discussão”.

Software Livre

(tradução do texto Linux e o Sistema GNU de Richard Stallman obtido no site do
CIPSGA: http://www.cipsga.org.br/). O projeto GNU começou em 1983 com o
objetivo de desenvolver um sistema operacional Unix-like totalmente livre.
Livre se refere à liberdade, e não ao preço; significa que você está livre para
executar, distribuir, estudar, mudar e melhorar o software.

Um sistema Unix-like consiste de muitos programas diferentes. Nós achamos
alguns componentes já disponíveis como softwares livres -- por exemplo, X
Window e TeX. Obtemos outros componentes ajudando a convencer seus
desenvolvedores a tornarem eles livres -- por exemplo, o Berkeley network
utilities. Outros componentes nós escrevemos especificamente para o GNU -- por
exemplo, GNU Emacs, o compilador GNU C, o GNU C library, Bash e Ghostscript. Os
componentes desta última categoria são "software GNU". O sistema GNU consiste
de todas as três categorias reunidas.

O projeto GNU não é somente desenvolvimento e distribuição de alguns softwares
livres úteis. O coração do projeto GNU é uma idéia: que software deve ser livre
, e que a liberdade do usuário vale a pena ser defendida. Se as pessoas têm
liberdade mas não a apreciam conscientemente, não irão mantê-la por muito
tempo. Se queremos que a liberdade dure, precisamos chamar a atenção das
pessoas para a liberdade que elas têm em programas livres.

O método do projeto GNU é que programas livres e a idéia da liberdade dos
usuários ajudam-se mutuamente. Nós desenvolvemos software GNU, e conforme as
pessoas encontrem programas GNU ou o sistema GNU e comecem a usá-los, elas
também pensam sobre a filosofia GNU. O software mostra que a idéia funciona na
prática. Algumas destas pessoas acabam concordando com a idéia, e então
escrevem mais programas livres. Então, o software carrega a idéia, dissemina a
idéia e cresce da idéia.

Em 1992, nós encontramos ou criamos todos os componentes principais do sistema
exceto o kernel, que nós estávamos escrevendo. (Este kernel consiste do
microkernel Mach mais o GNU HURD. Atualmente ele está funcionando, mas não está
preparado para os usuários. Uma versão alfa deverá estar pronta em breve.)

Então o kernel do Linux tornou-se disponível. Linux é um kernel livre escrito
por Linus Torvalds compatível com o Unix. Ele não foi escrito para o projeto
GNU, mas o Linux e o quase completo sistema GNU fizeram uma combinação útil.
Esta combinação disponibilizou todos os principais componentes de um sistema
operacional compatível com o Unix, e, com algum trabalho, as pessoas o tornaram
um sistema funcional. Foi um sistema GNU variante, baseado no kernel do Linux.

Ironicamente, a popularidade destes sistemas desmerece nosso método de
comunicar a idéia GNU para as pessoas que usam GNU. Estes sistemas são
praticamente iguais ao sistema GNU -- a principal diferença é a escolha do
kernel. Porém as pessoas normalmente os chamam de "sistemas Linux (Linux
systems)". A primeira impressão que se tem é a de que um "sistema Linux" soa
como algo completamente diferente de "sistema GNU", e é isto que a maioria dos
usuários pensam que acontece.

A maioria das introduções para o "sistema Linux" reconhece o papel desempenhado
pelos componentes de software GNU. Mas elas não dizem que o sistema como um
todo é uma variante do sistema GNU que o projeto GNU vem compondo por uma
década. Elas não dizem que o objetivo de um sistema Unix-like livre como este
veio do projeto GNU. Daí a maioria dos usuários não saber estas coisas.

Como os seres humanos tendem a corrigir as suas primeiras impressões menos do
que as informações subseqüentes tentam dizer-lhes, estes usuários que depois
aprendem sobre a relação entre estes sistemas e o projeto GNU ainda geralmente
o subestima.

Isto faz com que muitos usuários se identifiquem como uma comunidade separada
de "usuários de Linux", distinta da comunidade de usuários GNU. Eles usam todos
os softwares GNU; de fato, eles usam quase todo o sistema GNU; mas eles não
pensam neles como usuários GNU, e freqüentemente não pensam que a filosofia GNU
está relacionada a eles.

Isto leva a outros problemas também -- mesmo dificultando cooperação com a
manutenção de programas. Normalmente quando usuários mudam um programa GNU para
fazer ele funcionar melhor em um sistema específico, eles mandam a mudança para
o mantenedor do programa; então eles trabalham com o mantenedor explicando a
mudança, perguntando por ela, e às vezes reescrevendo-a para manter a coerência
e mantenebilidade do pacote, para ter o patch instalado.

Mas as pessoas que pensam nelas como "usuários Linux" tendem a lançar uma
versão "Linux-only" do programa GNU, e consideram o trabalho terminado. Nós
queremos cada e todos os programas GNU que funcionem "out of the box" em
sistemas baseados em Linux; mas se os usuários não ajudarem, este objetivo se
torna muito mais difícil de atingir.

Como deve o projeto GNU lidar com este problema? O que nós devemos fazer agora
para disseminar a idéia de que a liberdade para os usuários de computador é
importante?

Nós devemos continuar a falar sobre a liberdade de compartilhar e modificar
software -- e ensinar outros usuários o valor destas liberdades. Se nós nos
beneficiamos por ter um sistema operacional livre, faz sentido para nós pensar
em preservar estas liberdades por um longo tempo. Se nós nos beneficiamos por
ter uma variedade de software livres, faz sentido pensar sobre encorajar outras
pessoas a escrever mais software livre, em vez de software proprietário.

Nós não devemos aceitar a idéia de duas comunidades separadas para GNU e Linux.
Ao contrário, devemos disseminar o entendimento de que "sistemas Linux" são
variantes do sistema GNU, e que os usuários destes sistemas são tanto usuários
GNU como usuários Linux (usuários do kernel do Linux). Usuários que têm
conhecimento disto irão naturalmente dar uma olhada na filosofia GNU que fez
estes sistemas existirem.

Eu escrevi este artigo como um meio de fazer isto. Outra maneira é usar os
termos "sistema GNU baseado em Linux (Linux-based GNU system)" ou "sistema GNU/
Linux (GNU/Linux system)", em vez de "sistema Linux", quando você escreve sobre
ou menciona este sistema.

Processamento de Dados

Processamento de Dados é o envio de dados ao computador que serão processados e
terão um resultado de saída útil.

Veja também “Dispositivos de Entrada e Saída”.

O Computador

É uma máquina eletrônica que processa e armazena os dados e pode executar
diversos programas para realizar uma série de tarefas e assim atender a
necessidade do seu utilizador. O computador não é uma máquina inteligente, ele
apenas executa as instruções dos programas que foram escritos pelo programador.

Conhecendo o Computador

Esta explica para que serve cada botão do painel do computador e monitor de
vídeo. Se você já sabe para que cada um serve, recomendo pular esta parte, é o
BE-A-BA. :-)

Todo computador possuem funções que são usados em outros tipos e modelos. Você
pode ter um modelo de computador e um amigo seu outro tipo e mesmo tendo
aparência diferente, terão as mesmas funções.

Tipos de Gabinete

Quanto ao tipo, o gabinete pode ser Desktop, Mini-torre e Torre.

Desktop

    É usado na posição Horizontal (como o vídeo cassete). Sua característica é
    que ocupa pouco espaço em uma mesa, pois pode ser colocado sob o monitor. A
    desvantagem é que normalmente possui pouco espaço para a colocação de novas
    placas e periféricos. Outra desvantagem é a dificuldade na manutenção deste
    tipo de equipamento (hardware).

Mini-Torre

    É usado na posição Vertical (torre). É o modelo mais usado. Sua
    característica é o espaço interno para expansão e manipulação de
    periféricos. A desvantagem é o espaço ocupado em sua mesa :-).

Torre

    Possui as mesmas características do Mini-torre, mas tem uma altura maior e
    mais espaço para colocação de novos periféricos. Muito usado em servidores
    de rede e placas que requerem uma melhor refrigeração.

Painel Frontal

O painel frontal do computador tem os botões que usamos para ligar, desligar, e
acompanhar o funcionamento do computador. Abaixo o significado de cada um:

Botão POWER

    Liga/Desliga o computador.

Botão TURBO

    Se ligado, coloca a placa mãe em operação na velocidade máxima (o padrão).
    Desligado, faz o computador funcionar mais lentamente (depende de cada
    placa mãe). Deixe sempre o TURBO ligado para seu computador trabalhar na
    velocidade máxima de processamento.

Botão RESET

    Reinicia o computador. Quando o computador é reiniciado, uma nova partida é
    feita (é como se nós ligássemos novamente o computador). Este botão é um
    dos mais usados por usuários Windows dentre os botões localizados no painel
    do microcomputador. No GNU/Linux é raramente usado (com menos freqüência
    que a tecla SCROLL LOCK).

    É recomendado se pressionar as teclas <CTRL> <ALT> <DEL> para reiniciar o
    computador e o botão RESET somente em último caso, pois o <CTRL> <ALT>
    <DEL> avisa ao Linux que o usuário pediu para o sistema ser reiniciado
    assim ele poderá salvar os arquivos, fechar programas e tomar outras
    providências antes de resetar o computador.

KEYLOCK

    Permite ligar/desligar o teclado. É acionado por uma chave e somente na
    posição "Cadeado Aberto" permite a pessoa usar o teclado (usar o
    computador). Alguns computadores não possuem KEYLOCK.

LED POWER

    Led (normalmente verde) no painel do computador que quando aceso, indica
    que o computador está ligado. O led é um diodo emissor de luz (light
    emission diode) que emite luz fria.

LED TURBO

    Led (normalmente amarelo) no painel do computador. Quando esta aceso,
    indica que a chave turbo está ligada e o computador funcionando a toda
    velocidade.

    Raramente as placas mãe Pentium e acima usam a chave turbo. Mesmo que
    exista no gabinete do micro, encontra-se desligada.

LED HDD

    Led (normalmente vermelho) no painel do computador. Acende quando o disco
    rígido (ou discos) do computador esta sendo usado.

    Também acende quando uma unidade de CD-ROM está conectada na placa mãe e
    for usado.

Monitor de Vídeo

O monitor de vídeo se divide em dois tipos:

  • Monocromático - Mostra tons de cinza

  • Policromático - A conhecida tela colorida

Quanto ao padrão do monitor, existem diversos:

CGA - Color Graphics Adapter

    Capacidade de mostrar 4 cores simultâneas em modo gráfico. Uma das
    primeiras usadas em computadores PCs, com baixa qualidade de imagem, poucos
    programas funcionavam em telas CGA, quase todos em modo texto. Ficou muito
    conhecida como "tela verde" embora existem modelos CGA preto e branco.

Hércules

    Semelhante ao CGA. Pode mostrar 2 cores simultâneas em modo gráfico. A
    diferença é que apresenta uma melhor qualidade para a exibição de gráficos
    mas por outro lado, uma grande variedade de programas para monitores CGA
    não funcionam com monitores Hércules por causa de seu modo de vídeo. Também
    é conhecido por sua imagem amarela.

    Dependendo da placa de vídeo, você pode configurar um monitor Hércules
    monocromático para trabalhar como CGA.

EGA - Enhanced Graphics Adapter

    Capacidade de mostrar 16 cores simultâneas em modo gráfico. Razoável
    melhora da qualidade gráfica, mais programas rodavam neste tipo de tela.
    Ficou mais conhecida após o lançamento dos computadores 286, mas no Brasil
    ficou pouco conhecida pois logo em seguida foi lançada o padrão VGA.

VGA - Video Graphics Array

    Capacidade de mostrar 256 cores simultâneas. Boa qualidade gráfica, este
    modelo se mostrava capaz de rodar tanto programas texto como gráficos com
    ótima qualidade de imagem. Se tornou o padrão mínimo para rodar programas
    em modo gráfico.

SVGA - Super Video Graphics Array

    Atual padrão de mercado, capaz de mostrar até 16 milhões de cores
    simultâneas. Excelente qualidade gráfica, também capaz de operar
    corretamente em modo texto.

Placa Mãe

É a placa principal do sistema onde estão localizados o Processador, Memória
RAM, Memória Cache, BIOS, CMOS, RTC, etc. A placa mãe possui encaixes onde são
inseridas placas de extensão (para aumentar as funções do computador). Estes
encaixes são chamados de "SLOTS".

Alguns componentes da placa mãe

Abaixo a descrição de alguns tipos de componentes eletrônicos que estão
presentes na placa mãe. Não se preocupe se não entender o que eles significam
agora:

  • RAM - Memória de Acesso Aleatório (Randomic Access Memory). É uma memória
    de armazenamento temporário dos programas e depende de uma fonte de energia
    para o armazenamento dos programas. É uma memória eletrônica muito rápida
    assim os programas de computador são executados nesta memória. Seu tamanho
    é medido em Kilobytes, Megabytes ou Gigabytes.

    Os chips de memória RAM podem ser independentes (usando circuitos
    integrados encaixados em soquetes na placa mãe) ou agrupados placas de 30
    pinos, 72 pinos e 168 pinos.

    Quanto maior o tamanho da memória, mais espaço o programa terá ao ser
    executado. O tamanho de memória RAM pedido por cada programa varia, o GNU/
    Linux precisa de no mínimo 8 MB de memória RAM para ser executado pelo
    processador.

  • PROCESSADOR - É a parte do computador responsável pelo processamentos das
    instruções matemáticas/lógicas e programas carregados na memória RAM.

  • CO-PROCESSADOR - Ajuda o Processador principal a processar as instruções
    matemáticas. É normalmente embutido no Processador principal em
    computadores a partir do 486 DX2-66. Em processadores Pentium e superiores,
    o co-processador é sempre embutido no processador.

  • CACHE - Memória de Armazenamento Auxiliar do Processador. Possui alta
    velocidade de funcionamento, normalmente a mesma que o processador. Serve
    para aumentar o desempenho de processamento. A memória Cache pode ser
    embutida na placa mãe ou encaixada externamente através de módulos L2.

  • BIOS - É a memória ROM que contém as instruções básicas para a
    inicialização do computador, reconhecimento e ativação dos periféricos
    conectados a placa mãe. As BIOS mais modernas (a partir do 286) também
    trazem um programa que é usado para configurar o computador modificando os
    valores localizados na CMOS.

    As placas controladoras SCSI possuem sua própria BIOS que identificam
    automaticamente os periféricos conectados a ela. Os seguintes tipos de
    chips podem ser usados para gravar a BIOS:

      □ ROM - Memória Somente para Leitura (Read Only Memory). Somente pode ser
        lida. É programada de fábrica através de programação elétrica ou
        química.

      □ PROM - Memória Somente para Leitura Programável (Programable Read Only
        Memory) idêntica a ROM mas que pode ser programada apenas uma vez por
        máquinas "Programadoras PROM". É também chamada de MASK ROM.

      □ EPROM - Memória semelhante a PROM, mas seu conteúdo pode ser apagado
        através raios ultra-violeta.

      □ EEPROM - Memória semelhante a PROM, mas seu conteúdo pode ser apagado e
        regravado. Também é chamada de Flash.

  • CMOS - É uma memória temporária alimentada por uma Bateria onde são lidas/
    armazenadas as configurações do computador feitas pelo programa residente
    na BIOS.

Memória do Computador

A memória é a parte do computador que permitem o armazenamento de dados. A
memória é dividida em dois tipos: Principal e Auxiliar. Normalmente quando
alguém fala em "memória de computador" está se referindo a memória "Principal".
Veja abaixo as descrições de Memória Principal e Auxiliar.

Memória Principal

É um tipo de memória eletrônica que depende de uma fonte de energia para manter
os dados armazenados e perde os dados quando a fonte de energia é desligada. A
memória RAM do computador (Randomic Access Memory - Memória de Acesso
aleatório) é o principal exemplo de memória de armazenamento Principal.

Os dados são armazenados em circuitos integrados ("chips") e enquanto você está
usando seu computador, a RAM armazena e executa seus programas. Os programas
são executados na memória RAM porque a memória eletrônica é muito rápida. As
memórias EDO, DIMM, DDR, DDR2, DDR3 são exemplos de memória RAM.

Se desligarmos o computador ou ocorrer uma queda de energia, você perderá os
programas que estiverem em execução ou o trabalho que estiver fazendo. Por esse
motivo é necessário o uso de uma memória auxiliar (veja “Memória Auxiliar”).

Memória Auxiliar

São dispositivos que NÃO dependem de uma fonte de energia para manter os dados
armazenados, os dados não são perdidos quando a fonte de energia é desligada.
As Memórias Auxiliares são muito mais lentas que as Memórias Principais porque
utilizam mecanismos mecânicos e elétricos (motores e eletroímãs) para funcionar
e fazer a leitura/gravação dos dados. Existem também modelos chamados disco de
estado sólido (SSD), os dados são armazenados em chips eletrônicos ao invés de
mecanismos mecânicos.

Um exemplo de dispositivos de armazenamento auxiliar são os pen drives,
disquetes, cartões SD, discos rígidos, unidades de fita, Zip Drives, DVD/CD/
BluRay, etc.

A Memória Auxiliar resolve o problema da perda de dados causado pela Memória
Principal quando o computador é desligado, desta forma podemos ler nossos
arquivos e programas da memória Auxiliar e copia-los para a Memória Principal
(memória RAM) para que possam ser novamente usados.

Um exemplo simples é de quando estiver editando um texto e precisar salva-lo, o
que você faz é simplesmente salvar os dados da memória RAM que estão sendo
editados para o disco rígido, desta forma você estará guardando seu documento
na Memória Auxiliar.

Este tipo de memória é mais lento que a memória principal, é por este motivo
que os programas somente são carregados e executados na Memória Principal.

Discos

Os discos são memórias de armazenamento Auxiliares. Entre os vários tipos de
discos existentes, posso citar os Flexíveis, Rígidos, Pen-drives, SSD e CDs.
Veja as explicações sobre cada um deles abaixo.

Discos Flexíveis

São discos usados para armazenar e transportar pequenas quantidades de dados.
Este tipo de disco é normalmente encontrado no tamanho 3 1/2 (1.44MB) polegadas
e 5 1/4 polegadas (360Kb ou 1.2MB). Hoje os discos de 3 1/2 são os mais
utilizados por terem uma melhor proteção por causa de sua capa plástica rígida,
maior capacidade e o menor tamanho o que facilita seu transporte.

Os disquetes são inseridos em um compartimento chamado de "Unidade de
Disquetes" ou "Drive" que faz a leitura/gravação do disquete.

Sua característica é a baixa capacidade de armazenamento e baixa velocidade no
acesso aos dados mas podem ser usados para transportar os dados de um
computador a outro com grande facilidade. Os disquetes de computador comuns são
discos flexíveis.

Disco Rígido

É um disco localizado dentro do computador. É fabricado com discos de metal
recompostos por material magnético onde os dados são gravados através de
cabeças e revestido externamente por uma proteção metálica que é preso ao
gabinete do computador por parafusos. Também é chamado de HD (Hard Disk) ou
Winchester. É nele que normalmente gravamos e executamos nossos programas mais
usados.

Existe também um tipo de disco rígido chamado SSD (disco de estado sólido). A
diferença deste disco para o disco rígido comum, é que no SSD os dados são
armazenados em chips ao invés de disco magnético.

A característica deste tipo de disco é a alta capacidade de armazenamento de
dados e alta velocidade no acesso aos dados.

CD/DVD/BluRay

É um tipo de disco que permite o armazenamento de dados através de um compact
disc e os dados são lidos através de uma lente ótica. A Unidade de CD é
localizada no gabinete do computador e pode ler CDs de músicas, arquivos,
interativos, etc. Existem diversos tipos de CDs no mercado, entre eles:

  • CD-R - CD gravável, pode ser gravado apenas uma vez. Possui sua capacidade
    de armazenamento entre 600MB e 740MB dependendo do formato de gravação
    usado. Usa um formato lido por todas as unidades de CD-ROM disponíveis no
    mercado.

  • CD-RW - CD regravável, pode ser gravado várias vezes, ter seus arquivos
    apagados, etc. Seu uso é semelhante ao de um disquete de alta capacidade.
    Possui capacidade de armazenamento de normalmente 640MB mas isto depende do
    fabricante. Usa um formato que é lido apenas por unidades leitoras e
    gravadoras multiseção.

  • DVD-ROM - Alta capacidade de armazenamento. Pode armazenar até 8GB de
    arquivos ou programas quando usado em dual layer. BluRay - Alta capacidade
    de armazenamento. Pode armazenar mais de 50GB de arquivos ou programas
    quando usado em dual layer. É um tipo de CD muito novo no mercado e ainda
    em desenvolvimento. É lido somente por unidades próprias para este tipo de
    disco.

Cuidados Básicos com o Computador

Abaixo uma lista de cuidados básicos para garantir uma melhor conservação e
funcionamento de seu computador.

  • Não deixe seu computador em locais expostos a umidade ou sol. O mesmo se
    aplica a mídias como pen-drives, gavetas de HD, cartões de memória etc.

  • Limpe o Gabinete e o Monitor com um pano levemente umedecido em água com
    sabão neutro ou solução de limpeza apropriada para micros. Não use Álcool,
    querosene, acetona ou qualquer outro tipo de produto abrasivo. O uso de um
    destes podem estragar o gabinete de seu computador e se um destes produtos
    atingir a parte interna pode causar problemas nas placas ou até um
    incêndio!

  • Não retire o Pino central da tomada do computador, ele não veio sobrando e
    tem utilidade! Este pino é ligado a carcaça do computador (chassis) e deve
    ser ligado ao terra de sua rede elétrica. As descargas elétricas vindas da
    fonte e componentes do micro são feitas no chassis e se este pino for
    retirado você poderá tomar choques ao tocar em alguma parte metálica do
    micro e queimar componentes sensíveis como o disco rígido, placa mãe, etc.

    Se estiver em dúvida consulte um eletricista de confiança.

  • Não instale seu computador muito próximo de campos magnéticos com
    televisores, aparelhos de som, motores, etc. Estes aparelhos geram ruídos
    elétricos e/ou magnéticos que podem prejudicar o bom funcionamento de seu
    micro. OBS: As caixas de som de kits multimídia possuem os ímãs revestidos
    de metais em seus auto-falantes para não causar nenhuma interferência ao
    computador.

  • Não use a bandeja da unidade de CD/DVD como porta copos!

  • Não coloque objetos dentro da unidade de disquetes.

  • Antes de desligar seu computador, utilize o comando "shutdown -h now" (ou
    seus sinonimos, como "halt", poweroff) para desligar corretamente o
    computador. Este comando finaliza adequadamente os programas, salva os
    dados, desmontar os sistemas de arquivos GNU/Linux. Para detalhes veja
    “Desligando o computador”.

Dispositivos de Entrada e Saída

  • Entrada - Permite a comunicação do usuário com o computador. São
    dispositivos que enviam dados ao computador para processamento. Exemplos:
    Teclado, mouse, touch screen, caneta ótica, scanner.

    O dispositivo de entrada padrão (stdin) em sistemas GNU/Linux é o teclado.

  • Saída - Permite a comunicação do computador com o usuário. São dispositivos
    que permitem o usuário visualizar o resultado do processamento enviado ao
    computador. Exemplos: Monitor, Impressora, Plotter, som.

    O dispositivo de saída padrão (stdout) em sistemas GNU/Linux é o Monitor.

Ligando o computador

Para ligar o computador pressione o botão POWER ou I/O localizado em seu painel
frontal do micro.

Imediatamente entrará em funcionamento um programa residente na memória ROM
(Read Only Memory - memória somente para leitura) da placa mãe que fará os
testes iniciais para verificar se os principais dispositivos estão funcionando
em seu computador (memória RAM, discos, processador, portas de impressora,
memória cache, etc).

Quando o ROM termina os testes básicos, ele inicia a procura do setor de boot
nos discos do computador que será carregado na memória RAM do computador. Após
carregar o setor de boot, o sistema operacional será iniciado (veja “Sistema
Operacional”). O setor de boot contém a porção principal usada para iniciar o
sistema operacional.

No GNU/Linux, o setor de boot normalmente é criado por um gerenciador de
inicialização (um programa que permite escolher qual sistema operacional será
iniciado). Deste modo podemos usar mais de um sistema operacional no mesmo
computador (como o DOS e Linux). Os gerenciadores de inicialização mais usados
em sistemas GNU/Linux na plataforma Intel X86 são o GRUB e o LILO.

Caso o ROM não encontre o sistema operacional em nenhum dos discos, ele pedirá
que seja inserido um disquete contendo o Sistema Operacional para partida.

Desligando o computador

Para desligar o computador primeiro digite (como root): "shutdown -h now",
"halt" ou "poweroff", o GNU/Linux finalizará os programas e gravará os dados em
seu disco rígido, quando for mostrada a mensagem "power down", pressione o
botão POWER em seu gabinete para desligar a alimentação de energia do
computador.

NUNCA desligue diretamente o computador sem usar o comando shutdown, halt ou 
poweroff, pois podem ocorrer perda de dados ou falhas no sistema de arquivos de
seu disco rígido devido a programas abertos e dados ainda não gravados no
disco.

Salve seus trabalhos para não correr o risco de perde-los durante o
desligamento do computador.

Reiniciando o computador

Reiniciar quer dizer iniciar novamente o sistema. Não é recomendável desligar e
ligar constantemente o computador pelo botão ON/OFF, por este motivo existe
recursos para reiniciar o sistema sem desligar o computador. No GNU/Linux você
pode usar o comando reboot, shutdown -r now e também pressionar simultaneamente
as teclas <CTRL> <ALT> <DEL> para reiniciar de uma forma segura.

Observações:

  • Salve seus trabalhos para não correr o risco de perde-los durante a
    reinicialização do sistema.

  • O botão reset do painel frontal do computador também reinicia o computador,
    mas de uma maneira mais forte pois está ligado diretamente aos circuitos da
    placa mãe e o sistema será reiniciado imediatamente, não tendo nenhuma
    chance de finalizar corretamente os programas, gravar os dados da memória
    no disco e desmontar os sistemas de arquivos. O uso indevido da tecla reset
    pode causar corrompimentos em seus arquivos e perdas.

    Prefira o método de reinicialização explicado acima e use o botão reset
    somente em último caso.

Capítulo 2. Explicações Básicas

Índice

Hardware e Software
Arquivos

    Extensão de arquivos
    Tamanho de arquivos
    Arquivo texto e binário

Diretório

    Diretório Raíz
    Diretório atual
    Diretório home
    Diretório Superior
    Diretório Anterior
    Caminho na estrutura de diretórios
    Exemplo de diretório
    Estrutura básica de diretórios do Sistema Linux

Nomeando Arquivos e Diretórios
Comandos

    Comandos Internos

Comandos Externos
Aviso de comando (Prompt)
Interpretador de comandos
Terminal Virtual (console)
Login
Logout
coringas

    Exemplo de coringas

Este capítulo traz explicações sobre os principais componentes existentes no
computador e do sistema operacional Linux.

Hardware e Software

Hardware - Significa parte física do computador (disquete, pen-drive,
impressoras, monitores, placa mãe, placa de fax, discos rígidos, etc).

Software - São os programas usados no computador (sistema operacional,
processador de textos, planilha, banco de dados, scripts, comandos, etc).

Arquivos

É onde gravamos nossos dados. Um arquivo pode conter um texto feito por nós,
uma música, programa, planilha, etc.

Cada arquivo deve ser identificado por um nome, assim ele pode ser encontrado
facilmente quando desejar usa-lo. Se estiver fazendo um trabalho de história,
nada melhor que salva-lo com o nome historia. Um arquivo pode ser binário ou
texto (para detalhes veja “Arquivo texto e binário”).

O GNU/Linux é Case Sensitive ou seja, ele diferencia letras maiúsculas e 
minúsculas nos arquivos. O arquivo historia é completamente diferente de
Historia. Esta regra também é válido para os comandos e diretórios. Prefira,
sempre que possível, usar letras minúsculas para identificar seus arquivos,
pois quase todos os comandos do sistema estão em minúsculas.

Um arquivo oculto no GNU/Linux é identificado por um "." no inicio do nome (por
exemplo, .bashrc). Arquivos ocultos não aparecem em listagens normais de
diretórios, deve ser usado o comando ls -a para também listar arquivos ocultos.

Extensão de arquivos

A extensão serve para identificar o tipo do arquivo. A extensão são as letras
após um "." no nome de um arquivo, explicando melhor:

  • relatório.txt - O .txt indica que o conteúdo é um arquivo texto.

  • script.sh - Arquivo de Script (interpretado por /bin/sh).

  • system.log - Registro de algum programa no sistema.

  • arquivo.gz - Arquivo compactado pelo utilitário gzip.

  • index.html - Página de Internet (formato Hypertexto).

A extensão de um arquivo também ajuda a saber o que precisamos fazer para
abri-lo. Por exemplo, o arquivo relatório.txt é um texto simples e podemos ver
seu conteúdo através do comando “cat”, já o arquivo index.html contém uma
página de Internet e precisaremos de um navegador para poder visualiza-lo (como
o lynx, Firefox ou o Konqueror).

A extensão (na maioria dos casos) não é requerida pelo sistema operacional GNU/
Linux, mas é conveniente o seu uso para determinarmos facilmente o tipo de
arquivo e que programa precisaremos usar para abri-lo.

Tamanho de arquivos

A unidade de medida padrão nos computadores é o bit. A um conjunto de 8 bits
nós chamamos de byte. Cada arquivo/diretório possui um tamanho, que indica o
espaço que ele ocupa no disco e isto é medido em bytes. O byte representa uma
letra. Assim, se você criar um arquivo vazio e escrever o nome Linux e salvar o
arquivo, este terá o tamanho de 5 bytes. Espaços em branco e novas linhas
também ocupam bytes.

Além do byte existem as medidas Kbytes, Mbytes, Gbytes. Os prefixos K (quilo),
M (mega), G (giga), T (tera) etc. vêem da matemática. O "K" significa
multiplicar por 10^3, o "M" por 10^6, e assim por diante. Esta letras servem
para facilitar a leitura em arquivos de grande tamanho. Um arquivo de 1K é a
mesma coisa de um arquivo de 1024 bytes. Uma forma que pode inicialmente lhe
ajudar a lembrar: K vem de Kilo que é igual a 1000 - 1Kilo é igual a 1000
gramas certo?.

Da mesma forma 1Mb (ou 1M) é igual a um arquivo de 1024K ou 1.048.576 bytes

1Gb (ou 1G) é igual a um arquivo de 1024Mb ou 1048576Kb ou 1.073.741.824 bytes
(1 Gb é igual a 1.073.741.824 bytes, são muitos números!). Deu pra notar que é
mais fácil escrever e entender como 1Gb do que 1.073.741.824 bytes :-)

A lista completa em ordem progressiva das unidades de medida é a seguinte:

Símbolo 10^     2^      Nome

K        3      10      Quilo
M        6      20      Mega
G        9      30      Giga
T       12      40      Tera
P       15      50      Peta
E       18      60      Eta
Z       21      70      Zetta
Y       24      80      Yotta

Arquivo texto e binário

Quanto ao tipo, um arquivo pode ser de texto ou binário:

texto

    Seu conteúdo é compreendido pelas pessoas. Um arquivo texto pode ser uma
    carta, um script, um programa de computador escrito pelo programador,
    arquivo de configuração, etc.

binário

    Seu conteúdo somente pode ser entendido por computadores. Contém caracteres
    incompreensíveis para pessoas normais. Um arquivo binário é gerado através
    de um arquivo de programa (digitado pela pessoa que o criou, o programador)
    através de um processo chamado de compilação. Compilação é basicamente a
    conversão de um programa em linguagem humana para a linguagem de máquina.

Diretório

Diretório é o local utilizado para armazenar conjuntos arquivos para melhor
organização e localização. O diretório, como o arquivo, também é "Case
Sensitive" (diretório /teste é completamente diferente do diretório /Teste).

Não podem existir dois arquivos com o mesmo nome em um diretório, ou um
sub-diretório com um mesmo nome de um arquivo em um mesmo diretório.

Um diretório nos sistemas Linux/UNIX são especificados por uma "/" e não uma "\
" como é feito no DOS. Para detalhes sobre como criar um diretório, veja o
comando mkdir (“mkdir”).

Diretório Raíz

Este é o diretório principal do sistema. Dentro dele estão todos os diretórios
do sistema. O diretório Raíz é representado por uma "/", assim se você digitar
o comando cd / você estará acessando este diretório.

Nele estão localizados outros diretórios como o /bin, /sbin, /usr, /usr/local,
/mnt, /tmp, /var, /home, etc. Estes são chamados de sub-diretórios pois estão
dentro do diretório "/". A estrutura de diretórios e sub-diretórios pode ser
identificada da seguinte maneira:

  • /

  • /bin

  • /sbin

  • /usr

  • /usr/local

  • /mnt

  • /tmp

  • /var

  • /home

A estrutura de diretórios também é chamada de Árvore de Diretórios porque é
parecida com uma árvore de cabeça para baixo. Cada diretório do sistema tem
seus respectivos arquivos que são armazenados conforme regras definidas pela 
FHS (FileSystem Hierarchy Standard - Hierarquia Padrão do Sistema de Arquivos)
versão 2.0, definindo que tipo de arquivo deve ser armazenado em cada
diretório.

Diretório atual

É o diretório em que nos encontramos no momento. Você pode digitar pwd (veja
“pwd”) para verificar qual é seu diretório atual.

O diretório atual também é identificado por um "." (ponto). O comando comando
ls . pode ser usado para listar seus arquivos (é claro que isto é desnecessário
porque se não digitar nenhum diretório, o comando ls listará o conteúdo do
diretório atual).

Diretório home

Também chamado de diretório de usuário. Em sistemas GNU/Linux cada usuário
(inclusive o root) possui seu próprio diretório onde poderá armazenar seus
programas e arquivos pessoais.

Este diretório está localizado em /home/[login], neste caso se o seu login for
"joao" o seu diretório home será /home/joao. O diretório home também é
identificado por um ~(til), você pode digitar tanto o comando ls /home/joao
como ls ~ para listar os arquivos de seu diretório home.

O diretório home do usuário root (na maioria das distribuições GNU/Linux) está
localizado em /root.

Dependendo de sua configuração e do número de usuários em seu sistema, o
diretório de usuário pode ter a seguinte forma: /home/[1letra_do_nome]/[login],
neste caso se o seu login for "joao" o seu diretório home será /home/j/joao.

Diretório Superior

O diretório superior (Upper Directory) é identificado por .. (2 pontos).

Caso estiver no diretório /usr/local e quiser listar os arquivos do diretório /
usr você pode digitar, ls .. Este recurso também pode ser usado para copiar,
mover arquivos/diretórios, etc.

Diretório Anterior

O diretório anterior é identificado por "-". É útil para retornar ao último
diretório usado.

Se estive no diretório /usr/local e digitar cd /lib, você pode retornar
facilmente para o diretório /usr/local usando cd -.

Caminho na estrutura de diretórios

São os diretórios que teremos que percorrer até chegar no arquivo ou diretório
que que procuramos. Se desejar ver o arquivo /etc/hosts você tem duas opções:

 1. Mudar o diretório padrão para /etc com o comando cd /etc e usar o comando
    cat hosts

 2. Usar o comando "cat" especificando o caminho completo na estrutura de
    diretórios e o nome de arquivo: cat /etc/hosts.

As duas soluções acima permitem que você veja o arquivo GPL. A diferença entre
as duas é a seguinte:

  • Na primeira, você muda o diretório padrão para /usr/doc/copyright (confira
    digitando pwd) e depois o comando cat GPL. Você pode ver os arquivos de /
    usr/doc/copyright com o comando "ls".

    /usr/doc/copyright é o caminho de diretório que devemos percorrer para
    chegar até o arquivo GPL.

  • Na segunda, é digitado o caminho completo para o "cat" localizar o arquivo
    GPL: cat /usr/doc/copyright/GPL. Neste caso, você continuará no diretório
    padrão (confira digitando pwd). Digitando ls, os arquivos do diretório
    atual serão listados.

O caminho de diretórios é necessário para dizer ao sistema operacional onde
encontrar um arquivo na "árvore" de diretórios.

Exemplo de diretório

Um exemplo de diretório é o seu diretório de usuário, todos seus arquivos
essenciais devem ser colocadas neste diretório. Um diretório pode conter outro
diretório, isto é útil quando temos muitos arquivos e queremos melhorar sua
organização. Abaixo um exemplo de uma empresa que precisa controlar os arquivos
de Pedidos que emite para as fábricas:

/pub/vendas - diretório principal de vendas /pub/vendas/mes01-1999 - diretório
contendo vendas do mês 01/1999 /pub/vendas/mes02-2009 - diretório contendo
vendas do mês 02/2009 /pub/vendas/mes01-2010 - diretório contendo vendas do mês
03/2010

mes01-99, mes02-2009, mes01-2010 são diretórios usados para armazenar os
arquivos de pedidos do mês e ano correspondente. Isto é essencial para
organização, pois se todos os pedidos fossem colocados diretamente no diretório
vendas, seria muito difícil encontrar o arquivo do cliente "João" do mês 01/
2009.

Você deve ter reparado que usei a palavra sub-diretório para mes01-1999,
mes02-2009 e mes01-2010, porque que eles estão dentro do diretório vendas. Da
mesma forma, vendas é um sub-diretório de pub.

Estrutura básica de diretórios do Sistema Linux

O sistema GNU/Linux possui a seguinte estrutura básica de diretórios
organizados segundo o FHS (Filesystem Hierarchy Standard):

/bin

    Contém arquivos programas do sistema que são usados com freqüência pelos
    usuários.

/boot

    Contém arquivos necessários para a inicialização do sistema.

/cdrom

    Ponto de montagem da unidade de CD-ROM.

/media

    Ponto de montagem de dispositivos diversos do sistema (rede, pen-drives,
    CD-ROM em distribuições mais novas).

/dev

    Contém arquivos usados para acessar dispositivos (periféricos) existentes
    no computador.

/etc

    Arquivos de configuração de seu computador local.

/floppy

    Ponto de montagem de unidade de disquetes

/home

    Diretórios contendo os arquivos dos usuários.

/lib

    Bibliotecas compartilhadas pelos programas do sistema e módulos do kernel.

/lost+found

    Local para a gravação de arquivos/diretórios recuperados pelo utilitário 
    fsck.ext2. Cada partição possui seu próprio diretório lost+found.

/mnt

    Ponto de montagem temporário.

/proc

    Sistema de arquivos do kernel. Este diretório não existe em seu disco
    rígido, ele é colocado lá pelo kernel e usado por diversos programas que
    fazem sua leitura, verificam configurações do sistema ou modificar o
    funcionamento de dispositivos do sistema através da alteração em seus
    arquivos.

/sys

    Sistema de arquivos do kernel. Este diretório não existe em seu disco
    rígido, ele é colocado lá pelo kernel e usado por diversos programas que
    fazem sua leitura, verificam configurações do sistema ou modificar o
    funcionamento de dispositivos do sistema através da alteração em seus
    arquivos.

/root

    Diretório do usuário root.

/sbin

    Diretório de programas usados pelo superusuário (root) para administração e
    controle do funcionamento do sistema.

/tmp

    Diretório para armazenamento de arquivos temporários criados por programas.

/usr

    Contém maior parte de seus programas. Normalmente acessível somente como
    leitura.

/var

    Contém maior parte dos arquivos que são gravados com freqüência pelos
    programas do sistema, e-mails, spool de impressora, cache, etc.

Nomeando Arquivos e Diretórios

No GNU/Linux, os arquivos e diretórios podem ter o tamanho de até 255 letras.
Você pode identifica-lo com uma extensão (um conjunto de letras separadas do
nome do arquivo por um ".").

Os programas executáveis do GNU/Linux, ao contrário dos programas de DOS e 
Windows, não são executados a partir de extensões .exe, .com ou .bat. O GNU/
Linux (como todos os sistemas POSIX) usa a permissão de execução de arquivo
para identificar se um arquivo pode ou não ser executado.

No exemplo anterior, nosso trabalho de história pode ser identificado mais
facilmente caso fosse gravado com o nome trabalho.text ou trabalho.txt. Também
é permitido gravar o arquivo com o nome Trabalho de Historia.txt mas não é
recomendado gravar nomes de arquivos e diretórios com espaços. Porque será
necessário colocar o nome do arquivo entre "aspas" para acessa-lo (por exemplo,
cat "Trabalho de Historia.txt"). Ao invés de usar espaços, prefira capitalizar
o arquivo (usar letras maiúsculas e minúsculas para identifica-lo):
TrabalhodeHistoria.txt.

Comandos

Comandos são ordens que passamos ao sistema operacional para executar uma
determinada tarefa.

Cada comando tem uma função específica, devemos saber a função de cada comando
e escolher o mais adequado para fazer o que desejamos, por exemplo:

  • ls - Mostra arquivos de diretórios

  • cd - Para mudar de diretório

Este guia tem uma lista de vários comandos organizados por categoria com a
explicação sobre o seu funcionamento e as opções aceitas (incluindo alguns
exemplos).

É sempre usado um espaço depois do comando para separá-lo de uma opção ou
parâmetro que será passado para o processamento. Um comando pode receber opções
e parâmetros:

opções

    As opções são usadas para controlar como o comando será executado, por
    exemplo, para fazer uma listagem mostrando o dono, grupo, tamanho dos
    arquivos você deve digitar ls -l.

    Opções podem ser passadas ao comando através de um "-" ou "--":

    -

        Opção identificada por uma letra. Podem ser usadas mais de uma opção
        com um único hífen. O comando ls -l -a é a mesma coisa de ls -la

    --

        Opção identificada por um nome. Também chamado de opção extensa. O
        comando ls --all é equivalente a ls -a.

    Pode ser usado tanto "-" como "--", mas há casos em que somente "-" ou "--"
    esta disponível.

parâmetros

    Um parâmetro identifica o caminho, origem, destino, entrada padrão ou saída
    padrão que será passada ao comando.

    Se você digitar: ls /usr/share/doc/copyright, /usr/share/doc/copyright será
    o parâmetro passado ao comando ls, neste caso queremos que ele liste os
    arquivos do diretório /usr/share/doc/copyright.

    É normal errar o nome de comandos, mas não se preocupe, quando isto
    acontecer o sistema mostrará a mensagem command not found (comando não
    encontrado) e voltará ao aviso de comando. As mensagens de erro não fazem
    nenhum mal ao seu sistema, somente dizem que algo deu errado para que você
    possa corrigir e entender o que aconteceu. No GNU/Linux, você tem a
    possibilidade de criar comandos personalizados usando outros comandos mais
    simples (isto será visto mais adiante). Os comandos se encaixam em duas
    categorias: Comandos Internos e Comandos Externos.

Por exemplo: "ls -la /usr/share/doc", ls é o comando, -la é a opção passada ao
comando, e /usr/share/doc é o diretório passado como parâmetro ao comando ls.

Comandos Internos

São comandos que estão localizados dentro do interpretador de comandos
(normalmente o Bash) e não no disco. Eles são carregados na memória RAM do
computador junto com o interpretador de comandos.

Quando executa um comando, o interpretador de comandos verifica primeiro se ele
é um Comando Interno caso não seja é verificado se é um Comando Externo.

Exemplos de comandos internos são: cd, exit, echo, bg, fg, source, help

Comandos Externos

São comandos que estão localizados no disco. Os comandos são procurados no
disco usando o ordem do PATH e executados assim que encontrados.

Para detalhes veja “path”.

Aviso de comando (Prompt)

Aviso de comando (ou Prompt), é a linha mostrada na tela para digitação de
comandos que serão passados ao interpretador de comandos para sua execução.

A posição onde o comando será digitado é marcado um "traço" piscante na tela
chamado de cursor. Tanto em shells texto como em gráficos é necessário o uso do
cursor para sabermos onde iniciar a digitação de textos e nos orientarmos
quanto a posição na tela.

O aviso de comando do usuário root é identificado por uma "#" (tralha), e o
aviso de comando de usuários é identificado pelo símbolo "$". Isto é padrão em
sistemas UNIX.

Você pode retornar comandos já digitados pressionando as teclas Seta para cima
/ Seta para baixo.

A tela pode ser rolada para baixo ou para cima segurando a tecla SHIFT e
pressionando PGUP ou PGDOWN. Isto é útil para ver textos que rolaram
rapidamente para cima.

Abaixo algumas dicas sobre a edição da linha de comandos (não é necessário se
preocupar em decora-los):

  • Pressione a tecla Back Space ("<--") para apagar um caracter à esquerda do
    cursor.

  • Pressione a tecla Del para apagar o caracter acima do cursor.

  • Pressione CTRL+A para mover o cursor para o inicio da linha de comandos.

  • Pressione CTRL+E para mover o cursor para o fim da linha de comandos.

  • Pressione CTRL+U para apagar o que estiver à esquerda do cursor. O conteúdo
    apagado é copiado para uso com CTRL+y.

  • Pressione CTRL+K para apagar o que estiver à direita do cursor. O conteúdo
    apagado é copiado para uso com CTRL+y.

  • Pressione CTRL+L para limpar a tela e manter o texto que estiver sendo
    digitado na linha de comando (parecido com o comando clear).

  • Pressione CTRL+Y para colocar o texto que foi apagado na posição atual do
    cursor.

Interpretador de comandos

Também conhecido como "shell". É o programa responsável em interpretar as
instruções enviadas pelo usuário e seus programas ao sistema operacional (o
kernel). Ele que executa comandos lidos do dispositivo de entrada padrão
(teclado) ou de um arquivo executável. É a principal ligação entre o usuário,
os programas e o kernel. O GNU/Linux possui diversos tipos de interpretadores
de comandos, entre eles posso destacar o bash, ash, csh, tcsh, sh, etc. Entre
eles o mais usado é o bash. O interpretador de comandos do DOS, por exemplo, é
o command.com.

Os comandos podem ser enviados de duas maneiras para o interpretador:
interativa e não-interativa:

Interativa

    Os comandos são digitados no aviso de comando e passados ao interpretador
    de comandos um a um. Neste modo, o computador depende do usuário para
    executar uma tarefa, ou próximo comando.

Não-interativa

    São usados arquivos de comandos criados pelo usuário (scripts) para o
    computador executar os comandos na ordem encontrada no arquivo. Neste modo,
    o computador executa os comandos do arquivo um por um e dependendo do
    término do comando, o script pode checar qual será o próximo comando que
    será executado e dar continuidade ao processamento.

    Este sistema é útil quando temos que digitar por várias vezes seguidas um
    mesmo comando ou para compilar algum programa complexo.

O shell Bash possui ainda outra característica interessante: A completação dos
nomes. Isto é feito pressionando-se a tecla TAB. Por exemplo, se digitar "ls
tes" e pressionar <tab>, o Bash localizará todos os arquivos que iniciam com
"tes" e completará o restante do nome. Caso a completação de nomes encontre
mais do que uma expressão que satisfaça a pesquisa, ou nenhuma, é emitido um
beep. Se você apertar novamente a tecla TAB imediatamente depois do beep, o
interpretador de comandos irá listar as diversas possibilidades que satisfazem
a pesquisa, para que você possa escolher a que lhe interessa. A completação de
nomes funciona sem problemas para comandos internos.

Exemplo: ech (pressione TAB). ls /vm(pressione TAB)

Terminal Virtual (console)

Terminal (ou console) é o teclado e tela conectados em seu computador. O GNU/
Linux faz uso de sua característica multi-usuária usando os "terminais
virtuais". Um terminal virtual é uma segunda seção de trabalho completamente
independente de outras, que pode ser acessada no computador local ou
remotamente via telnet, rsh, rlogin, etc.

No GNU/Linux, em modo texto, você pode acessar outros terminais virtuais
segurando a tecla ALT e pressionando F1 a F6. Cada tecla de função corresponde
a um número de terminal do 1 ao 6 (o sétimo é usado por padrão pelo ambiente
gráfico X). O GNU/Linux possui mais de 63 terminais virtuais, mas apenas 6
estão disponíveis inicialmente por motivos de economia de memória RAM (cada
terminal virtual ocupa aproximadamente 350 Kb de memória RAM, desative a
quantidade que não estiver usando para liberar memória RAM para uso de outros
programas!).

Se estiver usando o modo gráfico, você deve segurar CTRL+ ALT enquanto
pressiona uma tela de <F1> a <F6>. Para voltar ao modo gráfico, pressione
CTRL+ALT+ <F7>.

Um exemplo prático: Se você estiver usando o sistema no Terminal 1 com o nome
"joao" e desejar entrar como "root" para instalar algum programa, segure ALT
enquanto pressiona <F2> para abrir o segundo terminal virtual e faça o login
como "root". Será aberta uma nova seção para o usuário "root" e você poderá
retornar a hora que quiser para o primeiro terminal pressionando ALT+<F1>.

Login

Login é a entrada no sistema quando você digita seu nome e senha. Por enquanto
vou manter o seu suspense sobre o que é o logout.

Logout

Logout é a saída do sistema. A saída do sistema é feita pelos comandos logout, 
exit, CTRL+D, ou quando o sistema é reiniciado ou desligado.

coringas

coringas (ou referência global) é um recurso usado para especificar um ou mais
arquivos ou diretórios do sistema de uma só vez. Este é um recurso permite que
você faça a filtragem do que será listado, copiado, apagado, etc. São usados 4
tipos de coringas no GNU/Linux:

  • "*" - Faz referência a um nome completo/restante de um arquivo/diretório.

  • "?" - Faz referência a uma letra naquela posição.

  • [padrão] - Faz referência a uma faixa de caracteres de um arquivo/
    diretório. Padrão pode ser:

      □ [a-z][0-9] - Faz referência a caracteres de a até z seguido de um
        caracter de 0 até 9.

      □ [a,z][1,0] - Faz a referência aos caracteres a e z seguido de um
        caracter 1 ou 0 naquela posição.

      □ [a-z,1,0] - Faz referência a intervalo de caracteres de a até z ou 1 ou
        0 naquela posição.

    A procura de caracteres é "Case Sensitive" assim se você deseja que sejam
    localizados todos os caracteres alfabéticos você deve usar [a-zA-Z].

    Caso a expressão seja precedida por um ^, faz referência a qualquer
    caracter exceto o da expressão. Por exemplo [^abc] faz referência a
    qualquer caracter exceto a, b e c.

  • {padrões} - Expande e gera strings para pesquisa de padrões de um arquivo/
    diretório.

      □ X{ab,01} - Faz referência a seqüencia de caracteres Xab ou X01

      □ X{a-z,10} Faz referencia a seqüencia de caracteres Xa-z e X10.

O que diferencia este método de expansão dos demais é que a existência do
arquivo/diretório é opcional para geração do resultado. Isto é útil para a
criação de diretórios. Lembrando que os 4 tipos de coringas ("*", "?", "[]", "
{}") podem ser usados juntos.

Exemplo de coringas

Para entender melhor vamos a prática:

Vamos dizer que tenha 5 arquivo no diretório /usr/teste: teste1.txt,
teste2.txt, teste3.txt, teste4.new, teste5.new.

Caso deseje listar todos os arquivos do diretório /usr/teste você pode usar o
coringa "*" para especificar todos os arquivos do diretório:

cd /usr/teste e ls * ou ls /usr/teste/*.

Não tem muito sentido usar o comando ls com "*" porque todos os arquivos serão
listados se o ls for usado sem nenhum Coringa.

Agora para listar todos os arquivos teste1.txt, teste2.txt, teste3.txt com
excessão de teste4.new, teste5.new, podemos usar inicialmente 3 métodos:

 1. Usando o comando ls *.txt que pega todos os arquivos que começam com
    qualquer nome e terminam com .txt.

 2. Usando o comando ls teste?.txt, que pega todos os arquivos que começam com
    o nome teste, tenham qualquer caracter no lugar do coringa ? e terminem com
    .txt. Com o exemplo acima teste*.txt também faria a mesma coisa, mas se
    também tivéssemos um arquivo chamado teste10.txt este também seria listado.

 3. Usando o comando ls teste[1-3].txt, que pega todos os arquivos que começam
    com o nome teste, tenham qualquer caracter entre o número 1-3 no lugar da
    6a letra e terminem com .txt. Neste caso se obtém uma filtragem mais exata,
    pois o coringa ? especifica qualquer caracter naquela posição e []
    especifica números, letras ou intervalo que será usado.

Agora para listar somente teste4.new e teste5.new podemos usar os seguintes
métodos:

 1. ls *.new que lista todos os arquivos que terminam com .new

 2. ls teste?.new que lista todos os arquivos que começam com teste, contenham
    qualquer caracter na posição do coringa ? e terminem com .new.

 3. ls teste[4,5].* que lista todos os arquivos que começam com teste contenham
    números de 4 e 5 naquela posição e terminem com qualquer extensão.

Existem muitas outras formas de se fazer a mesma coisa, isto depende do gosto
de cada um. O que pretendi fazer aqui foi mostrar como especificar mais de um
arquivo de uma só vez. O uso de coringas será útil ao copiar arquivos, apagar,
mover, renomear, e nas mais diversas partes do sistema. Alias esta é uma
característica do GNU/Linux: permitir que a mesma coisa possa ser feita com
liberdade de várias maneiras diferentes.

Capítulo 3. Para quem esta migrando (ou pensando em migrar) do DOS/Windows para
o Linux

Índice

Quais as diferenças iniciais
Comandos equivalentes entre DOS/CMD do Windows e o Linux

    Arquivos de configuração

Usando a sintaxe de comandos DOS no Linux
Programas equivalentes entre Windows/DOS e o Linux

Este capítulo explica as diferenças e particularidades do sistema GNU/Linux
comparado ao Windows, DOS e uma lista de equivalência entre comandos e
programas executados no CMD do Windows/DOS e GNU/Linux, que pode servir de
comparação para que o usuário possa conhecer e utilizar os comandos/programas 
GNU/Linux que tem a mesma função no ambiente DOS/Windows.

Quais as diferenças iniciais

  • Quando entrar pela primeira vez no GNU/Linux (ou qualquer outro UNIX, a
    primeira coisa que verá será a palavra login: escrita na tela.

    A sua aventura começa aqui, você deve ser uma pessoa cadastrada no sistema
    (ter uma conta) para que poder entrar. No login você digita seu nome (por
    exemplo, gleydson) e pressiona Enter. Agora será lhe pedida a senha, repare
    que a senha não é mostrada enquanto é digitada, isto serve de segurança e
    para enganar pessoas que estão próximas de você "tocando" algumas teclas a
    mais enquanto digita a senha e fazendo-as pensar que você usa uma grande
    senha ;-) (com os asteriscos aparecendo isto não seria possível).

    Caso cometa erros durante a digitação da senha, basta pressionar a tecla
    Back Space para apagar o último caracter digitado e terminar a entrada da
    senha.

    Pressione Enter, se tudo ocorrer bem você estará dentro do sistema e será
    presenteado com o símbolo # (caso tenha entrado como usuário root) ou $
    (caso tenha entrado como um usuário normal).

    Existe um mecanismo de segurança que te alerta sobre eventuais tentativas
    de entrada no sistema por intrusos usando seu login, faça um teste: entre
    com seu login e digite a senha errada, na segunda vez entre com a senha
    correta no sistema. Na penúltima linha das mensagens aparece uma mensagem
    "1 failure since last login", o que quer dizer "1 falha desde o último
    login". Isto significa que alguém tentou entrar 1 vez com seu nome e senha
    no sistema, sem sucesso.

  • A conta root não tem restrições de acesso ao sistema e pode fazer tudo o
    que quiser, é equivalente ao usuário normal do DOS e Windows. Use a conta
    root somente para manutenções no sistema e instalação de programas,
    qualquer movimento errado pode comprometer todo o sistema. Para detalhes
    veja “A conta root”.

  • No GNU/Linux os diretório são identificados por uma / e não por uma \ como
    acontece no DOS. Para entrar no diretório /bin, você deve usar cd /bin.

  • Os comandos são case-sensitive, o que significa que ele diferencia as
    letras maiúsculas de minúsculas em arquivos e diretórios. O comando ls e LS
    são completamente diferentes.

  • A multitarefa lhe permite usar vários programas simultaneamente (não pense
    que multitarefa somente funciona em ambientes gráficos, pois isto é
    errado!). Para detalhes veja Capítulo 5, Execução de programas.

  • Os dispositivos também são identificados e uma forma diferente que no DOS
    por exemplo:

     DOS/Windows        Linux
    -------------  ---------------
    A:             /dev/fd0
    B:             /dev/fd1
    C:             /dev/hda1 ou /dev/sda1
    LPT1           /dev/lp0
    LPT2           /dev/lp1
    LPT3           /dev/lp2
    COM1           /dev/ttyS0
    COM2           /dev/ttyS1
    COM3           /dev/ttyS2
    COM4           /dev/ttyS3

  • Os recursos multiusuário lhe permitem acessar o sistema de qualquer lugar
    sem instalar nenhum driver, ou programa gigante, apenas através de conexões
    TCP/IP, como a Internet. Também é possível acessar o sistema localmente com
    vários usuários (cada um executando tarefas completamente independente dos
    outros) através dos Terminais Virtuais. Faça um teste: pressione ao mesmo
    tempo a tecla ALT e F2 e você será levado para o segundo Terminal Virtual,
    pressione novamente ALT e F1 para retornar ao anterior.

  • Para reiniciar o computador, você pode pressionar CTRL+ALT+DEL (como
    usuário root) ou digitar shutdown -r now. Veja “Reiniciando o computador”
    para detalhes.

  • Para desligar o computador, digite shutdown -h now e espere o aparecimento
    da mensagem Power Down para apertar o botão LIGA/DESLIGA do computador.
    Veja “Desligando o computador” para detalhes.

Comandos equivalentes entre DOS/CMD do Windows e o Linux

Esta seção contém os comandos equivalentes entre estes dois sistemas e a
avaliação entre ambos. Grande parte dos comandos podem ser usados da mesma
forma que no DOS, mas os comandos Linux possuem avanços para utilização neste
ambiente multiusuário/multitarefa.

O objetivo desta seção é permitir as pessoas com experiência em DOS fazer
rapidamente no GNU/Linux as tarefas que fazem no DOS. A primeira coluna tem o
nome do comando no DOS, a segunda o comando que possui a mesma função no GNU/
Linux e na terceira coluna as diferenças.

  DOS       Linux                        Diferenças
--------  ------------ --------------------------------------------------
cls       clear        Sem diferenças.
dir       ls -la       A listagem no Linux possui mais campos (as
                       permissões de acesso) e o total de espaço ocupado
                       no diretório e livre no disco deve ser visto
                       separadamente usando o comando du e df.
                       Permite também listar o conteúdo de diversos
                       diretórios com um só comando (ls /bin /sbin /...).
dir/s     ls -lR       Sem diferenças.
dir/od    ls -tr       Sem diferenças.
cd        cd           Poucas diferenças. cd sem parâmetros retorna ao
                       diretório de usuário e também permite o uso
                       de "cd -" para retornar ao diretório anteriormente
                       acessado.
del       rm           Poucas diferenças. O rm do Linux permite
                       especificar diversos arquivos que serão apagados
                       (rm arquivo1 arquivo2 arquivo3). Para ser mostrados
                       os arquivos apagados, deve-se especificar o
                       parâmetro "-v" ao comando, e "-i" para pedir
                       a confirmação ao apagar arquivos.
md        mkdir        Uma só diferença: No Linux permite que vários
                       diretórios sejam criados de uma só vez
                       (mkdir /tmp/a /tmp/b...).
copy      cp           Poucas diferenças. Para ser mostrados os arquivos
                       enquanto estão sendo copiados, deve-se usar a
                       opção "-v", e para que ele pergunte se deseja
                       substituir um arquivo já existente, deve-se usar
                       a opção "-i".
echo      echo         Sem diferenças.
path      path         No Linux deve ser usado ":" para separar os
                       diretórios e usar o comando
                       "export PATH=caminho1:/caminho2:/caminho3:"
                       para definir a variável de ambiente PATH.
                       O path atual pode ser visualizado através
                       do comando "echo $PATH".
ren       mv           Poucas diferenças. No Linux não é possível
                       renomear vários arquivos de uma só vez
                       (como "ren *.txt *.bak"). É necessário usar
                       um shell script para fazer isto.
type      cat          Sem diferenças.
ver       uname -a     Poucas diferenças (o uname tem algumas opções
                       a mais).
date      date         No Linux mostra/modifica a Data e Hora do sistema.
time      date         No Linux mostra/modifica a Data e Hora do sistema.
attrib    chmod        O chmod possui mais opções por tratar as permissões
                       de acesso de leitura, gravação e execução para
                       donos, grupos e outros usuários.
chkdsk    fsck         O fack é mais rápido e a checagem mais abrangente.
scandisk  fsck         O fsck é mais rápido e a checagem mais abrangente.
doskey    -----        A memorização de comandos é feita automaticamente pelo
                       bash.
edit      vi, ae,      O edit é mais fácil de usar, mas usuário
        emacs, mcedit experientes apreciarão os recursos do vi ou
                       o emacs (programado em lisp).
fdisk    fdisk, cfdisk Os particionadores do Linux trabalham com
                       praticamente todos os tipos de partições de
                       diversos sistemas de arquivos diferentes.
format    mkfs.ext3    Poucas diferenças, precisa apenas que seja
                       especificado o dispositivo a ser formatado
                       como "/dev/fd0" ou "/dev/hda10" (o
                       tipo de identificação usada no Linux), ao
                       invés de "A:" ou "C:".
help      man, info    Sem diferenças.
interlnk  plip         O plip do Linux permite que sejam montadas
                       redes reais a partir de uma conexão via Cabo
                       Paralelo ou Serial. A máquina pode fazer tudo
                       o que poderia fazer conectada em uma rede
                       (na realidade é uma rede e usa o TCP/IP como
                       protocolo) inclusive navegar na Internet, enviar
                       e-mails, irc, etc.
intersvr  plip         Mesmo que o acima.
keyb      loadkeys     Sem diferenças (somente que a posição das
                       teclas do teclado pode ser editada.
                       Desnecessário para a maioria dos usuários).
label     e2label      É necessário especificar a partição que terá
                       o nome modificado.
mem       cat /proc/meminfo Mostra detalhes sobre a quantidade de dados
          top          em buffers, cache e memória virtual (disco).
more      more, less   O more é equivalente a ambos os sistemas, mas
                       o less permite que sejam usadas as setas para
                       cima e para baixo, o que torna a leitura do
                       texto muito mais agradável.
move      mv           Poucas diferenças. Para ser mostrados os arquivos
                       enquanto estão sendo movidos, deve-se usar a
                       opção "-v", e para que ele pergunte se deseja
                       substituir um arquivo já existente deve-se usar
                       a opção "-i".
scan      clamav       Os principais fabricantes disponibilizam anti-virus
                       para Linux, na maioria das vezes para integrar a
                       servidores de arquivos, e-mails, protegendo estações
                       Windows. Infecções por vírus são raras no Linux devido
                       as restrições do usuário durante execução de
                       programas (quando corretamente utilizadas).
backup    tar          O tar permite o uso de compactação (através do
                       parâmetro -z) e tem um melhor esquema de
                       recuperação de arquivos corrompidos que já
                       segue evoluindo há 30 anos em sistemas UNIX.
print     lpr          O lpr é mais rápido e permite até mesmo
                       impressões de gráficos ou arquivos compactados
                       diretamente caso seja usado o programa
                       magicfilter. É o programa de Spool de
                       impressoras usados no sistema Linux/Unix.
vol       e2label      Sem diferenças.
xcopy     cp -R        Pouca diferença, requer que seja usado a
                       opção "-v" para mostrar os arquivos que
                       estão sendo copiados e "-i" para pedir
                       confirmação de substituição de arquivos.

Arquivos de configuração

Os arquivos config.sys e autoexec.bat são equivalentes aos arquivos do
diretório /etc especialmente o /etc/inittab e arquivos dentro do diretório /etc
/init.d .

Usando a sintaxe de comandos DOS no Linux

Você pode usar os comandos do pacote para simular os comandos usados pelo DOS
no GNU/Linux, a diferença básica é que eles terão a letra m no inicio do nome.
Os seguintes comandos são suportados:

  • mattrib - Ajusta modifica atributos de arquivos

  • mcat - Mostra os dados da unidade de disquete em formato RAW

  • mcd - Entra em diretórios

  • mcopy - Copia arquivos/diretórios

  • mdel - Exclui arquivos

  • mdeltree - Exclui arquivos, diretórios e sub-diretórios

  • mdir - Lista arquivos e diretórios

  • mdu - Mostra o espaço ocupado pelo diretório do DOS

  • mformat - Formatador de discos

  • minfo - Mostra detalhes sobre a unidade de disquetes

  • mlabel - Cria um volume para unidades DOS

  • mmd - Cria diretórios

  • mmount - Monta discos DOS

  • mmove - Move ou renomeia arquivos/subdiretórios

  • mpartition - Particiona um disco para ser usado no DOS

  • mrd - Remove um diretório

  • mren - Renomeia arquivos

  • mtype - Visualiza o conteúdo de arquivos (equivalente ao cat)

  • mtoolstest - Exibe a configuração atual do mtools

  • mshowfat - Mostra a FAT da unidade

  • mbadblocks - Procura por setores defeituosos na unidade

  • mzip - Altera modo de proteção e ejeta discos em unidades Jaz/ZIP

  • mkmanifest - Cria um shell script para restaurar nomes extensos usados no
    UNIX

  • mcheck - Verifica arquivos na unidade

Programas equivalentes entre Windows/DOS e o Linux

Esta seção contém programas equivalentes para quem está vindo do DOS e Windows
e não sabe o que usar no GNU/Linux. Esta seção também tem por objetivo permitir
ao usuário que ainda não usa GNU/Linux decidir se a passagem vale a pena vendo
se o sistema tem os programas que precisa.

Note que esta listagem mostra os programas equivalentes entre o DOS/Windows e o
GNU/Linux cabendo a você a decisão final de migrar ou não. Lembrando que é
possível usar o Windows, OS/2, DOS, OS/2 e GNU/Linux no mesmo disco rígido sem
qualquer tipo de conflito. A listagem abaixo pode estar incompleta, se
encontrar algum programa que não esteja listado aqui, por favor entre em
contato pelo E-Mail <gleydson@guiafoca.org> para inclui-lo na listagem.

DOS/Windows           Linux                         Diferenças
-----------           ----------         -------------------------------
MS Word               Open Office,       O Open Office possui todos os
                                         recursos do Word além de ter
                                         a interface gráfica igual, menus
                                         e teclas de atalho idênticas ao
                                         Word, o que facilita a migração.
                                         Também trabalha com arquivos
                                         no formato Word97/2000 e não
                                         é vulnerável a vírus de macro.
                                         É distribuído gratuitamente e
                                         não requer pagamento de licença
                                         podendo ser instalado em quantos
                                         computadores você quiser (tanto
                                         domésticos como de empresas).
MS Excel              Open Office        Mesmos pontos do acima e também
                                         abre arquivos Excel97/2000.
MS PowerPoint         Open Office        Mesmos pontos do acima.
MS Access             MySQL, PostgreSQL  Existem diversas ferramentas de
                      Oracle             conceito para bancos de dados
                                         corporativos no Linux. Todos
                                         produtos compatíveis com outras
                                         plataformas.
MS Outlook            Pine, evolution    Centenas de programas de E-Mail
                      mutt, sylpheed,    tanto em modo texto como em
                      icedove            modo gráfico. Instale, avalie
                                         e escolha.
MS Internet Explorer  Firefox, Opera,    Os três primeiros para modo
                      Mozilla, lynx.     gráfico e o lynx opera em
                                         modo texto.
ICQ                   LICQ, PIDGIM, SIM  Muito prático e fácil de
                                         operar. Possibilita a mudança
                                         completa da aparência do programa
                                         através de Skins. A organização
                                         dos menus deste programa é outro
                                         ponto de destaque.
MSN                   AMSN, PIDGIM       Permite conversar diretamente com
                                         usuários do Microsoft MSN.
Photo Shop            The Gimp           Fácil de usar, possui
                                         muitos scripts que permitem
                                         a criação rápida e fácil de
                                         qualquer tipo de efeito
                                         profissional pelo usuário
                                         mais leigo. Acompanha centenas
                                         de efeitos especiais e um
                                         belo manual em html com muitas
                                         fotos (aproximadamente 20MB) que
                                         mostra o que é possível se fazer
                                         com ele.
Corel Photo Paint     GIMP               Corel Photo-Paint para
Corel Draw            Inkscape, Sodipodi Programas equivalentes
Autocad               Qcad               Programa com funções genéricas
Visio                 dia                Possui funcionalidades identicas
                                         e ótimo conjunto de ícones
winamp                xmms               Possui todos os recursos do
                                         programa para Windows além
                                         de filtros que permite acrescentar
                                         efeitos digitais da música (em
                                         tempo real), eco, etc.
media player          mplayer,playmidi   Programas para execução de
                      xwave,             arquivos de música e videos
                                         multimídia. Existem outras
                                         alternativas, a escolha
                                         depende de seu gosto e da
                                         sofisticação do programa.
Agente de Sistema     cron               Pouca diferença. O cron
                                         da mais liberdade na programação
                                         de tarefas a serem executadas
                                         pelo Linux.
Mixer                 aumix, cam         Sem diferenças.
Bate-Papo             talk, ytalk        O talk e o ytalk permite a
                                         conversa de dois usuários não
                                         só através de uma rede local,
                                         mas de qualquer parte do
                                         planeta, pois usa o protocolo
                                         tcp/ip para comunicação. Muito
                                         útil e fácil de usar.
MIRC                  Bitchx, xchat      Clientes IRC para Linux
IIS, Pers. Web Server Apache             O apache é o servidor WEB mais
                                         usado no mundo (algo em torno
                                         de 75% das empresas), muito
                                         rápido e flexível de se
                                         configurar.
Exchange, NT Mail     Postfix, Sendmail  72% da base de servidores de
                      Exim, Qmail        emails no mundo atualmente roda
                                         em software livre. Os mais recomendados
                                                                       são o Postfix e o qmail, devido a
                                                                       segurança, velocidade e integridade
                                                                       de mensagem
Wingate, MS Proxy     Squid, Apache,     A migração de um servidor proxy
                      ip masquerade,     para Linux requer o uso de
                      nat, diald,        vários programas separados para
                      exim,              que se tenha um resultado
                                         profissional. Isto pode parecer
                                         incomodo no começo, mas você logo
                                         perceberá que a divisão de serviços
                                         entre programas é mais produtivo.
                                         Quando desejar substituir um
                                         deles, o funcionamento dos
                                         outros não serão afetados.
                                         Não vou entrar em detalhes sobre os
                                         programas citados ao lado, mas o squid
                                         é um servidor proxy Web (HTTP e
                                         HTTPS) completo e também apresenta um
                                         excelente serviço FTP.
                                         Possui outros módulos como dns, ping,
                                         restrições de acesso, limites de
                                         tamanho de arquivos, cache, etc.
MS Frontpage          Mozilla            Sem comentários... todas são
                      e muitas outras    ferramentas para a geração
                      ferramentas para   de grandes Web Sites. O wdm,
                      geração de conteúdo por exemplo, é usado na geração
                      WEB (como zope,    do site da distribuição Debian
                      php3, php4, wdm,   (http://www.debian.org) em 30
                      htdig)             idiomas diferentes.
MS Winsock            Sem equivalente    O Linux tem suporte nativo a
                                         tcp/ip desde o começo de sua
                                         existência e não precisa de
                                         nenhuma camada de comunicação
                                         entre ele e a Internet. A
                                         performance é aproximadamente
                                         10% maior em conexões Internet
                                         via fax-modem e outras redes tcp/ip.
AVG, Viruscan,        Clamavis, AVG      Os maiores fabricantes de anti-virus
norton, F-PROT, CPAV. F-Prot, ViruScan   disponibilizam versões para Linux,
                                         que podem ser instaladas em servidores
                                         de E-Mail, servidores de arquivos,
                                         aumentando o nível de proteção dos
                                         usuários.

Capítulo 4. Discos e Partições

Índice

Partições
Formatando Pen-drives/Disquetes

    Formatando pen-drives para serem usados no Linux
    Formatando pen-drives compatíveis com o Windows
    Programas de Formatação Gráficos

Pontos de Montagem
Identificação de discos e partições em sistemas Linux
Montando (acessando) uma partição de disco

    fstab

Desmontando uma partição de disco

Este capítulo traz explicações de como manipular discos rígidos e partições no
sistema GNU/Linux e como acessar seus discos de CD-ROM e partições DOS, Windows
9X/XP/Vista/Seven/Oito/10 no GNU/Linux.

Partições

São divisões existentes no disco rígido que marcam onde começa onde termina um
sistema de arquivos. As partições nos permitem usar mais de um sistema
operacional no mesmo computador (como o GNU/Linux, Windows e DOS), ou dividir o
disco rígido em uma ou mais partes para ser usado por um único sistema
operacional ou até mesmo por diferentes arquiteturas (32 e 64 bits).

Uma partição de disco não interfere em outras partições existentes, por este
motivo é possível usar o Windows, GNU/Linux e qualquer outro sistema
operacional no mesmo disco. Para escolher qual deles será inicializado, veja
???.

Para particionar (dividir) o disco rígido em uma ou mais partes é necessário o
uso de um programa de particionamento. Os programas mais conhecidos para
particionamento de discos no GNU/Linux são fdisk, cfdisk e o Disk Druid.

Lembre-se:

  • Quando se apaga uma partição, você estará apagando TODOS os arquivos
    existentes nela!

  • A partição do tipo Linux Native (Tipo 83) é a usada para armazenar arquivos
    no GNU/Linux, tanto ext2, ext3, ext4, reiserfs, xfs, etc. Para detalhes
    veja ???.

  • A partição do tipo Linux Swap (Tipo 82) é usada como memória virtual. Para
    detalhes veja ???.

  • Em sistemas novos, é comum encontrar o Windows instalado em uma partição
    que consome TODO o espaço do disco rígido. Uma solução para instalar o GNU/
    Linux é apagar a partição Windows e criar três com tamanhos menores (uma
    para o Windows, uma para o GNU/Linux e outra para a Memória Virtual do
    Linux (SWAP). Ou criar apenas 2 se você não quiser mais saber mais do 
    Windows ;-)

    A outra solução é usar o parted (e gparted sua versão gráfica), que
    trabalha com FAT16, FAT32, NTFS. Esta técnica também é chamada de
    Reparticionamento não destrutivo (e o outro obviamente Reparticionamento
    destrutivo). Para sistemas que foram formatados em Windows XP e superiores,
    é possível que o parted não consiga redimensionar o sistema, neste caso
    você pode reparticionar usando ferramentas como o ntfsresize ou Partition
    Magic (para Windows).

Para mais detalhes sobre discos, partições ou como particionar seu disco, veja
algum bom documento sobre particionamento (como a página de manual e
documentação do fdisk, cfdisk, parted ou Disk Druid).

Formatando Pen-drives/Disquetes

As subseções seguintes explicarão maneiras de formatar seu pen-drive, memória
flash, e outras tecnologias (incluindo disquetes) para serem usados no GNU/
Linux e DOS/Windows.

Formatando pen-drives para serem usados no Linux

Para formatar pen-drives para serem usados no GNU/Linux use o comando:

mkfs.ext2 [-c] [/dev/sde1]

Em alguns sistemas você deve usar mke2fs no lugar de mkfs.ext2. A opção -c faz
com que o mkfs.ext2 procure por blocos danificados no pen-drive. Caso deseje
formatar um disquete, especifique o dispositivo /dev/fd0 ao inves de /dev/sdb1.

Note que o nome de dispositivo que é conectado varia de acordo com o sistema e
quantidade de discos rígidos que sua máquina possui portanto tenha ATENCÃO para
não formatar o dispositivo incorreto (que pode ser justamente seu disco rígido
principal). Para maior segurança, ao identificar o pen-drive, digite dmesg ao
conectar o pen-drive para visualizar o dispositivo correto ou fique atento as
mensagens do console que mostrará o dispositivo que foi associado ao pen-drive.

OBS: Este comando cria um sistema de arquivos ext2 no pen-drive e permite usar
características como permissões de acesso e outras. Isto também faz com que o
pen-drive NÃO possa ser lido pelo DOS/Windows. Para formatar um pen-drive no 
GNU/Linux usando o FAT16 ou FAT32 (compatível com o DOS/Windows) veja próxima
seção.

Exemplo: mkfs.ext2 -c /dev/sde1

Formatando pen-drives compatíveis com o Windows

A formatação de pen-drives para serem usados no Windows é feita usando o
comando mkfs.msdos que é geralmente incluído no pacote . O mkfs.msdos permite
tanto a criação de sistemas de arquivos FAT16 ou FAT32.

mkfs.msdos [opções] [dispositivo]

dispositivo

    Pen-drive que será formatado. Normalmente /dev/sdb1 (dependendo do
    dispositivo detectado via comando dmesg).

opções, -F [num]

    Especifica o tipo de FAT que será usado na formatação. Podem ser usados os
    valores 12 (para formatação usando FAT12, limitado a 12MB), 16 (para
    formatação usando FAT16, limitado a 2Gb) e 32 (para formatação FAT32,
    limitado a 128Gb).

-n [nome]

    Atribui o [nome] de volume ao dispositivo.

-c

    Faz uma pesquisa por bad blocks antes da criação do sistema de arquivos no
    dispositivo. Os setores defeituosos encontrados serão automaticamente
    marcados para não serem utilizadas.

-m [arquivo_mensagem]

    Especifica o arquivo que contém a mensagem que será exibida ao usuário caso
    o disco não seja inicializável. A mensagem não pode exceder 418 bytes.

Note que não se deve montar o pen-driv / disquete para formata-lo.

Segue abaixo exemplos de como formatar seu pen-drive mkfs.msdos:

  • mkfs.msdos /dev/sdc1 - Formata o pen-drive no terceiro dispositivo SCSI
    Genérico, como FAT32 e usando os valores padrões.

  • mkfs.msdos -F 16 /dev/sdc1 - Faz a mesma coisa que o acima, mas formata o
    pen-drive como FAT16.

  • mkfs.msdos -n teste -F 16 /dev/sdc1 - Formata o pen-drive no terceiro
    dispositivo SCSI genérico, como FAT16 e cria o nome de volume teste.

Programas de Formatação Gráficos

Além de programas de formatação em modo texto, existem outros para ambiente
gráfico (X11) que permitem fazer a mesma tarefa.

Entre os diversos programas destaco o gfloppy que além de permitir selecionar
se o disquete será formatado para o GNU/Linux (ext2), DOS (FAT12) e permite
selecionar a capacidade e formatação rápida do disco.

Pontos de Montagem

O GNU/Linux acessa as partições existente em seus discos rígidos e disquetes
através de diretórios. Os diretórios que são usados para acessar (montar)
partições são chamados de Pontos de Montagem. Para detalhes sobre montagem de
partições, veja “Montando (acessando) uma partição de disco”.

No DOS cada letra de unidade (C:, D:, E:) identifica uma partição de disco, no 
GNU/Linux os pontos de montagem fazem parte da grande estrutura do sistema de
arquivos raiz.

Existem muitas vantagens de se usar pontos de montagem ao invés de unidade de
disco para identificar partições (método usado no Windows):

  • Você pode montar a partição no diretório que quiser.

  • Em caso de um sistema de arquivos cheio, você pode copiar o conteúdo de um
    grande diretório para outro sistema de arquivos, apagar o conteúdo do
    diretório original e montar o disco onde foram copiados os arquivos naquele
    local (caso não use um sistema de LVM).

  • Reduz riscos de corrompimento do sistema operacional. Caso isto aconteça,
    será necessário apenas restaurar o backup do sistema de arquivos afetado.

  • Tempo de boot reduzido quando um sistema de arquivos for verificado por
    ferramentas como o fsck.

  • O uso de pontos de montagem torna o gerenciamento mais flexível.

  • A adição de novas partições ou substituição de discos rígidos não afeta a
    ordem de identificação dos discos e pontos de montagem (como não acontece
    no DOS).

Identificação de discos e partições em sistemas Linux

No GNU/Linux, os dispositivos existentes em seu computador (como discos
rígidos, pen-drives, flash, storages remotas, disquetes, tela, portas de
impressora, modem, etc) são identificados por um arquivo referente a este
dispositivo no diretório /dev.

A identificação de discos rígidos no GNU/Linux é feita da seguinte forma:

/dev/sda1
|    | ||
|    | ||_Número que identifica o número da partição no disco rígido.
|    | |
|    | |_Letra que identifica o disco rígido (a=primeiro, b=segundo, etc...).
|    |
|    |_Sigla que identifica o tipo do disco rígido (sd=SATA/SCSI, sd=IDE, xt=MFM).
|
|_Diretório onde são armazenados os dispositivos existentes no sistema.

Abaixo algumas identificações de discos e partições em sistemas Linux:

  • /dev/fd0 - Primeira unidade de disquetes.

  • /dev/fd1 - Segunda unidade de disquetes.

  • /dev/sda - Primeiro disco rígido na primeira controladora SATA ou SCSI.

  • /dev/sda1 - Primeira partição do primeiro disco rígido SATA ou.

  • /dev/sdb - Segundo disco rígido na primeira controladora SATA ou SCSI.

  • /dev/sdb1 - Primeira partição do segundo disco rígido SATA ou SCSI.

  • /dev/sr0 - Primeiro CD-ROM SATA ou SCSI.

  • /dev/sr1 - Segundo CD-ROM SATA ou SCSI.

  • /dev/hda - Primeiro disco rígido na primeira controladora IDE do micro
    (primary master).

  • /dev/hda1 - Primeira partição do primeiro disco rígido IDE.

  • /dev/hdb - Segundo disco rígido na primeira controladora IDE do micro
    (primary slave).

  • /dev/hdb1 - Primeira partição do segundo disco rígido IDE.

  • /dev/xda - Primeiro disco rígido XT.

  • /dev/xdb - Segundo disco rígido XT.

As letras de identificação de discos rígidos podem ir além de sdb, por exemplo,
caso utilize pen-drives, memória flash, as unidades serão detectadas como sdc,
sdd e assim por diante.

É importante entender como os discos e partições são identificados no sistema,
pois será necessário usar os parâmetros corretos para monta-los.

Montando (acessando) uma partição de disco

Você pode acessar uma partição de disco usando o comando mount.

mount [dispositivo] [ponto de montagem] [opções]

Onde:

dispositivo

    Identificação da unidade de disco/partição que deseja acessar (como /dev/
    hda1 (disco rígido) ou /dev/fd0 (primeira unidade de disquetes).

ponto de montagem

    Diretório de onde a unidade de disco/partição será acessado. O diretório
    deve estar vazio para montagem de um sistema de arquivo. Normalmente é
    usado o diretório /mnt para armazenamento de pontos de montagem
    temporários.

-t [tipo]

    Tipo do sistema de arquivos usado pelo dispositivo. São aceitos os sistemas
    de arquivos:

      □ ext2 - Para partições GNU/Linux usando o Extended File System versão 2
        (a mais comum).

      □ ext3 - Para partições GNU/Linux usando o Extended File System versão 3,
        com suporte a journaling.

      □ ext4 - Para partições GNU/Linux usando o Extended File System versão 4,
        com suporte a journaling.

      □ reiserfs - Para partições reiserfs, com suporte a journaling.

      □ xfs - Para partições xfs, com suporte a journaling.

      □ vfat - Para partições Windows 95 que utilizam nomes extensos de
        arquivos e diretórios.

      □ msdos - Para partições DOS normais.

      □ iso9660 - Para montar unidades de CD-ROM. É o padrão.

    Na maioria das vezes, caso o sistema de arquivos não seja especificado, o 
    mount utilizará a auto-detecção e montará a partição usando o sistema de
    arquivos correto. Para mais detalhes sobre opções usadas com cada sistema
    de arquivos, veja a página de manual mount.

-r

    Caso for especificada, monta a partição somente para leitura.

-w

    Caso for especificada, monta a partição como leitura/gravação. É o padrão.

Existem muitas outras opções que podem ser usadas com o comando mount, mas aqui
procurei somente mostrar o básico para "montar" seus discos e partições no GNU/
Linux (para mais opções, veja a página de manual do mount). Caso você digitar
mount sem parâmetros, serão mostrados que sistemas de arquivos estão atualmente
montados no sistema. Esta mesma listagem pode ser vista em /etc/mtab. A
remontagem de partição também é muito útil, especialmente após reparos nos
sistema de arquivos do disco rígido. Veja alguns exemplos de remontagem abaixo.

É necessário permissões de root para montar partições, a não ser que tenha
especificado a opção user no arquivo /etc/fstab (veja “fstab”).

Exemplo de Montagem:

  • Montar uma partição Windows (vfat) de /dev/sda1 em /mnt somente para
    leitura: mount /dev/sda1 /mnt -r -t vfat

  • Montar um pen-drive detectado em /dev/sdc1 em /mnt: mount /dev/sdc1 /mnt -t
    vfat

  • Montar uma partição DOS localizada em um segundo disco rígido /dev/hdb1 em
    /mnt: mount /dev/hdb1 /mnt -t msdos.

  • Remontar a partição raíz como somente leitura: mount -o remount,ro /

  • Remontar a partição raíz como leitura/gravação (a opção -n é usada porque o
    mount não conseguirá atualizar o arquivo /etc/mtab devido ao sistema de
    arquivos / estar montado como somente leitura atualmente: mount -n -o
    remount,rw /.

fstab

O arquivo /etc/fstab permite que as partições do sistema sejam montadas
facilmente especificando somente o dispositivo ou o ponto de montagem. Este
arquivo contém parâmetros sobre as partições que são lidos pelo comando mount.
Cada linha deste arquivo contém a partição que desejamos montar, o ponto de
montagem, o sistema de arquivos usado pela partição e outras opções. fstab tem
a seguinte forma:

Sistema_de_arquivos Ponto_de_Montagem Tipo    Opções           dump ordem
/dev/sda1           /                 ext3    defaults           0    1
/dev/sda2           /boot             ext3    defaults           0    2
/dev/sda3           /dos              msdos   defaults,noauto,rw 0    0
/dev/hdg            /cdrom            iso9660 defaults,noauto    0    0

Onde:

Sistema de Arquivos

    Partição que deseja montar.

Ponto de montagem

    Diretório do GNU/Linux onde a partição montada será acessada.

Tipo

    Tipo de sistema de arquivos usado na partição que será montada. Para
    partições GNU/Linux use ext3, reiserfs, xfs (de acordo com o tipo de
    partição selecionada durante a formatação), para partições DOS (sem nomes
    extensos de arquivos) use msdos, para partições Win 95 (com suporte a nomes
    extensos de arquivos) use vfat, para unidades de CD-ROM use iso9660.

Opções

    Especifica as opções usadas com o sistema de arquivos. Abaixo, algumas
    opções de montagem para ext2/3/4 (a lista completa pode ser encontrada na
    página de manual do mount):

      □ defaults - Utiliza valores padrões de montagem.

      □ noauto - Não monta os sistemas de arquivos durante a inicialização
        (útil para CD-ROMS e disquetes).

      □ ro - Monta como somente leitura.

      □ user - Permite que usuários montem o sistema de arquivos (não
        recomendado por motivos de segurança).

      □ sync é recomendado para uso com discos removíveis (disquetes, zip
        drives, nfs, etc) para que os dados sejam gravados imediatamente na
        unidade (caso não seja usada, você deve usar o comando “sync” antes de
        retirar o disquete da unidade.

dump

    Especifica a frequência de backup feita com o programa dump no sistema de
    arquivos. 0 desativa o backup.

Ordem

    Define a ordem que os sistemas de arquivos serão verificados na
    inicialização do sistema. Se usar 0, o sistema de arquivos não é
    verificado. O sistema de arquivos raíz que deverá ser verificado primeiro é
    o raíz "/" (a não ser quevocê tenha um sistema de arquivos de outro tipo
    que não é montado dentro do diretório raíz e possui seu suporte embutido no
    kernel).

Após configurar o /etc/fstab, basta digitar o comando mount /dev/hdg ou mount /
cdrom para que a unidade de CD-ROM seja montada. Você deve ter notado que não é
necessário especificar o sistema de arquivos da partição pois o mount
verificará se ele já existe no /etc/fstab e caso existir, usará as opções
especificadas neste arquivo. Para maiores detalhes veja as páginas de manual
fstab e mount.

Desmontando uma partição de disco

Utilize o comando umount para desmontar um sistema de arquivos que foi montado
com o mount. Você deve ter permissões de root para desmontar uma partição.

umount [dispositivo/ponto de montagem]

Você pode tanto usar umount /dev/sda1 como umount /mnt para desmontar um
sistema de arquivos /dev/sda1 montado em /mnt.

Observação: O comando umount executa o sync automaticamente no momento da
desmontagem, para garantir que todos os dados ainda em memória RAM sejam
salvos.

Capítulo 5. Execução de programas

Índice

Executando um comando/programa
path
Tipos de Execução de comandos/programas
Executando programas em seqüência
ps
top
Controle de execução de processos

    Interrompendo a execução de um processo
    Parando momentaneamente a execução de um processo
    jobs
    fg
    bg
    kill
    killall
    killall5
    Sinais do Sistema

Fechando um programa quando não se sabe como sair
Eliminando caracteres estranhos

Este capítulo explica como executar programas no GNU/Linux e o uso das
ferramentas de controle de execução dos programas.

Executando um comando/programa

Para executar um comando, é necessário que ele tenha permissões de execução
(veja “Tipos de Permissões de Acesso” e “ls”) e que esteja no caminho de
procura de arquivos (veja “path”).

No aviso de comando #(root) ou $(usuário), digite o nome do comando e tecle
Enter. O programa/comando é executado e receberá um número de identificação
(chamado de PID - Process Identification), este número é útil para identificar
o processo no sistema e assim ter um controle sobre sua execução (será visto
mais adiante neste capítulo).

Todo o programa executado no Linux roda sob o controle das permissões de
acesso. Recomendo ver mais tarde o Capítulo 11, Permissões de acesso a arquivos
e diretórios.

Exemplos de comandos: ls, df, pwd.

path

Path é o caminho de procura dos arquivos/comandos executáveis. O path (caminho)
é armazenado na variável de ambiente PATH. Você pode ver o conteúdo desta
variável com o comando echo $PATH.

Por exemplo, o caminho /usr/local/bin:/usr/bin:/bin:/usr/bin/X11 significa que
se você digitar o comando ls, o interpretador de comandos iniciará a procura do
programa ls no diretório /usr/local/bin, caso não encontre o arquivo no
diretório /usr/local/bin ele inicia a procura em /usr/bin, até que encontre o
arquivo procurado.

Caso o interpretador de comandos chegue até o último diretório do path e não
encontre o arquivo/comando digitado, é mostrada a seguinte mensagem:

bash: ls: command not found (comando não encontrado).

O caminho de diretórios vem configurado na instalação do Linux, mas pode ser
alterado no arquivo /etc/profile. Caso deseje alterar o caminho para todos os
usuários, este arquivo é o melhor lugar, pois ele é lido por todos os usuários
no momento do login.

Caso um arquivo/comando não esteja localizado em nenhum dos diretórios do path,
você deve executa-lo usando um ./ na frente do comando.

Se deseja alterar o path para um único usuário, modifique o arquivo
.bash_profile em seu diretório de usuário (home).

OBSERVAÇÃO: Por motivos de segurança, não inclua o diretório atual $PWD no
path.

Tipos de Execução de comandos/programas

Um programa pode ser executado de duas formas:

 1. Primeiro Plano - Também chamado de foreground. Quando você deve esperar o
    término da execução de um programa para executar um novo comando. Somente é
    mostrado o aviso de comando após o término de execução do comando/programa.

 2. Segundo Plano - Também chamado de background. Quando você não precisa
    esperar o término da execução de um programa para executar um novo comando.
    Após iniciar um programa em background, é mostrado um número PID
    (identificação do Processo) e o aviso de comando é novamente mostrado,
    permitindo o uso normal do sistema.

    O programa executado em background continua sendo executado internamente.
    Após ser concluído, o sistema retorna uma mensagem de pronto acompanhado do
    número PID do processo que terminou.

Para iniciar um programa em primeiro plano, basta digitar seu nome normalmente.
Para iniciar um programa em segundo plano, acrescente o caracter "&" após o
final do comando.

OBS: Mesmo que um usuário execute um programa em segundo plano e saia do
sistema, o programa continuará sendo executado até que seja concluído ou
finalizado pelo usuário que iniciou a execução (ou pelo usuário root).

Exemplo: find / -name boot.b &

O comando será executado em segundo plano e deixará o sistema livre para outras
tarefas. Após o comando find terminar, será mostrada uma mensagem.

Executando programas em seqüência

Os comandos podem ser executados em seqüência (um após o término do outro) se
os separarmos com ";". Por exemplo: echo primeiro;echo segundo;echo terceiro

ps

Algumas vezes é útil ver quais processos estão sendo executados no computador.
O comando ps faz isto, e também nos mostra qual usuário executou o programa,
hora que o processo foi iniciado, etc.

ps [opções]

Onde:

opções, a

    Mostra os processos criados por você e de outros usuários do sistema.

x

    Mostra processos que não são controlados pelo terminal.

u

    Mostra o nome de usuário que iniciou o processo e hora em que o processo
    foi iniciado.

m

    Mostra a memória ocupada por cada processo em execução.

f

    Mostra a árvore de execução de comandos (comandos que são chamados por
    outros comandos).

e

    Mostra variáveis de ambiente no momento da inicialização do processo.

w

    Mostra a continuação da linha atual na próxima linha ao invés de cortar o
    restante que não couber na tela.

--sort:[coluna]

    Organiza a saída do comando ps de acordo com a coluna escolhida. Você pode
    usar as colunas pid, utime, ppid, rss, size, user, priority.

    Pode ser especificada uma listagem em ordem inversa especificando --sort:
    [-coluna]. Para mais detalhes e outras opções, veja a página de manual.

As opções acima podem ser combinadas para resultar em uma listagem mais
completa. Você também pode usar pipes "|" para filtrar a saída do comando ps.
Para detalhes, veja “| (pipe)”.

Ao contrário de outros comandos, o comando ps não precisa do hífen "-" para
especificar os comandos. Isto porque ele não utiliza opções longas e não usa
parâmetros.

Exemplos: ps, ps ax|grep inetd, ps auxf, ps auxw.

top

Mostra os programas em execução ativos, parados, tempo usado na CPU, detalhes
sobre o uso da memória RAM, Swap, disponibilidade para execução de programas no
sistema, etc.

top é um programa que continua em execução mostrando continuamente os processos
que estão rodando em seu computador e os recursos utilizados por eles. Para
sair do top, pressione a tecla q.

top [opções]

Onde:

-d [tempo]

    Atualiza a tela após o [tempo] (em segundos).

-s

    Diz ao top para ser executado em modo seguro.

-i

    Inicia o top ignorando o tempo de processos zumbis.

-c

    Mostra a linha de comando ao invés do nome do programa.

A ajuda sobre o top pode ser obtida dentro do programa pressionando a tecla h
ou pela página de manual (man top).

Abaixo algumas teclas úteis:

  • espaço - Atualiza imediatamente a tela.

  • CTRL+L - Apaga e atualiza a tela.

  • h - Mostra a tela de ajuda do programa. É mostrado todas as teclas que
    podem ser usadas com o top.

  • i - Ignora o tempo ocioso de processos zumbis.

  • q - Sai do programa.

  • k - Finaliza um processo - semelhante ao comando kill. Você será perguntado
    pelo número de identificação do processo (PID). Este comando não estará
    disponível caso esteja usando o top com a opção -s.

  • n - Muda o número de linhas mostradas na tela. Se 0 for especificado, será
    usada toda a tela para listagem de processos.

Controle de execução de processos

Abaixo algumas comandos e métodos úteis para o controle da execução de
processos no Linux.

Interrompendo a execução de um processo

Para cancelar a execução de algum processo rodando em primeiro plano, basta
pressionar as teclas CTRL+C. A execução do programa será cancelada e será
mostrado o aviso de comando. Você também pode usar o comando “kill” para
interromper um processo sendo executado.

Parando momentaneamente a execução de um processo

Para parar a execução de um processo rodando em primeiro plano, basta
pressionar as teclas CTRL+Z. O programa em execução será pausado e será
mostrado o número de seu job e o aviso de comando.

Para retornar a execução de um comando pausado, use “fg” ou “bg”.

O programa permanece na memória no ponto de processamento em que parou quando
ele é interrompido. Você pode usar outros comandos ou rodar outros programas
enquanto o programa atual está interrompido.

jobs

O comando jobs mostra os processos que estão parados ou rodando em segundo
plano. Processos em segundo plano são iniciados usando o símbolo "&" no final
da linha de comando (veja “Tipos de Execução de comandos/programas”) ou através
do comando bg.

jobs

O número de identificação de cada processo parado ou em segundo plano (job), é
usado com os comandos “fg” e “bg”. Um processo interrompido pode ser finalizado
usando-se o comando kill %[num], onde [num] é o número do processo obtido pelo
comando jobs.

fg

Permite fazer um programa rodando em segundo plano ou parado, rodar em primeiro
plano. Você deve usar o comando jobs para pegar o número do processo rodando em
segundo plano ou interrompido, este número será passado ao comando fg para
ativa-lo em primeiro plano.

fg [número]

Onde número é o número obtido através do comando jobs.

Caso seja usado sem parâmetros, o fg utilizará o último programa interrompido
(o maior número obtido com o comando jobs).

Exemplo: fg 1.

bg

Permite fazer um programa rodando em primeiro plano ou parado, rodar em segundo
plano. Para fazer um programa em primeiro plano rodar em segundo, é necessário
primeiro interromper a execução do comando com CTRL+ Z, será mostrado o número
da tarefa interrompida, use este número com o comando bg para iniciar a
execução do comando em segundo plano.

bg [número]

Onde: número número do programa obtido com o pressionamento das teclas CTRL+Z
ou através do comando jobs.

kill

Permite enviar um sinal a um comando/programa. Caso seja usado sem parâmetros,
o kill enviará um sinal de término ao processo sendo executado.

kill opções] [sinal] [número]

Onde:

número

    É o número de identificação do processo obtido com o comando “ps”. Também
    pode ser o número após o sinal de % obtido pelo comando jobs para matar uma
    tarefa interrompida. Veja “jobs”.

sinal

    Sinal que será enviado ao processo. Se omitido usa -15 como padrão.

opções, -9

    Envia um sinal de destruição ao processo ou programa. Ele é terminado
    imediatamente sem chances de salvar os dados ou apagar os arquivos
    temporários criados por ele.

Você precisa ser o dono do processo ou o usuário root para termina-lo ou
destruí-lo. Você pode verificar se o processo foi finalizado através do comando
ps. Os tipos de sinais aceitos pelo GNU/Linux são explicados em detalhes em
“Sinais do Sistema”.

Exemplo: kill 500, kill -9 500, kill %1.

killall

Permite finalizar processos através do nome.

killall [opções] [sinal] [processo]

Onde:

processo

    Nome do processo que deseja finalizar

sinal

    Sinal que será enviado ao processo (pode ser obtido usando a opção -i).

opções, -i

    Pede confirmação sobre a finalização do processo.

-l

    Lista o nome de todos os sinais conhecidos.

-q

    Ignora a existência do processo.

-v

    Retorna se o sinal foi enviado com sucesso ao processo.

-w

    Finaliza a execução do killall somente após finalizar todos os processos.

Os tipos de sinais aceitos pelo GNU/Linux são explicados em detalhes na “Sinais
do Sistema”.

Exemplo: killall -HUP inetd

killall5

Envia um sinal de finalização para todos os processos sendo executados.

killall5 [sinal]

Sinais do Sistema

Retirado da página de manual signal. O GNU/Linux suporta os sinais listados
abaixo. Alguns números de sinais são dependentes de arquitetura.

Primeiro, os sinais descritos no POSIX 1:

Sinal   Valor     Ação    Comentário
---------------------------------------------------------------------------
HUP        1        A      Travamento detectado no terminal de controle ou
                           finalização do processo controlado
INT        2        A      Interrupção através do teclado
QUIT       3        C      Sair através do teclado
ILL        4        C      Instrução Ilegal
ABRT       6        C      Sinal de abortar enviado pela função abort
FPE        8        C      Exceção de ponto Flutuante
KILL       9       AEF     Sinal de destruição do processo
SEGV      11        C      Referência Inválida de memória
PIPE      13        A      Pipe Quebrado: escreveu para o pipe sem leitores
ALRM      14        A      Sinal do Temporizador da chamada do sistema alarm
TERM      15        A      Sinal de Término
USR1   30,10,16     A      Sinal definido pelo usuário 1
USR2   31,12,17     A      Sinal definido pelo usuário 2
CHLD   20,17,18     B      Processo filho parado ou terminado
CONT   19,18,25            Continuar a execução, se interrompido
STOP   17,19,23    DEF     Interromper processo
TSTP   18,20,24     D      Interromper digitação no terminal
TTIN   21,21,26     D      Entrada do terminal para o processo em segundo plano
TTOU   22,22,27     D      Saída do terminal para o processo em segundo plano

As letras da coluna Ação tem o seguinte significado:

  • A - A ação padrão é terminar o processo.

  • B - A ação padrão é ignorar o sinal.

  • C - A ação padrão é terminar o processo e mostrar o core.

  • D - A ação padrão é parar o processo.

  • E - O sinal não pode ser pego.

  • F - O sinal não pode ser ignorado.

Sinais não descritos no POSIX 1 mas descritos na SUSv2:

Sinal     Valor     Ação     Comentário
-------------------------------------------------------------------------
BUS      10,7,10      C      Erro no Barramento (acesso incorreto da memória)
POLL                  A      Evento executado em Pool (Sys V). Sinônimo de IO
PROF     27,27,29     A      Tempo expirado do Profiling
SYS      12,-,12      C      Argumento inválido para a rotina (SVID)
TRAP        5         C      Captura do traço/ponto de interrupção
URG      16,23,21     B      Condição Urgente no soquete (4.2 BSD)
VTALRM   26,26,28     A      Alarme virtual do relógio (4.2 BSD)
XCPU     24,24,30     C      Tempo limite da CPU excedido (4.2 BSD)
XFSZ     25,25,31     C      Limite do tamanho de arquivo excedido (4.2 BSD)

(Para os casos SIGSYS, SIGXCPU, SIGXFSZ, e em algumas arquiteturas também o
SIGGUS, a ação padrão do Linux para kernels 2.3.27 e superiores é A (terminar),
enquanto SYSv2 descreve C (terminar e mostrar dump core).) Seguem vários outros
sinais:

Sinal     Valor     Ação     Comentário
--------------------------------------------------------------------
IOT         6         C      Traço IOT. Um sinônimo para ABRT
EMT       7,-,7
STKFLT    -,16,-      A      Falha na pilha do processador
IO       23,29,22     A      I/O agora possível (4.2 BSD)
CLD       -,-,18             Um sinônimo para CHLD
PWR      29,30,19     A      Falha de força (System V)
INFO      29,-,-             Um sinônimo para SIGPWR
LOST      -,-,-       A      Perda do bloqueio do arquivo
WINCH    28,28,20     B      Sinal de redimensionamento da Janela (4.3 BSD, Sun)
UNUSED    -,31,-      A      Sinal não usado (será SYS)

O "-" significa que o sinal não está presente. Onde três valores são listados,
o primeiro é normalmente válido para o Alpha e Sparc, o do meio para i386,
PowerPc e sh, o último para o Mips. O sinal 29 é SIGINFO/SIGPWR em um Alpha mas
SIGLOST em um Sparc.

Fechando um programa quando não se sabe como sair

Muitas vezes quando se esta iniciando no GNU/Linux você pode executar um
programa e talvez não saiba como fecha-lo. Este capítulo do guia pretende
ajuda-lo a resolver este tipo de problema.

Isto pode também ocorrer com programadores que estão construindo seus programas
e por algum motivo não implementam uma opção de saída, ou ela não funciona!

Em nosso exemplo vou supor que executamos um programa em desenvolvimento com o
nome contagem que conta o tempo em segundos a partir do momento que é
executado, mas que o programador esqueceu de colocar uma opção de saída. Siga
estas dicas para finaliza-lo:

 1. Normalmente todos os programas UNIX (o GNU/Linux também é um Sistema
    Operacional baseado no UNIX) podem ser interrompidos com o pressionamento
    das teclas <CTRL> e <C>. Tente isto primeiro para finalizar um programa.
    Isto provavelmente não vai funcionar se estiver usando um Editor de Texto
    (ele vai entender como um comando de menu). Isto normalmente funciona para
    comandos que são executados e terminados sem a intervenção do usuário.

    Caso isto não der certo, vamos partir para a força! ;-)

 2. Mude para um novo console (pressionando <ALT> e <F2>), e faça o login como
    usuário root.

 3. Localize o PID (número de identificação do processo) usando o comando: ps
    ax, aparecerão várias linhas cada uma com o número do processo na primeira
    coluna, e a linha de comando do programa na última coluna. Caso aparecerem
    vários processos você pode usar ps ax|grep contagem, neste caso o grep fará
    uma filtragem da saída do comando ps ax mostrando somente as linhas que tem
    a palavra "contagem". Para maiores detalhes, veja o comando “grep”.

 4. Feche o processo usando o comando kill PID, lembre-se de substituir PID
    pelo número encontrado pelo comando ps ax acima.

    O comando acima envia um sinal de término de execução para o processo
    (neste caso o programa contagem). O sinal de término mantém a chance do
    programa salvar seus dados ou apagar os arquivos temporários que criou e
    então ser finalizado, isto depende do programa.

 5. Alterne para o console onde estava executando o programa contagem e
    verifique se ele ainda está em execução. Se ele estiver parado mas o aviso
    de comando não está disponível, pressione a tecla <ENTER>. Freqüentemente
    acontece isto com o comando kill, você finaliza um programa mas o aviso de
    comando não é mostrado até que se pressione <ENTER>.

 6. Caso o programa ainda não foi finalizado, repita o comando kill usando a
    opção -9: kill -9 PID. Este comando envia um sinal de DESTRUIÇÃO do
    processo, fazendo ele terminar "na marra"!

Uma última dica: todos os programas estáveis (todos que acompanham as boas
distribuições GNU/Linux) tem sua opção de saída. Lembre-se que quando finaliza
um processo todos os dados do programa em execução podem ser perdidos
(principalmente se estiver em um editor de textos), mesmo usando o kill sem o
parâmetro -9.

Procure a opção de saída de um programa consultando o help on line, as páginas
de manual, a documentação que acompanha o programa, info pages. Para detalhes
de como encontrar a ajuda dos programas, veja o Capítulo 16, Como obter ajuda

Eliminando caracteres estranhos

As vezes quando um programa mal comportado é finalizado ou quando você
visualiza um arquivo binário através do comando cat, é possível que o aviso de
comando (prompt) volte com caracteres estranhos.

Para fazer tudo voltar ao normal, basta digitar reset e teclar ENTER. Não se
preocupe, o comando reset não reiniciará seu computador (como o botão reset do
seu computador faz), ele apenas fará tudo voltar ao normal.

Note que enquanto você digitar reset aparecerão caracteres estranhos ao invés
das letras. Não se preocupe! Basta digitar corretamente e bater ENTER e o aviso
de comando voltará ao normal.

Capítulo 6. Comandos para manipulação de diretório

Índice

ls
cd
pwd
mkdir
rmdir

Abaixo comandos úteis para a manipulação de diretórios.

ls

Lista os arquivos de um diretório.

ls [opções] [caminho/arquivo] [caminho1/arquivo1] ...

onde:

caminho/arquivo

    Diretório/arquivo que será listado.

caminho1/arquivo1

    Outro Diretório/arquivo que será listado. Podem ser feitas várias listagens
    de uma só vez.

opções, -a, --all

    Lista todos os arquivos (inclusive os ocultos) de um diretório.

-A, --almost-all

    Lista todos os arquivos (inclusive os ocultos) de um diretório, exceto o
    diretório atual e o de nível anterior.

-B, --ignore-backups

    Não lista arquivos que terminam com ~ (Backup).

--color=PARAM

    Mostra os arquivos em cores diferentes, conforme o tipo de arquivo. PARAM
    pode ser:

      □ never - Nunca lista em cores (mesma coisa de não usar o parâmetro
        --color).

      □ always - Sempre lista em cores conforme o tipo de arquivo.

      □ auto - Somente colore a listagem se estiver em um terminal.

-d, --directory

    Lista os nomes dos diretórios ao invés do conteúdo.

-f

    Não classifica a listagem.

-F

    Insere um caracter após arquivos executáveis ('*'), diretórios ('/'),
    soquete ('='), link simbólico ('@') e pipe ('|'). Seu uso é útil para
    identificar de forma fácil tipos de arquivos nas listagens de diretórios.

-G, --no-group

    Oculta a coluna de grupo do arquivo.

-h, --human-readable

    Mostra o tamanho dos arquivos em Kbytes, Mbytes, Gbytes.

-H

    Faz o mesmo que -h, mas usa unidades de 1000 ao invés de 1024 para
    especificar Kbytes, Mbytes, Gbytes.

-l

    Usa o formato longo para listagem de arquivos. Lista as permissões, data de
    modificação, donos, grupos, etc.

-n

    Usa a identificação de usuário e grupo numérica ao invés dos nomes.

-L, --dereference

    Lista o arquivo original e não o link referente ao arquivo.

-o

    Usa a listagem longa sem os donos dos arquivos (mesma coisa que -lG).

-p

    Mesma coisa que -F, mas não inclui o símbolo '*' em arquivos executáveis.
    Esta opção é típica de sistemas Linux.

-R

    Lista diretórios e sub-diretórios recursivamente.

--full-time

    Lista data e hora completa.

Classificação da listagem

    A listagem pode ser classificada usando-se as seguintes opções:

    -f

        Não classifica, e usa -au para listar os arquivos.

    -r

        Inverte a ordem de classificação.

    -c

        Classifica pela data de alteração.

    -X

        Classifica pela extensão.

    -U

        Não classifica, lista os arquivos na ordem do diretório.

    -Z

        Exibe o contexto SELinux de cada arquivo.

Uma listagem feita com o comando ls -la normalmente é mostrada da seguinte
maneira:

-rwxr-xr--  1  gleydson user    8192 nov 4 16:00 teste

Abaixo as explicações de cada parte:

-rwxr-xr--

    São as permissões de acesso ao arquivo teste. A primeira letra (da
    esquerda) identifica o tipo do arquivo, se tiver um d é um diretório, se
    tiver um "-" é um arquivo normal.

    As permissões de acesso é explicada em detalhes em Capítulo 11, Permissões
    de acesso a arquivos e diretórios.

1

    Se for um diretório, mostra a quantidade de sub-diretórios existentes
    dentro dele. Caso for um arquivo, será 1.

gleydson

    Nome do dono do arquivo teste.

user

    Nome do grupo que o arquivo teste pertence.

8192

    Tamanho do arquivo (em bytes).

nov

    Mês da criação/ última modificação do arquivo.

4

    Dia que o arquivo foi criado.

16:00

    Hora em que o arquivo foi criado/modificado. Se o arquivo foi criado há
    mais de um ano, em seu lugar é mostrado o ano da criação do arquivo.

teste

    Nome do arquivo.

Exemplos do uso do comando ls:

  • ls - Lista os arquivos do diretório atual.

  • ls /bin /sbin - Lista os arquivos do diretório /bin e /sbin

  • ls -la /bin - Listagem completa (vertical) dos arquivos do diretório /bin
    inclusive os ocultos.

cd

Entra em um diretório. Você precisa ter a permissão de execução para entrar no
diretório.

cd [diretório]

onde:

diretório - diretório que deseja entrar.

Exemplos:

  • Usando cd sem parâmetros ou cd ~, você retornará ao seu diretório de
    usuário (diretório home).

  • cd /, retornará ao diretório raíz.

  • cd -, retornará ao diretório anteriormente acessado.

  • cd .., sobe um diretório.

  • cd ../[diretório], sobe um diretório e entra imediatamente no próximo (por
    exemplo, quando você está em /usr/sbin, você digita cd ../bin, o comando cd
    retorna um diretório (/usr) e entra imediatamente no diretório bin (/usr/
    bin).

pwd

Mostra o nome e caminho do diretório atual.

Você pode usar o comando pwd para verificar em qual diretório se encontra (caso
seu aviso de comandos não mostre isso).

mkdir

Cria um diretório no sistema. Um diretório é usado para armazenar arquivos de
um determinado tipo. O diretório pode ser entendido como uma pasta onde você
guarda seus papeis (arquivos). Como uma pessoa organizada, você utilizará uma
pasta para guardar cada tipo de documento, da mesma forma você pode criar um
diretório vendas para guardar seus arquivos relacionados com vendas naquele
local.

mkdir [opções] [caminho/diretório] [caminho1/diretório1]

onde:

caminho

    Caminho onde o diretório será criado.

diretório

    Nome do diretório que será criado.

opções:, -p

    Caso os diretórios dos níveis acima não existam, eles também serão criados.

--verbose

    Mostra uma mensagem para cada diretório criado. As mensagens de erro serão
    mostradas mesmo que esta opção não seja usada.

Para criar um novo diretório, você deve ter permissão de gravação. Por exemplo,
para criar um diretório em /tmp com o nome de teste que será usado para gravar
arquivos de teste, você deve usar o comando "mkdir /tmp/teste".

Podem ser criados mais de um diretório com um único comando (mkdir /tmp/teste /
tmp/teste1 /tmp/teste2).

rmdir

Remove um diretório do sistema. Este comando faz exatamente o contrário do 
mkdir. O diretório a ser removido deve estar vazio e você deve ter permissão de
gravação para remove-lo.

rmdir [caminho/diretório] [caminho1/diretório1]

onde:

caminho

    Caminho do diretório que será removido.

diretório

    Nome do diretório que será removido.

É necessário que esteja um nível acima do diretório(s) que será(ão) removido
(s). Para remover diretórios que contenham arquivos, use o comando rm com a
opção -r (para maiores detalhes, veja “rm”).

Por exemplo, para remover o diretório /tmp/teste você deve estar no diretório
tmp e executar o comando rmdir teste.

Capítulo 7. Comandos para manipulação de Arquivos

Índice

cat
tac
rm
cp
mv

Abaixo, comandos utilizados para manipulação de arquivos.

cat

Mostra o conteúdo de um arquivo binário ou texto.

cat [opções] [diretório/arquivo] [diretório1/arquivo1]

diretório/arquivo

    Localização do arquivo que deseja visualizar o conteúdo.

opções, -n, --number

    Mostra o número das linhas enquanto o conteúdo do arquivo é mostrado.

-s, --squeeze-blank

    Não mostra mais que uma linha em branco entre um parágrafo e outro.

-

    Lê a entrada padrão.

O comando cat trabalha com arquivos texto. Use o comando zcat para ver
diretamente arquivos compactados com gzip.

Exemplo: cat /usr/doc/copyright/GPL

tac

Mostra o conteúdo de um arquivo binário ou texto (como o cat) só que em ordem
inversa.

tac [opções] [diretório/arquivo] [diretório1/arquivo1]

diretório/arquivo

    Localização do arquivo que deseja visualizar o conteúdo

opções, -s [string]

    Usa o [string] como separador de registros.

-

    Lê a entrada padrão.

Exemplo: tac /usr/doc/copyright/GPL.

rm

Apaga arquivos. Também pode ser usado para apagar diretórios e sub-diretórios
vazios ou que contenham arquivos.

rm [opções][caminho][arquivo/diretório] [caminho1][arquivo1/diretório1]

onde:

caminho

    Localização do arquivo que deseja apagar. Se omitido, assume que o arquivo
    esteja no diretório atual.

arquivo/diretório

    Arquivo que será apagado.

opções, -i, --interactive

    Pergunta antes de remover, esta é ativada por padrão.

-v, --verbose

    Mostra os arquivos na medida que são removidos.

-r, --recursive

    Usado para remover arquivos em sub-diretórios. Esta opção também pode ser
    usada para remover sub-diretórios.

-f, --force

    Remove os arquivos sem perguntar.

-- arquivo

    Remove arquivos/diretórios que contém caracteres especiais. O separador
    "--" funciona com todos os comandos do shell e permite que os caracteres
    especiais como "*", "?", "-", etc. sejam interpretados como caracteres
    comuns.

Use com atenção o comando rm, uma vez que os arquivos e diretórios forem
apagados, eles não poderão ser mais recuperados.

Exemplos:

  • rm teste.txt - Apaga o arquivo teste.txt no diretório atual.

  • rm *.txt - Apaga todos os arquivos do diretório atual que terminam com
    .txt.

  • rm *.txt teste.novo - Apaga todos os arquivos do diretório atual que
    terminam com .txt e também o arquivo teste.novo.

  • rm -rf /tmp/teste/* - Apaga todos os arquivos e sub-diretórios do diretório
    /tmp/teste mas mantém o sub-diretório /tmp/teste.

  • rm -rf /tmp/teste - Apaga todos os arquivos e sub-diretórios do diretório /
    tmp/teste, inclusive /tmp/teste.

  • rm -f -- --arquivo-- - Remove o arquivo de nome --arquivo--.

cp

Copia arquivos.

cp [opções] [origem] [destino]

onde:

origem

    Arquivo que será copiado. Podem ser especificados mais de um arquivo para
    ser copiado usando "coringas" (veja “coringas”).

destino

    O caminho ou nome de arquivo onde será copiado. Se o destino for um
    diretório, os arquivos de origem serão copiados para dentro do diretório.

opções, i, --interactive

    Pergunta antes de substituir um arquivo existente.

-f, --force

    Não pergunta, substitui todos os arquivos caso já exista.

-r

    Copia arquivos dos diretórios e subdiretórios da origem para o destino. É
    recomendável usar -R ao invés de -r.

-R, --recursive

    Copia arquivos e sub-diretórios (como a opção -r) e também os arquivos
    especiais FIFO e dispositivos.

-v, --verbose

    Mostra os arquivos enquanto estão sendo copiados.

-s, --simbolic-link

    Cria link simbólico ao invés de copiar.

-l, --link

    Faz o link no destino ao invés de copiar os arquivos.

-p, --preserve

    Preserva atributos do arquivo, se for possível.

-u, --update

    Copia somente se o arquivo de origem é mais novo que o arquivo de destino
    ou quando o arquivo de destino não existe.

-x

    Não copia arquivos que estão localizados em um sistema de arquivos
    diferente de onde a cópia iniciou.

O comando cp copia arquivos da ORIGEM para o DESTINO. Ambos origem e destino
terão o mesmo conteúdo após a cópia.

Exemplos:

cp teste.txt teste1.txt

    Copia o arquivo teste.txt para teste1.txt.

cp teste.txt /tmp

    Copia o arquivo teste.txt para dentro do diretório /tmp.

cp * /tmp

    Copia todos os arquivos do diretório atual para /tmp.

cp /bin/* .

    Copia todos os arquivos do diretório /bin para o diretório em que nos
    encontramos no momento.

cp -R /bin /tmp

    Copia o diretório /bin e todos os arquivos/sub-diretórios existentes para o
    diretório /tmp.

cp -R /bin/* /tmp

    Copia todos os arquivos do diretório /bin (exceto o diretório /bin) e todos
    os arquivos/sub-diretórios existentes dentro dele para /tmp.

cp -R /bin /tmp

    Copia todos os arquivos e o diretório /bin para /tmp.

mv

Move ou renomeia arquivos e diretórios. O processo é semelhante ao do comando 
cp mas o arquivo de origem é apagado após o término da cópia.

mv [opções] [origem] [destino]

Onde:

origem

    Arquivo/diretório de origem.

destino

    Local onde será movido ou novo nome do arquivo/diretório.

opções, -f, --force

    Substitui o arquivo de destino sem perguntar.

-i, --interactive

    Pergunta antes de substituir. É o padrão.

-v, --verbose

    Mostra os arquivos que estão sendo movidos.

-u, --update

    Move somente arquivos antigos, ou novos arquivos.

O comando mv copia um arquivo da ORIGEM para o DESTINO (semelhante ao cp), mas
após a cópia, o arquivo de ORIGEM é apagado.

Exemplos:

mv teste.txt teste1.txt

    Muda o nome do arquivo teste.txt para teste1.txt.

mv teste.txt /tmp

    Move o arquivo teste.txt para /tmp. Lembre-se que o arquivo de origem é
    apagado após ser movido.

mv teste.txt teste.new (supondo que teste.new já exista)

    Copia o arquivo teste.txt por cima de teste.new e apaga teste.txt após
    terminar a cópia.

Capítulo 8. Comandos Diversos

Índice

clear
date
df
ln
du
find
free
grep
head
nl
more
less
sort
tail
time
touch
uptime
dmesg
mesg
echo
su
sync
uname
reboot
shutdown
wc
seq
chattr
lsattr
cut
cmp
dirname
diff
pr
patch
whereis
which
zforce
gzexe
znew

Comandos de uso diversos no sistema.

clear

Limpa a tela e posiciona o cursor no canto superior esquerdo do vídeo.

clear

date

Permite ver/modificar a Data e Hora do Sistema. Você precisa estar como usuário
root para modificar a data e hora. Muitos programas do sistema, arquivos de
registro (log) e tarefas agendadas funcionam com base na data e hora fornecidas
pelo sistema, assim esteja consciente das modificações que a data/hora pode
trazer a estes programas (principalmente em se tratando de uma rede com muitos
usuários).

date MesDiaHoraMinuto[AnoSegundos]

Onde:

MesDiaHoraMinuto[AnoSegundos]

    São respectivamente os números do mês, dia, hora e minutos sem espaços.
    Opcionalmente você pode especificar o Ano (com 2 ou 4 dígitos) e os
    Segundos.

+[FORMATO]

    Define o formato da listagem que será usada pelo comando date. Os seguintes
    formatos são os mais usados:

      □ %d - Dia do Mês (00-31).

      □ %m - Mês do Ano (00-12).

      □ %y - Ano (dois dígitos).

      □ %Y - Ano (quatro dígitos).

      □ %H - Hora (00-24).

      □ %I - Hora (00-12).

      □ %M - Minuto (00-59).

      □ %j - Dia do ano (1-366).

      □ %p - AM/PM (útil se utilizado com %d).

      □ %r - Formato de 12 horas completo (hh:mm:ss AM/PM).

      □ %T - Formato de 24 horas completo (hh:mm:ss).

      □ %w - Dia da semana (0-6).

    Outros formatos podem ser obtidos através da página de manual do date.

Para maiores detalhes, veja a página de manual do comando date.

Para ver a data atual digite: date

Se quiser mudar a Data para 25/12 e a hora para 08:15 digite: date 12250815

Para mostrar somente a data no formato dia/mês/ano: date +%d/%m/%Y

df

Mostra o espaço livre/ocupado de cada partição.

df [opções]

onde:

opções, -a

    Inclui sistemas de arquivos com 0 blocos.

-h, --human-readable

    Mostra o espaço livre/ocupado em MB, KB, GB ao invés de blocos.

-H

    Idêntico a -h mas usa 1000 ao invés de 1024 como unidade de cálculo.

-k

    Lista em Kbytes.

-l

    Somente lista sistema de arquivos locais.

-m

    Lista em Mbytes (equivalente a --block-size=1048576).

--sync

    Executa o sync antes de mostrar os dados.

-T

    Lista o tipo de sistema de arquivos de cada partição

-t tipo

    Lista somente sistema de arquivos do tipo tipo.

-x tipo

    Não lista sistemas de arquivos do tipo tipo.

Exemplos: df, df -h, df -t vfat.

ln

Cria links para arquivos e diretórios no sistema. O link é um mecanismo que faz
referência a outro arquivo ou diretório em outra localização. O link em
sistemas GNU/Linux faz referência reais ao arquivo/diretório podendo ser feita
cópia do link (será copiado o arquivo alvo), entrar no diretório (caso o link
faça referência a um diretório), etc.

ln [opções] [origem] [link]

Onde:

origem

    Diretório ou arquivo de onde será feito o link.

link

    Nome do link que será criado.

opções, -s

    Cria um link simbólico. Usado para criar ligações com o arquivo/diretório
    de destino.

-v

    Mostra o nome de cada arquivo antes de fazer o link.

-d

    Cria um hard link para diretórios. Somente o root pode usar esta opção.

Existem 2 tipos de links: simbólicos e hardlinks.

  • O link simbólico cria um arquivo especial no disco (do tipo link) que tem
    como conteúdo o caminho para chegar até o arquivo alvo (isto pode ser
    verificado pelo tamanho do arquivo do link). Use a opção -s para criar
    links simbólicos.

  • O hardlink faz referência ao mesmo inodo do arquivo original, desta forma
    ele será perfeitamente idêntico, inclusive nas permissões de acesso, ao
    arquivo original.

    Ao contrário dos links simbólicos, não é possível fazer um hardlink para um
    diretório ou fazer referência a arquivos que estejam em partições
    diferentes.

Observações:

  • Se for usado o comando rm com um link, somente o link será removido.

  • Se for usado o comando cp com um link, o arquivo original será copiado ao
    invés do link.

  • Se for usado o comando mv com um link, a modificação será feita no link.

  • Se for usado um comando de visualização (como o cat), o arquivo original
    será visualizado.

Exemplos:

  • ln -s /dev/ttyS1 /dev/modem - Cria o link /dev/modem para o arquivo /dev/
    ttyS1.

  • ln -s /tmp ~/tmp - Cria um link ~/tmp para o diretório /tmp.

du

Mostra o espaço ocupado por arquivos e sub-diretórios do diretório atual.

du [opções]

onde:

opções, -a, --all

    Mostra o espaço ocupado por todos os arquivos.

-b, --bytes

    Mostra o espaço ocupado em bytes.

-c, --total

    Faz uma totalização de todo espaço listado.

-D

    Não conta links simbólicos.

-h, --human

    Mostra o espaço ocupado em formato legível por humanos (Kb, Mb) ao invés de
    usar blocos.

-H

    Como o anterior mas usa 1000 e não 1024 como unidade de cálculo.

-k

    Mostra o espaço ocupado em Kbytes.

-m

    Mostra o espaço ocupado em Mbytes.

-S, --separate-dirs

    Não calcula o espaço ocupado por sub-diretórios.

-x

    Não faz a contagem de diretórios em sistemas de arquivos diferentes do
    atual.

Exemplo: du -h, du -hc.

find

Procura por arquivos/diretórios no disco. Ofind pode procurar arquivos através
de sua data de modificação, tamanho, etc através do uso de opções. find, ao
contrário de outros programas, usa opções longas através de um "-".

find [diretório] [opções/expressão]

Onde:

diretório

    Inicia a procura neste diretório, percorrendo seu sub-diretórios.

opções/expressão, -name [expressão]

    Procura pelo nome [expressão] nos nomes de arquivos e diretórios
    processados.

-depth

    Processa os sub-diretórios primeiro antes de processar os arquivos do
    diretório principal.

-maxdepth [num]

    Faz a procura até [num] sub-diretórios dentro do diretório que está sendo
    pesquisado.

-mindepth [num]

    Não faz nenhuma procura em diretórios menores que [num] níveis.

-mount, -xdev

    Não faz a pesquisa em sistemas de arquivos diferentes daquele de onde o
    comando find foi executado.

-amin [num]

    Procura por arquivos que foram acessados [num] minutos atrás. Caso for
    antecedido por "-", procura por arquivos que foram acessados entre [num]
    minutos atrás até agora.

-atime [num]

    Procura por arquivos que foram acessados [num] dias atrás. Caso for
    antecedido por "-", procura por arquivos que foram acessados entre [num]
    dias atrás e a data atual.

-gid [num]

    Procura por arquivos que possuam a identificação numérica do grupo igual a
    [num].

-group [nome]

    Procura por arquivos que possuam a identificação de nome do grupo igual a
    [nome].

-uid [num]

    Procura por arquivos que possuam a identificação numérica do usuário igual
    a [num].

-user [nome]

    Procura por arquivos que possuam a identificação de nome do usuário igual a
    [nome].

-inum [num]

    Procura por arquivos que estão localizados no inodo [num].

-links [num]

    Procura por arquivos que possuem [num] links como referência.

-mmin [num]

    Procura por arquivos que tiveram seu conteúdo modificado há [num] minutos.
    Caso for antecedido por "-", procura por arquivos que tiveram seu conteúdo
    modificado entre [num] minutos atrás até agora.

-mtime [num]

    Procura por arquivos que tiveram seu conteúdo modificado há [num] dias.
    Caso for antecedido por "-", procura por arquivos que tiveram seu conteúdo
    modificado entre [num] dias atrás até agora.

-ctime [num]

    Procura por arquivos que teve seu status modificado há [num] dias. Caso for
    antecedido por "-", procura por arquivos que tiveram seu conteúdo
    modificado entre [num] dias atrás até agora.

-nouser

    Procura por arquivos que não correspondam a identificação do usuário atual.

-nogroup

    Procura por arquivos que não correspondam a identificação do grupo do
    usuário atual.

-perm [modo]

    Procura por arquivos que possuam os modos de permissão [modo]. Os [modo] de
    permissão pode ser numérico (octal) ou literal.

-used [num]

    O arquivo foi acessado [num] vezes antes de ter seu status modificado.

-size [num]

    Procura por arquivos que tiverem o tamanho [num]. [num] pode ser antecedido
    de "+" ou "-" para especificar um arquivo maior ou menor que [num]. A opção
    -size pode ser seguida de:

      □ b - Especifica o tamanho em blocos de 512 bytes. É o padrão caso [num]
        não seja acompanhado de nenhuma letra.

      □ c - Especifica o tamanho em bytes.

      □ k - Especifica o tamanho em Kbytes.

-type [tipo]

    Procura por arquivos do [tipo] especificado. Os seguintes tipos são
    aceitos:

      □ b - bloco

      □ c - caracter

      □ d - diretório

      □ p - pipe

      □ f - arquivo regular

      □ l - link simbólico

      □ s - sockete

A maior parte dos argumentos numéricos podem ser precedidos por "+" ou "-".
Para detalhes sobre outras opções e argumentos, consulte a página de manual.

Exemplo:

  • find / -name grep - Procura no diretório raíz e sub-diretórios um arquivo/
    diretório chamado grep.

  • find / -name grep -maxdepth 3 - Procura no diretório raíz e sub-diretórios
    até o 3o. nível, um arquivo/diretório chamado grep.

  • find . -size +1000k - Procura no diretório atual e sub-diretórios um
    arquivo com tamanho maior que 1000 kbytes (1Mbyte).

  • find / -mmin 10 - Procura no diretório raíz e sub-diretórios um arquivo que
    foi modificado há 10 minutos atrás.

  • find / -links 4 - Procura no diretório raíz e sub-diretórios, todos os
    arquivos que possuem 4 links como referência.

free

Mostra detalhes sobre a utilização da memória RAM do sistema.

free [opções]

Onde:

opções, -b

    Mostra o resultado em bytes.

-k

    Mostra o resultado em Kbytes.

-m

    Mostra o resultado em Mbytes.

-o

    Oculta a linha de buffers.

-t

    Mostra uma linha contendo o total.

-s [num]

    Mostra a utilização da memória a cada [num] segundos.

O free é uma interface ao arquivo /proc/meminfo.

grep

Procura por um texto dentro de um arquivo(s) ou no dispositivo de entrada
padrão.

grep [expressão] [arquivo] [opções]

Onde:

expressão

    palavra ou frase que será procurada no texto. Se tiver mais de 2 palavras
    você deve identifica-la com aspas "" caso contrário o grep assumirá que a
    segunda palavra é o arquivo!

arquivo

    Arquivo onde será feita a procura.

opções, -A [número]

    Mostra o [número] de linhas após a linha encontrada pelo grep.

-B [número]

    Mostra o [número] de linhas antes da linha encontrada pelo grep.

-f [arquivo]

    Especifica que o texto que será localizado, esta no arquivo [arquivo].

-h, --no-filename

    Não mostra os nomes dos arquivos durante a procura.

-i, --ignore-case

    Ignora diferença entre maiúsculas e minúsculas no texto procurado e
    arquivo.

-n, --line-number

    Mostra o nome de cada linha encontrada pelo grep.

-E

    Ativa o uso de expressões regulares.

-U, --binary

    Trata o arquivo que será procurado como binário.

Se não for especificado o nome de um arquivo ou se for usado um hífen "-", grep
procurará a string no dispositivo de entrada padrão. O grep faz sua pesquisa em
arquivos texto. Use o comando zgrep para pesquisar diretamente em arquivos
compactados com gzip, os comandos e opções são as mesmas.

Exemplos: grep "capitulo" texto.txt, ps ax|grep inetd, grep "capitulo"
texto.txt -A 2 -B 2.

head

Mostra as linhas iniciais de um arquivo texto.

head [opções]

Onde:

-c [numero]

    Mostra o [numero] de bytes do inicio do arquivo.

-n [numero]

    Mostra o [numero] de linhas do inicio do arquivo. Caso não for
    especificado, o head mostra as 10 primeiras linhas.

Exemplos: head teste.txt, head -n 20 teste.txt.

nl

Mostra o número de linhas junto com o conteúdo de um arquivo.

nl [opções] [arquivo]

Onde:

opções, -f [opc]

    Faz a filtragem de saída de acordo com [opc]:

    a

        Numera todas as linhas.

    t

        Não numera linhas vazias.

    n

        Numera linhas vazias.

    texto

        Numera somente linhas que contém o [texto].

-v [num]

    Número inicial (o padrão é 1).

-i [num]

    Número de linhas adicionadas a cada linha do arquivo (o padrão é 1).

Exemplos: nl /etc/passwd, nl -i 2 /etc/passwd.

more

Permite fazer a paginação de arquivos ou da entrada padrão. O comando more pode
ser usado como comando para leitura de arquivos que ocupem mais de uma tela.
Quando toda a tela é ocupada, o more efetua uma pausa e permite que você
pressione Enter ou espaço para continuar avançando no arquivo sendo
visualizado. Para sair do more pressione q.

more [arquivo]

Onde: arquivo É o arquivo que será paginado.

Para visualizar diretamente arquivos texto compactados pelo gzip .gz use o
comando zmore.

Exemplos: more /etc/passwd, cat /etc/passwd|more.

less

Permite fazer a paginação de arquivos ou da entrada padrão. O comando less pode
ser usado como comando para leitura de arquivos que ocupem mais de uma tela.
Quando toda a tela é ocupada, o less efetua uma pausa (semelhante ao more) e
permite que você pressione Seta para Cima e Seta para Baixo ou PgUP/PgDown para
fazer o rolamento da página. Para sair do less pressione q.

less [arquivo]

Onde: arquivo É o arquivo que será paginado.

Para visualizar diretamente arquivos texto compactados pelo utilitário gzip
(arquivos .gz), use o comando zless.

Exemplos: less /etc/passwd, cat /etc/passwd|less

sort

Organiza as linhas de um arquivo texto ou da entrada padrão. A organização é
feita por linhas e as linhas são divididas em campos que é a ordem que as
palavras aparecem na linha separadas por um delimitador (normalmente um
espaço).

sort [opções] [arquivo]

Onde:

arquivo

    É o nome do arquivo que será organizado. Caso não for especificado, será
    usado o dispositivo de entrada padrão (normalmente o teclado ou um "|").

opções, -b

    Ignora linhas em branco.

-d

    Somente usa letras, dígitos e espaços durante a organização.

-f

    Ignora a diferença entre maiúsculas e minúsculas.

-r

    Inverte o resultado da comparação.

-n

    Caso estiver organizando um campo que contém números, os números serão
    organizados na ordem aritmética. Por exemplo, se você tiver um arquivo com
    os números

    100
    10
    50

    Usando a opção -n, o arquivo será organizado desta maneira:

    10
    50
    100

    Caso esta opção não for usada com o sort, ele organizará como uma listagem
    alfabética (que começam de a até z e do 0 até 9)

    10
    100
    50

-c

    Verifica se o arquivo já esta organizado. Caso não estiver, retorna a
    mensagem "disorder on arquivo".

-o arquivo

    Grava a saída do comando sort no arquivo.

-m arquivo1 arquivo2

    Combina o conteúdo de arquivo1 e arquivo2 gerando um único arquivo. Os dois
    arquivos precisam estar ordenados antes de se utilizar esta opção.

-i

    Ignora os caracteres fora da faixa octal ASCII 040-0176 durante a
    organização.

-t caracter

    Usa caracter como delimitador durante a organização de linhas. Por padrão é
    usado um espaço em branco como delimitador de caracteres.

+num1 -num2

    Especifica qual o campo dentro na linha que será usado na organização. O(s)
    campo(s) usado(s) para organização estará entre +num1 e +num2. O
    delimitador padrão utilizado é um espaço em branco (use a opção -t para
    especificar outro). A contagem é iniciada em "0". Caso não for
    especificada, a organização é feita no primeiro campo. Caso -num2 não seja
    especificado, a organização será feita usando a coluna +num1 até o fim da
    linha.

-k num1, num2

    Esta é uma alternativa ao método acima para especificar as chaves de
    organização. O uso é idêntico, mas o delimitador é iniciado em "1".

Abaixo, exemplos de uso do comando sort:

  • sort texto.txt - Organiza o arquivo texto.txt em ordem crescente.

  • sort texto.txt -r - Organiza o conteúdo do arquivo texto.txt em ordem
    decrescente.

  • cat texto.txt|sort - Faz a mesma coisa que o primeiro exemplo, só que neste
    caso a saída do comando cat é redirecionado a entrada padrão do comando 
    sort.

  • sort -f texto.txt - Ignora diferenças entre letras maiúsculas e minúsculas
    durante a organização.

  • sort +1 -3 texto.txt - Organiza o arquivo texto.txt usando como referência
    a segunda até a quarta palavra (segundo ao quarto campo) que constam
    naquela linha.

  • sort -t : +2 -3 passwd - Organiza o arquivo passwd usando como referência a
    terceira até a quarta palavra (terceiro ao quarto campo). Note que a opção
    -t especifica o caracter ":" como delimitador de campos ao invés do espaço.
    Neste caso, o que estiver após ":" será considerado o próximo campo.

tail

Mostra as linhas finais de um arquivo texto.

tail [opções]

Onde:

-c [numero]

    Mostra o [numero] de bytes do final do arquivo.

-n [numero]

    Mostra o [numero] de linhas do final do arquivo.

-f

    Mostra continuamente linhas adicionadas no final do arquivo.

Exemplos: tail teste.txt, tail -n 20 teste.txt.

time

Mede o tempo gasto para executar um processo (programa).

time [comando]

Onde: comando é o comando/programa que deseja medir o tempo gasto para ser
concluído.

Exemplo: time ls, time find / -name crontab.

touch

Muda a data e hora que um arquivo foi criado. Também pode ser usado para criar
arquivos vazios. Caso o touch seja usado com arquivos que não existam, por
padrão ele criará estes arquivos.

touch [opções] [arquivos]

Onde:

arquivos

    Arquivos que terão sua data/hora modificados.

opções, -t MMDDhhmm[ANO.segundos]

    Usa Mês (MM), Dias (DD), Horas (hh), minutos (mm) e opcionalmente o ANO e
    segundos para modificação do(s) arquivos ao invés da data e hora atual.

-a, --time=atime

    Faz o touch mudar somente a data e hora do acesso ao arquivo.

-c, --no-create

    Não cria arquivos vazios, caso os arquivos não existam.

-m, --time=mtime

    Faz o touch mudar somente a data e hora da modificação.

-r [arquivo]

    Usa as horas no [arquivo] como referência ao invés da hora atual.

Exemplos:

  • touch teste - Cria o arquivo teste caso ele não existir.

  • touch -t 10011230 teste - Altera da data e hora do arquivo para 01/10 e
    12:30.

  • touch -t 120112301999.30 teste - Altera da data, hora ano, e segundos do
    arquivo para 01/12/1999 e 12:30:30.

  • touch -t 12011200 * - Altera a data e hora do arquivo para 01/12 e 12:00.

uptime

Mostra o tempo de execução do sistema desde que o computador foi ligado.

uptime

dmesg

Mostra as mensagens de inicialização do kernel. São mostradas as mensagens da
última inicialização do sistema.

dmesg | less

mesg

Permite ou não o recebimentos de requisições de talk de outros usuários.

mesg [y/n]

Onde: y permite que você receba "talks" de outros usuários.

Digite mesg para saber se você pode ou não receber "talks" de outros usuários.
Caso a resposta seja "n" você poderá enviar um talk para alguém mas o seu
sistema se recusará em receber talks de outras pessoas.

É interessante colocar o comando mesg y em seu arquivo de inicialização
.bash_profile para permitir o recebimento de "talks" toda vez que entrar no
sistema.

Para detalhes sobre como se comunicar com outros usuários, veja o comando
“talk”.

echo

Mostra mensagens. Este comando é útil na construção de scripts para mostrar
mensagens na tela para o usuário acompanhar sua execução.

echo [mensagem]

A opção -n pode ser usada para que não ocorra o salto de linha após a mensagem
ser mostrada.

su

Permite o usuário mudar sua identidade para outro usuário sem fazer o logout.
Útil para executar um programa ou comando como root sem ter que abandonar a
seção atual.

su [usuário] [-c comando]

Onde: usuário é o nome do usuário que deseja usar para acessar o sistema. Se
não digitado, é assumido o usuário root. Caso seja especificado -c comando,
executa o comando sob o usuário especificado.

Será pedida a senha do superusuário para autenticação. Digite exit quando
desejar retornar a identificação de usuário anterior.

sync

Grava os dados do cache de disco na memória RAM para todos os discos rígidos e
flexíveis do sistema. O cache um mecanismo de aceleração que permite que um
arquivo seja armazenado na memória ao invés de ser imediatamente gravado no
disco, quando o sistema estiver ocioso, o arquivo é gravado para o disco. O GNU
/Linux procura utilizar toda memória RAM disponível para o cache de programas
acelerando seu desempenho de leitura/gravação.

sync

O uso do sync é útil em disquetes quando gravamos um programa e precisamos que
os dados sejam gravados imediatamente para retirar o disquete da unidade. Mas o
método recomendado é especificar a opção sync durante a montagem da unidade de
disquetes (para detalhes veja “fstab”.

uname

Retorna o nome e versão do kernel atual.

uname

reboot

Reinicia o computador.

shutdown

Desliga/reinicia o computador imediatamente ou após determinado tempo
(programável) de forma segura. Todos os usuários do sistema são avisados que o
computador será desligado . Este comando somente pode ser executado pelo
usuário root ou quando é usada a opção -a pelos usuários cadastrados no arquivo
/etc/shutdown.allow que estejam logados no console virtual do sistema.

shutdown [opções] [hora] [mensagem]

hora

    Momento que o computador será desligado. Você pode usar HH:MM para definir
    a hora e minuto, MM para definir minutos, +SS para definir após quantos
    segundos, ou now para imediatamente (equivalente a +0).

    O shutdown criará o arquivo /etc/nologin para não permitir que novos
    usuários façam login no sistema (com excessão do root). Este arquivo é
    removido caso a execução do shutdown seja cancelada (opção -c) ou após o
    sistema ser reiniciado.

mensagem

    Mensagem que será mostrada a todos os usuários alertando sobre o reinicio/
    desligamento do sistema.

opções, -h

    Inicia o processo para desligamento do computador.

-r

    Reinicia o sistema

-c

    Cancela a execução do shutdown. Você pode acrescentar uma mensagem avisando
    aos usuários sobre o fato.

-a

    Permite que os nomes de usuários contidos no arquivo /etc/shutdown.allow
    possam utilizar o shutdown para reinicializar/desligar o sistema. Deve ser
    colocado um nome de usuário por linha. O limite máximo de usuários neste
    arquivo é de 32.

    Este arquivo é útil quando o shutdown é usado para controlar o
    pressionamento das teclas CTRL+ALT+DEL no /etc/inittab.

-k

    Simula o desligamento/reinicio do sistema, enviando mensagem aos usuários.

-f

    Não executa a checagem do sistema de arquivos durante a inicialização do
    sistema. Este processo é feito gravando-se um arquivo /fastboot que é
    interpretado pelos scripts responsáveis pela execução do fsck durante a
    inicialização do sistema.

-F

    Força a checagem do sistema de arquivos durante a inicialização. É gravado
    um arquivo chamado /forcefsck que é interpretado pelos scripts responsáveis
    pela execução do fsck durante a inicialização do sistema.

-n

    Faz com que o shutdown ignore a execução do init fechando todos os
    processos.

-t [num]

    Faz com que o shutdown envie um sinal de término aos processos e aguarde
    [num] segundos antes de enviar o sinal KILL.

O shutdown envia uma mensagem a todos os usuários do sistema alertando sobre o
desligamento durante os 15 minutos restantes e assim permite que finalizem suas
tarefas. Após isto, o shutdown muda o nível de execução através do comando init
para 0 (desligamento), 1 (modo monousuário), 6 (reinicialização). É recomendado
utilizar o símbolo "&" no final da linha de comando para que o shutdown seja
executado em segundo plano.

Quando restarem apenas 5 minutos para o reinicio/desligamento do sistema, o
programa login será desativado, impedindo a entrada de novos usuários no
sistema.

O programa shutdown pode ser chamado pelo init através do pressionamento da
combinação das teclas de reinicialização CTRL+ALT+DEL alterando-se o arquivo /
etc/inittab. Isto permite que somente os usuários autorizados (ou o root)
possam reinicializar o sistema.

Exemplos:

  • "shutdown -h now" - Desligar o computador imediatamente.

  • "shutdown -r now" - Reinicia o computador imediatamente.

  • "shutdown 19:00 A manutenção do servidor será iniciada às 19:00" - Faz o
    computador entrar em modo monousuário (init 1) às 19:00 enviando a mensagem
    A manutenção do servidor será iniciada às 19:00 a todos os usuários
    conectados ao sistema.

  • "shutdown -r 15:00 O sistema será reiniciado às 15:00 horas" - Faz o
    computador ser reiniciado (init 6) às 15:00 horas enviando a mensagem O
    sistema será reiniciado às 15:00 horas a todos os usuários conectados ao
    sistema.

  • shutdown -r 20 - Faz o sistema ser reiniciado após 20 minutos.

  • shutdown -c - Cancela a execução do shutdown.

  • shutdown -t 30 -r 20 - Reinicia o sistema após 20 minutos, espera 30
    segundos após o sinal de término para enviar o sinal KILL a todos os
    programas abertos.

wc

Conta o número de palavras, bytes e linhas em um arquivo ou entrada padrão. Se
as opções forem omitidas, o wc mostra a quantidade de linhas, palavras, e
bytes.

wc [opções] [arquivo]

Onde:

arquivo

    Arquivo que será verificado pelo comando wc.

opções, -c, --bytes

    Mostra os bytes do arquivo.

-w, --words

    Mostra a quantidade de palavras do arquivo.

-l, --lines

    Mostra a quantidade de linhas do arquivo.

A ordem da listagem dos parâmetros é única, e modificando a posição das opções
não modifica a ordem que os parâmetros são listados.

Exemplo:

  • wc /etc/passwd - Mostra a quantidade de linhas, palavras e letras (bytes)
    no arquivo /etc/passwd.

  • wc -w /etc/passwd - Mostra a quantidade de palavras.

  • wc -l /etc/passwd - Mostra a quantidade de linhas.

  • wc -l -w /etc/passwd - Mostra a quantidade de linhas e palavras no arquivo
    /etc/passwd.

seq

Imprime uma seqüência de números começando em [primeiro] e terminando em
[último], utilizando [incremento] para avançar.

seq [opções] [primeiro] [incremento] [último]

Onde:

primeiro

    Número inicial da seqüência.

incremento

    Número utilizado para avançar na seqüência.

último

    Número final da seqüência.

opções, -f, --format=[formato]

    Formato de saída dos números da seqüência. Utilize o estilo do printf para
    ponto flutuante (valor padrão: %g).

-s, --separator=[string]

    Usa [string] para separar a seqüência de números (valor padrão: \n).

-w, --equal-width

    Insere zeros na frente dos números mantendo a seqüência alinhada.

Observações:

  • Se [primeiro] ou [incremento] forem omitidos, o valor padrão 1 será
    utilizado.

  • Os números recebidos são interpretados como números em ponto flutuante.

  • [incremento] deve ser positivo se [primeiro] for menor do que o último, e
    negativo caso contrário.

  • Quando utilizarmos a opção --format, o argumento deve ser exatamente %e, %f
    ou %g.

Exemplos: seq 0 2 10, seq -w 0 10, seq -f%f 0 10, seq -s", " 0 10

chattr

Modifica atributos de arquivos/diretórios. Não confunda atributos de arquivo
com permissões de acesso (Capítulo 11, Permissões de acesso a arquivos e
diretórios), os atributos são diferentes e definem outras características
especiais para os arquivos/diretórios especificados.

chattr [opções] [atributos] [arquivos/diretórios]

Onde:

arquivos/diretórios

    Arquivos/Diretórios que terão os atributos modificados. Podem ser usados
    coringas

opções, -R

    Modifica atributos em subdiretórios

-V

    Mostra detalhes sobre a modificação de atributos.

atributos

    Os atributos de arquivos/diretórios podem ser especificados da seguinte
    maneira:

      □ + - Adiciona o atributo

      □ - - Remove o atributo

      □ = - Define o atributo exatamente como especificado

    Os atributos são os seguintes:

      □ A - Não modifica a hora de acesso de arquivos. Poder aumentar
        consideravelmente a performance em Notebooks devido a diminuição de I/O
        no disco rígido. Quando especificada em diretórios, faz com que todos
        os arquivos e subdiretórios residentes nele não tenham a hora de acesso
        modificada.

        Este atributo funciona apenas em kernels 2.2 e superiores

      □ a - Append-Only - Arquivos com este atributo podem somente ser gravados
        em modo incrementais (o conteúdo poderá somente ser adicionado ao final
        do arquivo). Eles não poderão ser removidos, renomeados e novos links
        não poderão ser criados para estes arquivos.

        Em diretórios faz com que os arquivos sejam apenas adicionados. Somente
        o root pode especificar ou retirar este atributo.

      □ c - Permite compactação nos arquivos especificados de forma
        transparente para o usuário. Durante a leitura, o kernel retorna dados
        descompactados e durante a gravação os dados são compactados e gravados
        no disco.

        Este atributo ainda não foi totalmente implementado no código atual do
        kernel.

      □ d - Este atributo não é usado pelo kernel, mas faz com que o programa 
        dump evitar backup dos arquivos marcados com este atributo.

      □ i - Imutável - Arquivos imutáveis não podem ser modificados, os dados
        também não podem ser gravados para estes arquivos, não podem ser
        removidos, renomeados. Até mesmo o usuário root não poderá modificar
        estes arquivos.

        Em diretórios, faz com que arquivos não possam ser adicionados ou
        apagados. Somente o usuário root pode especificar ou retirar este
        atributo.

      □ s - O arquivo especificado é marcado como "apagamento seguro"; quando o
        arquivo é apagado, seus blocos são zerados e gravados de volta no disco
        (eliminando qualquer possibilidade de recuperação).

      □ S - Faz a gravação imediatamente para o arquivo especificado. É como
        especificar a opção "sync" na montagem do sistema de arquivos ext2, mas
        afeta somente os arquivos especificados. Não tem efeito em diretórios.

      □ u - O arquivo especificado é marcado como recuperável. Quando o arquivo
        é apagado, seu conteúdo é salvo para permitir futura recuperação.

        Este atributo ainda não foi implementado totalmente no código atual do
        kernel.

Os atributos de arquivos/diretórios são visualizados através do utilitário 
lsattr. Existem patches para os kernels da série 2.2 que adicionam o suporte
experimental aos atributos "c" e "u".

Exemplos:

  • chattr +AacdiSsu teste.txt - Adiciona todos os atributos

  • chattr =ASs teste.txt - Define os atributos para "ASs"

  • chattr +i -A teste.txt - Retira o atributo "A" e adiciona "i"

  • chattr = teste.txt - Retira todos os atributos

lsattr

Lista atributos de um arquivo/diretório. Os atributos podem ser modificados
através do comando chattr.

lsattr [opções] [arquivos/diretórios]

Onde:

arquivos/diretórios

    Arquivos/diretórios que deseja listar os atributos. Podem ser usados
    coringas.

opções, -a

    Lista todos os arquivos, incluindo ocultos (iniciando com um ".").

-d

    Lista os atributos de diretórios ao invés de listar os arquivos que ele
    contém.

-R

    Faz a listagem em diretórios e subdiretórios.

-v

    Mostra versões dos arquivos.

Caso seja especificado sem parâmetros, o lsattr listará os atributos de todos
os arquivos e diretórios do diretório atual. O lsattr mostrará mensagens de
erro caso seja usado em um diretório de pontos de montagem ou arquivos que não
sejam ext2.

Exemplo: lsattr -d, lsattr -R, lsattr -R *.txt

cut

Mostra seções de cada linha do arquivo dependendo das opções passadas ao
programa.

cut [opções] [arquivo]

Onde:

arquivo

    Arquivo que será verificado pelo comando cut.

opções, -b, --bytes [bytes]

    Mostra somente a lista de [bytes] do arquivo.

-c, --characters [numero]

    Mostra somente o [número] de caracteres no arquivo. É semelhante a opção
    "-b" mas tabs e espaços são tratados como qualquer caracter.

-f, --field [campos]

    Mostra somente a lista de [campos].

-d, --delimite [delimitador]

    Para uso com a opção -f, os campos são separados pelo primeiro caracter em
    [delimitador] ao invés de tabulações.

-s

    Para uso com a opção -f, somente mostra linhas que contém o caracter
    separador de campos.

Devem ser especificadas opções para o funcionamento deste comando. Os bytes,
campos e delimitadores podem ser especificados através de intervalos de
caracteres (usando a-z), através de vírgulas (a,b,d) ou da combinação entre
eles.

  • cut -b 1,3 /etc/passwd - Pega a primeira e terceira letra (byte) de cada
    linha do arquivo /etc/passwd

  • cut -b 1,3-10 /etc/passwd - Pega a primeira letra (byte) e terceira a
    décima letra de cada linha do arquivo /etc/passwd.

  • cut -c 1,3-10 /etc/passwd - Pega o primeiro caracter e terceiro ao décimo
    caracter de cada linha do arquivo /etc/passwd.

cmp

Compara dois arquivos de qualquer tipo (binário ou texto). Os dois arquivos
especificados serão comparado e caso exista diferença entre eles, é mostrado o
número da linha e byte onde ocorreu a primeira diferença na saída padrão (tela)
e o programa retorna o código de saída 1.

cmp [arquivo1] [arquivo2] [opções]

Opções:

arquivo1/arquivo2

    Arquivos que serão comparados.

opções, -l

    Mostra o número do byte (hexadecimal) e valores diferentes de bytes (octal)
    para cada diferença.

-s

    Não mostra nenhuma diferença, só retorna o código de saída do programa.

Use o comando zcmp para comparar diretamente arquivos binários/texto
compactados com gzip.

Exemplo: cmp teste.txt teste1.txt.

dirname

Obtém o nome do diretório através do caminho passado ao programa.

dirname [diretório/arquivo]

dirname /usr/bin/dirname, dirname /tmp/*.

diff

Compara dois arquivos e mostra as diferenças entre eles. O comando diff é usado
somente para a comparação de arquivos em formato texto. As diferenças
encontradas podem ser redirecionadas para um arquivo que poderá ser usado pelo
comando patch para aplicar as alterações em um arquivo que não contém as
diferenças. Isto é útil para grandes textos porque é possível copiar somente as
modificações (geradas através do diff, que são muito pequenas) e aplicar no
arquivo para atualiza-lo (através do patch) ao invés de copiar a nova versão.
Este é um sistema de atualização muito usado na atualização dos código fonte do
kernel do Linux.

diff [diretório1/arquivo1] [diretório2/arquivo2] [opções]

Opções:

diretório1/arquivo1 diretório2/arquivo2

    Arquivos /diretórios que serão comparados. Normalmente é usado como
    primeiro arquivo/diretório o mais antigo e o mais novo como segundo.

opções, -lines [num]

    Gera a diferença com [num] linhas de contexto. Por padrão o diff gera um
    arquivo com 2 linhas que é o mínimo necessário para o correto funcionamento
    do patch.

-a

    Compara os dois arquivos como arquivos texto.

-b

    Ignora espaços em branco como diferenças.

-B

    Ignora linhas em branco inseridas ou apagadas nos arquivos.

-i

    Ignora diferenças entre maiúsculas e minúsculas nos arquivos.

-H

    Usa análise heurística para verificar os arquivos.

-N

    Em uma comparação de diretórios, se o arquivo apenas existe em um
    diretório, trata-o como presente mas vazio no outro diretório.

-P

    Em uma comparação de diretórios, se o arquivos apenas existe no segundo
    diretório, trata-o como presente mas vazio no primeiro diretório.

-q

    Mostra somente se os dois arquivos possuem diferenças. Não mostra as
    diferenças entre eles.

-r

    Compara diretórios e sub-diretórios existentes.

-S [nome]

    Inicia a comparação de diretórios pelo arquivo [nome]. É útil quando
    cancelamos uma comparação.

-t

    Aumenta a tabulação das diferenças encontradas.

-u

    Usa o formato de comparação unificado.

Use o comando zdiff para comparar diretamente arquivos compactados pelo
utilitário gzip

Use o comando sdiff para visualizar as linhas diferentes entre os dois arquivos
em formato texto simples.

Exemplo:

  • diff texto.txt texto1.txt - Compara o arquivo texto.txt com texto1.txt e
    exibe suas diferenças na tela.

  • diff -Bu texto.txt texto1.txt - Compara o arquivo texto.txt com texto1.txt
    ignorando linhas em branco diferentes entre os dois arquivos e usando o
    formato unificado.

  • diff texto.txt texto1.txt >texto.diff - Compara o arquivo texto.txt com
    texto1.txt e gera um arquivo chamado texto.diff contendo a diferença entre
    eles. Este arquivo poderá ser usado pelo patch para aplicar as diferenças
    existente entre os dois no arquivo texto.txt.

  • diff -r /usr/src/linux-2.2.13 /usr/src/linux-2.2.14 >patch-2.2.14.diff -
    Compara o diretório e sub-diretórios linux-2.2.13 e linux-2.2.14 e grava as
    diferenças entre eles no arquivo patch-2.2.14.diff.

pr

Página arquivos texto ou a entrada padrão para impressão. Este comando faz a
paginação de um arquivo texto e opcionalmente ajusta o número de colunas e
mostra o resultado na saída padrão.

pr [opções] [arquivo]

Onde:

arquivo

    Arquivo que será paginado para impressão.

opções, +[NUM]

    Inicia a numeração de páginas na página [PAGINA]

-[NUM]

    Mostra a saída com [NUM] colunas.

-c

    Imprime o caracter CTRL como "^" na saída padrão.

-F, -f

    Usa avanço de página ao invés de linhas em branco para separar páginas.

-e[caracter][tamanho]

    Usa o caracter [caracter] como tabulação (o padrão é tab) e o espaço da
    tabulação [tamanho].

-h [nome]

    Mostra [nome] ao invés do nome do arquivo no cabeçalho.

-l [num]

    Define o número máximo de linhas por página para [num].

-m

    Imprime vários arquivos em paralelo, um por coluna.

-r

    Oculta mensagens de erro de abertura de arquivos.

-w [num]

    Ajusta a largura da página para [num] colunas (o padrão é 72).

Exemplo: pr -l 50 -h "Teste do comando pr" teste.txt.

patch

Atualiza arquivos texto através das diferenças geradas pelo comando diff.

patch [opções] [arquivo.diff] ou patch [opções] < [arquivo.diff]

Onde:

arquivo.diff

    Arquivo contendo as diferenças geradas pelo comando diff.

opções, -p [num]

    Nível do diretório onde o patch será aplicado, se igual a 0, o patch assume
    que os arquivos que serão atualizados estão no diretório atual, se 1,
    assume que os arquivos que serão atualizado estão no diretório acima (..),
    se 2, 2 diretórios acima ...

-b

    Cria cópias de segurança dos arquivos originais ao aplica o patch.

-binary

    Lê e grava arquivo usando modo binário.

-d [dir]

    Muda para o diretório [dir] antes de aplica o patch.

-E

    Remove arquivos vazios após a aplicação do patch.

-n

    Interpreta o arquivo de patch como um .diff normal.

-N

    Não desfaz patches já aplicados.

-s

    Não mostra mensagens de erro.

-u

    Interpreta o patch em formato unificado.

As diferenças são aplicadas em arquivos originais gerados pelo comando diff. É
importante entender os comandos patch e diff pois são comandos muito utilizados
para desenvolvimento feito por equipes de pessoas.

Exemplo:

  • patch -p0<texto.diff - Aplica as diferenças contidas no arquivo texto.diff
    nos arquivos originais.

  • patch -p0 texto.txt texto.diff - Aplica as diferenças contidas no arquivo
    texto.diff nos arquivos originais. Faz a mesma coisa que o comando
    anterior.

whereis

Localiza o arquivo que contém uma página de manual. A pesquisa é feita
usando-se os caminhos de páginas de manuais configuradas no sistema
(normalmente o arquivo /etc/manpath.config).

whereis [comando]

Exemplo: whereis ls, whereis cd.

which

Mostra a localização de um arquivo executável no sistema. A pesquisa de
arquivos executáveis é feita através do path do sistema. Para maiores detalhes,
veja “path”.

which [comando]

Exemplos: which ls, which shutdown, which which.

zforce

Renomeia extensão de arquivos para .gz. Este comando é útil quando fazemos
downloads de arquivos compactados pelo gzip mas que não estão identificados
pela extensão .gz.

zforce [arquivos]

Quando é usado o zforce verifica se o arquivo especificado foi compactado pelo 
gzip, caso seja, é verificado se já tem a extensão .gz, caso não tiver,
acrescenta a extensão.

gzexe

Cria arquivos compactados gzip auto-extrácteis. Este comando é usado para
compactar arquivos executáveis que se auto-descompactam assim que são
solicitados. É útil para sistemas ou unidades de disco que possuem pouco espaço
disponível. Este comando deve somente ser usado para arquivos executáveis.

gzexe [arquivo]

Onde: arquivo é o arquivo executável que será compactado.

Quando gzexe é executado, uma cópia do arquivo original é gravada com o formato
nome_do_arquivo~.

Exemplo: gzexe /tmp/teste.

znew

Recompacta arquivos do formato compress (.Z) para o formato gzip (.gz). Após a
re-compactação, os arquivos de origem .Z são apagados.

znew [opções] [arquivo]

Onde:

arquivo.Z

    Arquivo compactado pelo compress que será re-compactado para o gzip.

opções, -f

    Substitui o arquivo .gz caso já exista.

-t

    Teste os novos arquivos criados antes de apagar os arquivos .Z.

-v

    Mostra o nome e porcentagem de compactação para cada arquivo processado.

-9

    Usa a máxima compactação.

-P

    Usa pipes durante a conversão para reduzir o espaço ocupado no disco. A
    data e hora do arquivo não é mantida caso esta opção seja usada.

-K

    Mantém o arquivo .Z caso seja menor que o arquivo .gz.

Capítulo 9. Comandos de rede

Índice

who
telnet
finger
ftp
whoami
dnsdomainname
hostname
talk

Este capítulo traz alguns comandos úteis para uso em rede e ambientes
multiusuário.

who

Mostra quem está atualmente conectado no computador. Este comando lista os
nomes de usuários que estão conectados em seu computador, o terminal e data da
conexão.

who [opções]

onde:

opções, -H, --heading

    Mostra o cabeçalho das colunas.

-b, --boot

    Mostra o horário do último boot do sistema.

-d, --dead

    Mostra processos mortos no sistema.

-i, -u, --idle

    Mostra o tempo que o usuário está parado em Horas:Minutos.

-m, i am

    Mostra o nome do computador e usuário associado ao nome. É equivalente a
    digitar who i am ou who am i.

-q, --count

    Mostra o total de usuários conectados aos terminais.

-r, --runlevel

    Mostra o nível de execução atual do sistema e desde quando ele está ativo.

-T, -w, --mesg

    Mostra se o usuário pode receber mensagens via talk (conversação).

      □ + O usuário recebe mensagens via talk

      □ - O usuário não recebe mensagens via talk.

      □ ? Não foi possível determinar o dispositivo de terminal onde o usuário
        está conectado.

telnet

Permite acesso a um computador remoto. É mostrada uma tela de acesso
correspondente ao computador local onde deve ser feita a autenticação do
usuário para entrar no sistema. Muito útil, mas deve ser tomado cuidados ao
disponibilizar este serviço para evitar riscos de segurança e usado o ssh
sempre que possível por ser um protocolo criptografado e com recursos avançados
de segurança.

telnet [opções] [ip/dns] [porta]

onde:

ip/dns

    Endereço IP do computador de destino ou nome DNS.

porta

    Porta onde será feita a conexão. Por padrão, a conexão é feita na porta 23.

opções

    -8

        Requisita uma operação binária de 8 bits. Isto força a operação em modo
        binário para envio e recebimento. Por padrão, telnet não usa 8 bits.

    -a

        Tenta um login automático, enviando o nome do usuário lido da variável
        de ambiente USER.

    -d

        Ativa o modo de debug.

    -r

        Ativa a emulação de rlogin.

    -l [usuário]

        Faz a conexão usando [usuário] como nome de usuário.

Exemplo: telnet 192.168.1.1, telnet 192.168.1.1 23.

finger

Mostra detalhes sobre os usuários de um sistema. Algumas versões do finger
possuem bugs e podem significar um risco para a segurança do sistema. É
recomendado desativar este serviço na máquina local.

finger [usuário] [usuário@host]

Onde:

usuário

    Nome do usuário que deseja obter detalhes do sistema. Se não for digitado o
    nome de usuário, o sistema mostra detalhes de todos os usuários conectados
    no momento.

usuário@host

    Nome do usuário e endereço do computador que deseja obter detalhes.

-l

    Mostra os detalhes de todos os usuários conectados no momento. Entre os
    detalhes, estão incluídos o nome do interpretador de comandos (shell) do
    usuário, diretório home, nome do usuário, endereço, etc. Estes dados são
    lidos de /etc/passwd.

-p

    Não exibe o conteúdo dos arquivos .plan e .project

Se for usado sem parâmetros, mostra os dados de todos os usuários conectados
atualmente ao seu sistema.

Exemplo: finger, finger root.

ftp

Permite a transferência de arquivos do computador remoto/local e vice versa. O
file transfer protocol é o sistema de transmissão de arquivos mais usado na
Internet. É requerida a autenticação do usuário para que seja permitida a
conexão. Muitos servidores ftp disponibilizam acesso anônimo aos usuários, com
acesso restrito.

Uma vez conectado a um servidor ftp, você pode usar a maioria dos comandos do 
GNU/Linux para operá-lo.

ftp [ip/dns]

Abaixo alguns dos comandos mais usados no FTP:

ls

    Lista arquivos do diretório atual.

cd [diretório]

    Entra em um diretório.

get [arquivo]

    Copia um arquivo do servidor ftp para o computador local. O arquivo é
    gravado, por padrão, no diretório onde o programa ftp foi executado.

hash [on/off]

    Por padrão esta opção está desligada. Quando ligada, faz com que o caracter
    "#" seja impresso na tela indicando o progresso do download.

mget [arquivos]

    Semelhante ao get, mas pode copiar diversos arquivos e permite o uso de
    coringas.

send [arquivo]

    Envia um arquivo para o diretório atual do servidor FTP (você precisa de
    uma conta com acesso a gravação para fazer isto).

prompt [on/off]

    Ativa ou desativa a pergunta para a cópia de arquivo. Se estiver como off
    assume sim para qualquer pergunta.

Exemplo: ftp ftp.debian.org.

whoami

Mostra o nome que usou para se conectar ao sistema. É útil quando você usa
várias contas e não sabe com qual nome entrou no sistema :-)

whoami

dnsdomainname

Mostra o nome do domínio de seu sistema.

hostname

Mostra ou muda o nome de seu computador na rede.

talk

Inicia conversa com outro usuário de sistema em uma rede local ou Internet.
Talk é um programa de conversação em tempo real, caracter por caracter.

talk [usuário] [tty]

ou

talk [usuário@host]

Onde:

usuário

    Nome de login do usuário que deseja iniciar a conversação. Este nome pode
    ser obtido com o comando who (veja “who”).

tty

    O nome de terminal onde o usuário está conectado, para iniciar uma conexão
    local.

usuário@host

    Se o usuário que deseja conversar estiver conectado em um computador
    remoto, você deve usar o nome do usuário@hosname do computador.

Após o talk ser iniciado, ele verificará se o usuário pode receber mensagens,
em caso positivo, ele enviará uma mensagem ao usuário dizendo como responder ao
seu pedido de conversa. Veja “who”.

Para poder fazer a rolagem para cima e para baixo no talk, pressione CTRL+P
(Previous - Tela anterior) e CTRL+N (Next - Próxima tela). Você deve ter o
daemon do talk instalado (talkd) para receber requisições de conversa.

Você deve autorizar o recebimento de talks de outros usuários para que eles
possam se comunicar com você. Para detalhes veja o comando “mesg”.

Capítulo 10. Comandos para manipulação de contas

Índice

adduser
addgroup
passwd
gpasswd
newgrp
userdel
groupdel
lastlog
last
sg
Adicionando o usuário a um grupo extra
chfn
id
logname
users
groups

Este capítulo traz comandos usados para manipulação de conta de usuários e
grupos em sistemas GNU/Linux. Entre os assuntos descritos aqui estão adicionar
usuários ao sistema, adicionar grupos, incluir usuários em grupos existentes,
etc.

adduser

Adiciona um usuário ou grupo no sistema. Por padrão, quando um novo usuário é
adicionado, é criado um grupo com o mesmo nome do usuário. Opcionalmente o 
adduser também pode ser usado para adicionar um usuário a um grupo (veja
“Adicionando o usuário a um grupo extra”). Será criado um diretório home com o
nome do usuário (a não ser que o novo usuário criado seja um usuário do
sistema) e este receberá uma identificação. A identificação do usuário (UID)
escolhida será a primeira disponível no sistema especificada de acordo com a
faixa de UIDS de usuários permitidas no arquivo de configuração /etc/
adduser.conf. Este é o arquivo que contém os padrões para a criação de novos
usuários no sistema.

adduser [opções] [usuário/grupo]

Onde:

usuário/grupo

    Nome do novo usuário que será adicionado ao sistema.

opções, -disable-passwd

    Não executa o programa passwd para escolher a senha e somente permite o uso
    da conta após o usuário escolher uma senha.

--force-badname

    Desativa a checagem de senhas ruins durante a adição do novo usuário. Por
    padrão o adduser checa se a senha pode ser facilmente adivinhada.

--group

    Cria um novo grupo ao invés de um novo usuário. A criação de grupos também
    pode ser feita pelo comando addgroup.

-uid [num]

    Cria um novo usuário com a identificação [num] ao invés de procurar o
    próximo UID disponível.

-gid [num]

    Faz com que o usuário seja parte do grupo [gid] ao invés de pertencer a um
    novo grupo que será criado com seu nome. Isto é útil caso deseje permitir
    que grupos de usuários possam ter acesso a arquivos comuns.

    Caso estiver criando um novo grupo com adduser, a identificação do novo
    grupo será [num].

--home [dir]

    Usa o diretório [dir] para a criação do diretório home do usuário ao invés
    de usar o especificado no arquivo de configuração /etc/adduser.conf.

--ingroup [nome]

    Quando adicionar um novo usuário no sistema, coloca o usuário no grupo
    [nome] ao invés de criar um novo grupo.

--quiet

    Não mostra mensagens durante a operação.

--system

    Cria um usuário de sistema ao invés de um usuário normal.

Os dados do usuário são colocados no arquivo /etc/passwd após sua criação e os
dados do grupo são colocados no arquivo /etc/group.

OBSERVAÇÃO: Caso esteja usando senhas ocultas (shadow passwords), as senhas dos
usuários serão colocadas no arquivo /etc/shadow e as senhas dos grupos no
arquivo /etc/gshadow. Isto aumenta mais a segurança do sistema porque somente o
usuário root pode ter acesso a estes arquivos, ao contrário do arquivo /etc/
passwd que possui os dados de usuários e devem ser lidos por todos.

addgroup

Adiciona um novo grupo de usuários no sistema. As opções usadas são as mesmas
do “adduser”.

addgroup [usuário/grupo] [opções]

passwd

Modifica a parametros e senha de usuário. Um usuário somente pode alterar a
senha de sua conta, mas o superusuário (root) pode alterar a senha de qualquer
conta de usuário, inclusive a data de validade da conta, etc. Os donos de
grupos também podem alterar a senha do grupo com este comando.

Os dados da conta do usuário como nome, endereço, telefone, também podem ser
alterados com este comando.

passwd [usuário] [opções]

Onde:

usuário

    Nome do usuário que terá sua senha alterada.

opções, -e

    Força a expiração de senha para a conta especificada.

-k

    Somente altera a senha se a conta estiver expirada.

-x [dias]

    Especifica o número máximo de dias que a senha poderá ser usada. Após
    terminar o prazo, a senha deverá ser modificada.

-i

    Desativa a conta caso o usuário não tenha alterado sua senha após o tempo
    especificado por -x.

-n [dias]

    Especifica o número mínimo de dias para a senha ser alterada. O usuário não
    poderá mudar sua senha até que [dias] sejam atingidos desde a última
    alteração de senha.

-w [num]

    Número de dias antecedentes que o usuário receberá o alerta para mudar sua
    senha. O alerta ocorre [num] dias antes do limite da opção -x, avisando ao
    usuários quantos dias restam para a troca de sua senha.

-l [nome]

    Bloqueia a conta do usuário [nome]. Deve ser usada pelo root. O bloqueio da
    conta é feito acrescentando um caracter a senha para que não confira com a
    senha original.

-u [nome]

    Desbloqueia a conta de um usuário bloqueada com a opção -l.

-S [nome]

    Mostra o status da conta do usuário [nome]. A primeira parte é o nome do
    usuário seguido de L(conta bloqueada), NP(sem senha), ou P (com senha), a
    terceira parte é a data da última modificação da senha, a quarta parte é a
    período mínimo, máximo, alerta e o período de inatividade para a senha.

Procure sempre combinar letras maiúsculas, minúsculas, e números ao escolher
suas senhas. Não é recomendado escolher palavras normais como sua senha pois
podem ser vulneráveis a ataques de dicionários cracker. Outra recomendação é
utilizar senhas ocultas em seu sistema (shadow password).

Você deve ser o dono da conta para poder modificar a senhas. O usuário root
pode modificar/apagar a senha de qualquer usuário.

Exemplo: passwd root.

gpasswd

Modifica parametros e senha de grupo. Um usuário somente pode alterar a senha
de seu grupo, mas o superusuário (root) pode alterar a senha de qualquer grupo
de usuário, inclusive definir o administrador do grupo.

gpasswd [opções] [usuario] [grupo]

Onde:

usuário

    Nome do usuário/grupo que terá sua senha alterada.

opções, -r usuario grupo

    Remove a senha de grupo.

-R usuario grupo

    Desativa o acesso do grupo usando o comando newgrp.

-a usuario grupo

    Adiciona o usuário no grupo especificado.

-d usuario grupo

    Apaga o usuário do gurpo especificado.

-A [usuario] [grupo]

    Define que o [usuario] será o administrador do [grupo].

-M [usuario] [grupo]

    Define os usuários que fazem parte do grupo e suas permissões.

Quando o grupo não possui senha, somente quem faz parte do grupo pode utilizar
o comando new-grp.

Você deve ser o dono da conta para poder modificar a senhas. O usuário root
pode modificar/apagar a senha de qualquer usuário.

Exemplo: gpasswd grupo, gpasswd -a gleydson grupo.

newgrp

Altera a identificação de grupo do usuário. Para retornar a identificação
anterior, digite exit e tecle Enter. Para executar um comando com outra
identificação de grupo de usuário, use o comando “sg”.

newgrp - [grupo]

Onde:

-

    Se usado, inicia um novo ambiente após o uso do comando newgrp (semelhante
    a um novo login no sistema), caso contrário, o ambiente atual do usuário é
    mantido.

grupo

    Nome do grupo ou número do grupo que será incluído.

Quando este comando é usado, é pedida a senha do grupo que deseja acessar. Caso
a senha do grupo esteja incorreta ou não exista senha definida, a execução do
comando é negada. A listagem dos grupos que pertence atualmente pode ser feita
usando o comando “id”.

userdel

Apaga um usuário do sistema. Quando é usado, este comando apaga todos os dados
da conta especificado dos arquivos de contas do sistema.

userdel [-r] [usuário]

Onde:

-r

    Apaga também o diretório HOME do usuário.

OBS: Note que uma conta de usuário não poderá ser removida caso ele estiver no
sistema, pois os programas podem precisar ter acesso aos dados dele (como UID,
GID) no /etc/passwd.

groupdel

Apaga um grupo do sistema. Quando é usado, este comando apaga todos os dados do
grupo especificado dos arquivos de contas do sistema.

groupdel [grupo]

Tenha certeza que não existem arquivos/diretórios criados com o grupo apagado
através do comando find.

OBS: Você não pode remover o grupo primário de um usuário. Remova o usuário
primeiro.

lastlog

Mostra o último login dos usuários cadastrados no sistema. É mostrado o nome
usado no login, o terminal onde ocorreu a conexão e a hora da última conexão.
Estes dados são obtidos através da pesquisa e formatação do arquivo /var/log/
lastlog. Caso o usuário não tenha feito login, é mostrada a mensagem ** Never
logged in **.

lastlog [opções]

Onde:

opções, -t [dias]

    Mostra somente os usuários que se conectaram ao sistema nos últimos [dias].

-b [dias]

    Mostra somente os usuários que se conectaram antes de [dias].

-u [nome]

    Mostra somente detalhes sobre o usuário [nome].

A opção -t substitui a opção -u caso sejam usadas.

last

Mostra uma listagem de entrada e saída de usuários no sistema. São mostrados os
seguintes campos na listagem:

  • Nome do usuário

  • Terminal onde ocorreu a conexão/desconexão

  • O hostname (caso a conexão tenha ocorrido remotamente) ou console (caso
    tenha ocorrido localmente).

  • A data do login/logout, a hora do login/down se estiver fora do sistema/
    still logged in se ainda estiver usando o sistema

  • Tempo (em Horas:Minutos) que esteve conectado ao sistema.

A listagem é mostrada em ordem inversa, ou seja, da data mais atual para a mais
antiga. A listagem feita pelo last é obtida de /var/log/wtmp.

last [opções]

Onde:

opções, -n [num]

    Mostra [num] linhas. Caso não seja usada, todas as linhas são mostradas.

-R

    Não mostra o campo HostName.

-a

    Mostra o hostname na última coluna. Será muito útil se combinada com a
    opção -d.

-d

    Usa o DNS para resolver o IP de sistemas remotos para nomes DNS.

-x

    Mostra as entradas de desligamento do sistema e alterações do nível de
    execução do sistema.

O comando last pode ser seguido de um argumento que será pesquisado como uma
expressão regular durante a listagem.

O comando last usa o arquivo /var/log/wtmp para gerar sua listagem, mas alguns
sistemas podem não possuir este arquivo. O arquivo /var/log/wtmp somente é
usado caso existir. Você pode cria-lo com o comando "echo -n >/var/log/wtmp" ou
touch /var/log/wtmp.

  • last - Mostra a listagem geral

  • last -a - Mostra a listagem geral incluindo o nome da máquina

  • last gleydson - Mostra somente atividades do usuário gleydson

  • last reboot - Mostra as reinicializações do sistema

  • last tty1 - Mostra todas as atividades no tty1

sg

Executa um comando com outra identificação de grupo. A identificação do grupo
de usuário é modificada somente durante a execução do comando. Para alterar a
identificação de grupo durante sua seção shell, use o comando “newgrp”.

sg [-] [grupo] [comando]

Onde:

-

    Se usado, inicia um novo ambiente durante o uso do comando (semelhante a um
    novo login e execução do comando), caso contrário, o ambiente atual do
    usuário é mantido.

grupo

    Nome do grupo que o comando será executado.

comando

    Comando que será executado. O comando será executado pelo bash.

Quando este comando é usado, é pedida a senha do grupo que deseja acessar. Caso
a senha do grupo esteja incorreta ou não exista senha definida, a execução do
comando é negada.

Exemplo: sg root ls /root

Adicionando o usuário a um grupo extra

Para adicionar um usuário em um novo grupo e assim permitir que ele acesse os
arquivos/diretórios que pertencem àquele grupo, você deve estar como root e
editar o arquivo /etc/group com o comando vigr. Este arquivo possui o seguinte
formato:

NomedoGrupo:senha:GID:usuários

Onde:

NomedoGrupo

    É o nome daquele grupo de usuários.

senha

    Senha para ter acesso ao grupo. Caso esteja utilizando senhas ocultas para
    grupos, as senhas estarão em /etc/gshadow.

GID

    Identificação numérica do grupo de usuário.

usuarios

    Lista de usuários que também fazem parte daquele grupo. Caso exista mais de
    um nome de usuário, eles devem estar separados por vírgula.

Deste modo para acrescentar o usuário "joao" ao grupo audio para ter acesso aos
dispositivos de som do Linux, acrescente o nome no final da linha:
"audio:x:100:joao". Pronto, basta digitar logout e entrar novamente com seu
nome e senha, você estará fazendo parte do grupo audio (confira digitando
groups ou id).

Outros nomes de usuários podem ser acrescentados ao grupo audio bastando
separar os nomes com vírgula. Você também pode usar o comando adduser da
seguinte forma para adicionar automaticamente um usuário a um grupo:

adduser joao audio

Isto adicionaria o usuário "joao" ao grupo audio da mesma forma que fazendo-se
a edição manualmente.

chfn

Muda os dados usados pelo comando “finger”.

chfn [usuário] [opções]

Onde:

usuário

    Nome do usuário.

opções, -f [nome]

    Adiciona/altera o nome completo do usuário.

-r [nome]

    Adiciona/altera o número da sala do usuário.

-w [tel]

    Adiciona/altera o telefone de trabalho do usuário.

-h [tel]

    Adiciona/altera o telefone residencial do usuário.

-o [outros]

    Adiciona/altera outros dados do usuário.

Caso o nome que acompanha as opções (como o nome completo) contenha espaços,
use "" para identifica-lo.

Exemplo: chfn -f "Nome do Usuário root" root

id

Mostra a identificação atual do usuário, grupo primário e outros grupos que
pertence.

id [opções] [usuário]

Onde:

usuário

    É o usuário que desejamos ver a identificação, grupos primários e
    complementares.

opções, -g, --group

    Mostra somente a identificação do grupo primário.

-G, --groups

    Mostra a identificação de outros grupos que pertence.

-n, --name

    Mostra o nome do usuário e grupo ao invés da identificação numérica.

-u, --user

    Mostra somente a identificação do usuário (user ID).

-r, --real

    Mostra a identificação real de usuário e grupo, ao invés da efetiva. Esta
    opção deve ser usada junto com uma das opções: -u, -g, ou -G.

Caso não sejam especificadas opções, id mostrará todos os dados do usuário.

Exemplo: id, id --user, id -r -u.

logname

Mostra seu login (username).

logname

users

Mostra os nomes de usuários usando atualmente o sistema. Os nomes de usuários
são mostrados através de espaços sem detalhes adicionais, para ver maiores
detalhes sobre os usuários, veja os comandos “id” e “who”.

users

Os nomes de usuários atualmente conectados ao sistema são obtidos do arquivo /
var/log/wtmp.

groups

Mostra os grupos que o usuário pertence.

groups [usuário]

Exemplo: groups, groups root

Capítulo 11. Permissões de acesso a arquivos e diretórios

Índice

Donos, Grupos e outros usuários
Tipos de Permissões de Acesso
Etapas para acesso a um arquivo/diretório
Exemplos práticos de permissões de acesso

    Exemplo de acesso a um arquivo
    Exemplo de acesso a um diretório

Permissões de Acesso Especiais
A conta root
chmod
chgrp
chown
Modo de permissão octal
umask

As permissões de acesso protegem o sistema de arquivos Linux do acesso indevido
de pessoas ou programas não autorizados.

A permissão de acesso do GNU/Linux também impede que um programa mal
intencionado, por exemplo, apague um arquivo que não deve, envie arquivos
especiais para outra pessoa ou forneça acesso da rede para que outros usuários
invadam o sistema. O sistema GNU/Linux é muito seguro e como qualquer outro
sistema seguro e confiável impede que usuários mal intencionados (ou iniciantes
que foram enganados) instalem programas enviados por terceiros sem saber para
que eles realmente servem e causem danos irreversíveis em seus arquivos, seu
micro ou sua empresa.

Esta seção do guia, de inicio, pode ser um pouco dificil de se entender, então
recomendo ler e ao mesmo tempo prática-la para uma ótima compreensão. Não se
preocupe, também coloquei exemplos para ajuda-lo a entender o sistema de
permissões de acesso do ambiente GNU/Linux.

Donos, Grupos e outros usuários

A idéia básica da segurança no sistema GNU/Linux é definir o acesso aos
arquivos por donos, grupos e outros usuários:

dono

    É a pessoa que criou o arquivo ou o diretório. O nome do dono do arquivo/
    diretório é o mesmo do usuário usado para entrar no sistema GNU/Linux.
    Somente o dono pode modificar as permissões de acesso do arquivo.

    As permissões de acesso do dono de um arquivo somente se aplicam ao dono do
    arquivo/diretório. A identificação do dono também é chamada de user id
    (UID).

    A identificação de usuário ao qual o arquivo pertence é armazenada no
    arquivo /etc/passwd e do grupo no arquivo /etc/group. Estes são arquivos
    textos comuns e podem ser editados em qualquer editor de texto, mas utilize
    preferencialmente os comandos vipw e vigr que executa procedimentos
    adicionais de checagem de uids e grupos após a alteração. Tenha cuidado
    para não modificar o campo que contém a senha do usuário encriptada (que
    pode estar armazenada no arquivo /etc/passwd caso não estiver usando senhas
    ocultas).

grupo

    Permite que vários usuários diferentes tenham acesso a um mesmo arquivo (já
    que somente o dono poderia ter acesso ao arquivo). Cada usuário pode fazer
    parte de um ou mais grupos e então acessar arquivos que pertençam ao mesmo
    grupo que o seu (mesmo que estes arquivos tenham outro dono).

    Por padrão, quando um novo usuário é criado e não especificar nenhum grupo,
    ele pertencerá ao grupo de mesmo nome do seu grupo primário (este
    comportamento é controlado pelo parametro USERGROUPS=yes do arquivo /etc/
    adduser.conf, veja “id”). A identificação do grupo é chamada de GID (group
    id).

    Um usuário pode pertencer a um ou mais grupos. Para detalhes de como
    incluir o usuário em mais grupos veja “Adicionando o usuário a um grupo
    extra”.

outros

    É a categoria de usuários que não são donos ou não pertencem ao grupo do
    arquivo.

Cada um dos tipos acima possuem três tipos básicos de permissões de acesso que
serão vistas na próxima seção.

Tipos de Permissões de Acesso

Quanto aos tipos de permissões que se aplicam ao dono, grupo e outros usuários,
temos 3 permissões básicas:

  • r - Permissão de leitura para arquivos. Caso for um diretório, permite
    listar seu conteúdo (através do comando ls, por exemplo).

  • w - Permissão de gravação para arquivos. Caso for um diretório, permite a
    gravação de arquivos ou outros diretórios dentro dele.

    Para que um arquivo/diretório possa ser apagado, é necessário o acesso a
    gravação.

  • x - Permite executar um arquivo (caso seja um programa executável). Caso
    seja um diretório, permite que seja acessado através do comando cd (veja
    “cd” para detalhes).

As permissões de acesso a um arquivo/diretório podem ser visualizadas com o uso
do comando ls -la. Para maiores detalhes veja “ls”. As 3 letras (rwx) são
agrupadas da seguinte forma:

-rwxr-xr--   gleydson   users  teste

Virou uma bagunça não? Vou explicar cada parte para entender o que quer dizer
as 10 letras acima (da esquerda para a direita):

  • A primeira letra diz qual é o tipo do arquivo. Caso tiver um "d" é um
    diretório, um "l" um link a um arquivo no sistema (veja “ln” para detalhes)
    , um "-" quer dizer que é um arquivo comum, etc.

  • Da segunda a quarta letra (rwx) dizem qual é a permissão de acesso ao dono
    do arquivo. Neste caso gleydson ele tem a permissão de ler (r - read),
    gravar (w - write) e executar (x - execute) o arquivo teste.

  • Da quinta a sétima letra (r-x) diz qual é a permissão de acesso ao grupo do
    arquivo. Neste caso todos os usuários que pertencem ao grupo users tem a
    permissão de ler (r), e também executar (x) o arquivo teste.

  • Da oitava a décima letra (r--) diz qual é a permissão de acesso para os 
    outros usuários. Neste caso todos os usuários que não são donos do arquivo
    teste tem a permissão somente para ler o programa.

Veja o comando “chmod” para detalhes sobre a mudança das permissões de acesso
de arquivos/diretórios.

Etapas para acesso a um arquivo/diretório

O acesso a um arquivo/diretório é feito verificando primeiro se o usuário que
acessará o arquivo é o seu dono, caso seja, as permissões de dono do arquivo
são aplicadas. Caso não seja o dono do arquivo/diretório, é verificado se ele
pertence ao grupo correspondente, caso pertença, as permissões do grupo são
aplicadas. Caso não pertença ao grupo, são verificadas as permissões de acesso
para os outros usuários que não são donos e não pertencem ao grupo
correspondente ao arquivo/diretório.

Após verificar aonde o usuário se encaixa nas permissões de acesso do arquivo
(se ele é o dono, pertence ao grupo, ou outros usuários), é verificado se ele
terá permissão acesso para o que deseja fazer (ler, gravar ou executar o
arquivo), caso não tenha, o acesso é negado, mostrando uma mensagem do tipo:
"Permission denied" (permissão negada).

O que isto que dizer é que mesmo que você seja o dono do arquivo e definir o
acesso do dono (através do comando chmod) como somente leitura (r) mas o acesso
dos outros usuários como leitura e gravação, você somente poderá ler este
arquivo mas os outros usuários poderão ler/grava-lo.

As permissões de acesso (leitura, gravação, execução) para donos, grupos e
outros usuários são independentes, permitindo assim um nível de acesso
diferenciado. Para maiores detalhes veja “Tipos de Permissões de Acesso”.

Lembre-se: Somente o dono pode modificar as permissões de um arquivo/diretório!

Para mais detalhes veja os comandos “chown” e “chgrp”.

Exemplos práticos de permissões de acesso

Abaixo dois exemplos práticos de permissão de acesso: “Exemplo de acesso a um
arquivo” e a “Exemplo de acesso a um diretório”. Os dois exemplos são
explicados passo a passo para uma perfeita compreensão do assunto. Vamos a
prática!

Exemplo de acesso a um arquivo

Abaixo um exemplo e explicação das permissões de acesso a um arquivo no GNU/
Linux (obtido com o comando ls -la, explicarei passo a passo cada parte:

-rwxr-xr-- 1 gleydson user 8192 nov 4 16:00 teste

-rwxr-xr--

    Estas são as permissões de acesso ao arquivo teste. Um conjunto de 10
    letras que especificam o tipo do arquivo, permissão do dono do arquivo,
    grupo do arquivo e outros usuários. Veja a explicação detalhada sobre cada
    uma abaixo:

    -rwxr-xr--

        A primeira letra (do conjunto das 10 letras) determina o tipo do
        arquivos. Se a letra for um d é um diretório, e você poderá acessa-lo
        usando o comando cd. Caso for um l é um link simbólico para algum
        arquivo ou diretório no sistema (para detalhes veja o comando “ln” . Um
        - significa que é um arquivo normal.

    -rwxr-xr--

        Estas 3 letras (da segunda a quarta do conjunto das 10 letras) são as
        permissões de acesso do dono do arquivo teste. O dono (neste caso 
        gleydson) tem a permissão para ler (r), gravar (w) e executar (x) o
        arquivo teste.

    -rwxr-xr--

        Estes 3 simbolos (do quinto ao sétimo do conjunto de 10) são as
        permissões de acesso dos usuários que pertencem ao grupo user do
        arquivo teste. Os usuários que pertencem ao grupo user tem a permissão
        somente para ler (r) e executar (x) o arquivo teste não podendo
        modifica-lo ou apaga-lo.

    -rwxr-xr--

        Estes 3 simbolos (do oitavo ao décimo) são as permissões de acesso para
        usuários que não são donos do arquivo teste e que não pertencem ao
        grupo user. Neste caso, estas pessoas somente terão a permissão para
        ver o conteúdo do arquivo teste.

gleydson

    Nome do dono do arquivo teste.

user

    Nome do grupo que o arquivo teste pertence.

teste

    Nome do arquivo.

Exemplo de acesso a um diretório

Abaixo um exemplo com explicações das permissões de acesso a um diretório no 
GNU/Linux:

drwxr-x--- 2 gleydson user 1024 nov 4 17:55 exemplo

drwxr-x---

    Permissões de acesso ao diretório exemplo. É um conjunto de 10 letras que
    especificam o tipo de arquivo, permissão do dono do diretório, grupo que o
    diretório pertence e permissão de acesso a outros usuários. Veja as
    explicações abaixo:

    drwxr-x---

        A primeira letra (do conjunto das 10) determina o tipo do arquivo.
        Neste caso é um diretório porque tem a letra d.

    drwxr-x---

        Estas 3 letras (da segunda a quarta) são as permissões de acesso do 
        dono do diretório exemplo. O dono do diretório (neste caso gleydson)
        tem a permissão para listar arquivos do diretório (r), gravar arquivos
        no diretório (w) e entrar no diretório (x).

    drwxr-x---

        Estas 3 letras (da quinta a sétima) são as permissões de acesso dos
        usuários que pertencem ao grupo user. Os usuários que pertencem ao
        grupo user tem a permissão somente para listar arquivos do diretório
        (r) e entrar no diretório (x) exemplo.

    drwxr-x---

        Estes 3 simbolos (do oitavo ao décimo) são as permissões de acesso para
        usuários que não são donos do diretório exemplo e que não pertencem ao
        grupo user. Com as permissões acima, nenhum usuário que se encaixe nas
        condições de dono e grupo do diretório tem a permissão de acessa-lo.

gleydson

    Nome do dono do diretório exemplo.

user

    Nome do grupo que diretório exemplo pertence.

exemplo

    Nome do diretório.

Para detalhes de como alterar o dono/grupo de um arquivo/diretório, veja os
comandos “chmod”, “chgrp” e “chown”.

OBSERVAÇÕES:

  • O usuário root não tem nenhuma restrição de acesso ao sistema.

  • Se você tem permissões de gravação no diretório e tentar apagar um arquivo
    que você não tem permissão de gravação, o sistema perguntará se você
    confirma a exclusão do arquivo apesar do modo leitura. Caso você tenha
    permissões de gravação no arquivo, o arquivo será apagado por padrão sem
    mostrar nenhuma mensagem de erro (a não ser que seja especificada a opção
    -i com o comando rm).

  • Por outro lado, mesmo que você tenha permissões de gravação em um arquivo
    mas não tenha permissões de gravação em um diretório, a exclusão do arquivo
    será negada.

Isto mostra que é levado mais em consideração a permissão de acesso do
diretório do que as permissões dos arquivos e sub-diretórios que ele contém.
Este ponto é muitas vezes ignorado por muitas pessoas e expõem seu sistema a
riscos de segurança. Imagine o problema que algum usuário que não tenha
permissão de gravação em um arquivo mas que a tenha no diretório pode causar em
um sistema mal administrado.

Permissões de Acesso Especiais

Em adição as três permissões básicas (rwx), existem permissões de acesso
especiais (stX) que afetam os arquivos e diretórios:

  • s - Quando é usado na permissão de acesso do Dono, ajusta a identificação
    efetiva do usuário do processo durante a execução de um programa, também
    chamado de bit setuid. Não tem efeito em diretórios.

    Quando s é usado na permissão de acesso do Grupo, ajusta a identificação
    efetiva do grupo do processo durante a execução de um programa, chamado de 
    bit setgid. É identificado pela letra s no lugar da permissão de execução
    do grupo do arquivo/diretório. Em diretórios, força que os arquivos criados
    dentro dele pertençam ao mesmo grupo do diretório, ao invés do grupo
    primário que o usuário pertence.

    Ambos setgid e setuid podem aparecer ao mesmo tempo no mesmo arquivo/
    diretório. A permissão de acesso especial s somente pode aparecer no campo 
    Dono e Grupo.

  • S - Idêntico a "s". Significa que não existe a permissão "x" (execução ou
    entrar no diretório) naquela posição. Um exemplo é o chmod 2760 em um
    diretório.

  • t - Salva a imagem do texto do programa no dispositivo swap, assim ele será
    carregado mais rapidamente quando executado, também chamado de stick bit.

    Em diretórios, impede que outros usuários removam arquivos dos quais não
    são donos. Isto é chamado de colocar o diretório em modo append-only. Um
    exemplo de diretório que se encaixa perfeitamente nesta condição é o /tmp,
    todos os usuários devem ter acesso para que seus programas possam criar os
    arquivos temporários lá, mas nenhum pode apagar arquivos dos outros. A
    permissão especial t, pode ser especificada somente no campo outros
    usuários das permissões de acesso.

  • T - Idêntico a "t". Significa que não existe a permissão "x" naquela
    posição (por exemplo, em um chmod 1776 em um diretório).

  • X - Se você usar X ao invés de x, a permissão de execução somente é
    aplicada se o arquivo já tiver permissões de execução. Em diretórios ela
    tem o mesmo efeito que a permissão de execução x.

  • Exemplo da permissão de acesso especial X:

     1. Crie um arquivo teste (digitando touch teste) e defina sua permissão
        para rw-rw-r-- (chmod ug=rw,o=r teste ou chmod 664 teste).

     2. Agora use o comando chmod a+X teste

     3. digite ls -l

     4. Veja que as permissões do arquivo não foram afetadas.

     5. agora digite chmod o+x teste

     6. digite ls -l, você colocou a permissão de execução para os outros
        usuários.

     7. Agora use novamente o comando chmod a+X teste

     8. digite ls -l

     9. Veja que agora a permissão de execução foi concedida a todos os
        usuários, pois foi verificado que o arquivo era executável (tinha
        permissão de execução para outros usuários).

    10. Agora use o comando chmod a-X teste

    11. Ele também funcionará e removerá as permissões de execução de todos os
        usuários, porque o arquivo teste tem permissão de execução (confira
        digitando ls -l).

    12. Agora tente novamente o chmod a+X teste

    13. Você deve ter reparado que a permissão de acesso especial X é
        semelhante a x, mas somente faz efeito quanto o arquivo já tem
        permissão de execução para o dono, grupo ou outros usuários.

    Em diretórios, a permissão de acesso especial X funciona da mesma forma que
    x, até mesmo se o diretório não tiver nenhuma permissão de acesso (x).

A conta root

Esta seção foi baseada no Manual de Instalação da Debian.

A conta root é também chamada de super usuário, este é um login que não possui
restrições de segurança. A conta root somente deve ser usada para fazer a
administração do sistema, e usada o menor tempo possível.

Qualquer senha que criar deverá conter no mínimo 10 caracteres (pois tamanho
menor do que 10 é facilmente quebrado usando brute force com o puder
computacional existente atulamente, sendo que o ideal é utilizar frases senhas,
contendo letras maísculas e minúsculas, caracteres especiais, números e
pontuação. Tenha um cuidado especial quando escolher sua senha root, porque ela
é a conta mais poderosa. Evite palavras de dicionário ou o uso de qualquer
outros dados pessoais que podem ser adivinhados.

Em distribuições Linux mais modernas, o acesso via usuário root é
automaticamente negado em sessões iniciadas via acesso remoto ssh.

Se qualquer um lhe pedir senha root, seja extremamente cuidadoso. Você
normalmente nunca deve distribuir sua conta root, a não ser que esteja
administrando um computador com mais de um administrador do sistema.

Utilize uma conta de usuário normal ao invés da conta root para operar seu
sistema. Porque não usar a conta root? Bem, uma razão para evitar usar
privilégios root é por causa da facilidade de se cometer danos irreparáveis
como root. Outra razão é que você pode ser enganado e rodar um programa Cavalo
de Tróia -- que é um programa que obtém poderes do super usuário para
comprometer a segurança do seu sistema sem que você saiba.

chmod

Muda a permissão de acesso a um arquivo ou diretório. Com este comando você
pode escolher se usuário ou grupo terá permissões para ler, gravar, executar um
arquivo ou arquivos. Sempre que um arquivo é criado, seu dono é o usuário que o
criou e seu grupo é o grupo do usuário (exceto para diretórios configurados com
a permissão de grupo "s", será visto adiante).

chmod [opções] [permissões] [diretório/arquivo]

Onde:

diretório/arquivo

    Diretório ou arquivo que terá sua permissão mudada.

opções, -v, --verbose

    Mostra todos os arquivos que estão sendo processados.

-f, --silent

    Não mostra a maior parte das mensagens de erro.

-c, --change

    Semelhante a opção -v, mas só mostra os arquivos que tiveram as permissões
    alteradas.

-R, --recursive

    Muda permissões de acesso do diretório/arquivo no diretório atual e
    sub-diretórios.

ugoa+-=rwxXst
      □ ugoa - Controla que nível de acesso será mudado. Especificam, em ordem,
        usuário (u), grupo (g), outros (o), todos (a).

      □ +-= - + coloca a permissão, - retira a permissão do arquivo e = define
        a permissão exatamente como especificado.

      □ rwx - r permissão de leitura do arquivo. w permissão de gravação. x
        permissão de execução (ou acesso a diretórios).

chmod não muda permissões de links simbólicos, as permissões devem ser mudadas
no arquivo alvo do link. Também podem ser usados códigos numéricos octais para
a mudança das permissões de acesso a arquivos/diretórios. Para detalhes veja
“Modo de permissão octal”.

DICA: É possível copiar permissões de acesso do arquivo/diretório, por exemplo,
se o arquivo teste.txt tiver a permissão de acesso r-xr----- e você digitar
chmod o=u, as permissões de acesso dos outros usuários (o) serão idênticas ao
do dono (u). Então a nova permissão de acesso do arquivo teste.txt será
r-xr--r-x

Exemplos de permissões de acesso:

chmod g+r *

    Permite que todos os usuários que pertençam ao grupo dos arquivos (g)
    tenham (+) permissões de leitura (r) em todos os arquivos do diretório
    atual.

chmod o-r teste.txt

    Retira (-) a permissão de leitura (r) do arquivo teste.txt para os outros
    usuários (usuários que não são donos e não pertencem ao grupo do arquivo
    teste.txt).

chmod uo+x teste.txt

    Inclui (+) a permissão de execução do arquivo teste.txt para o dono e
    outros usuários do arquivo.

chmod a+x teste.txt

    Inclui (+) a permissão de execução do arquivo teste.txt para o dono, grupo
    e outros usuários.

chmod a=rw teste.txt

    Define a permissão de todos os usuários exatamente (=) para leitura e
    gravação do arquivo teste.txt.

chgrp

Muda o grupo de um arquivo/diretório.

chgrp [opções] [grupo] [arquivo/diretório]

Onde:

grupo

    Novo grupo do arquivo/diretório.

arquivo/diretório

    Arquivo/diretório que terá o grupo alterado.

opções, -c, --changes

    Somente mostra os arquivos/grupos que forem alterados.

-f, --silent

    Não mostra mensagens de erro para arquivos/diretórios que não puderam ser
    alterados.

-v, --verbose

    Mostra todas as mensagens e arquivos sendo modificados.

-R, --recursive

    Altera os grupos de arquivos/sub-diretórios do diretório atual.

chown

Muda dono de um arquivo/diretório. Opcionalmente pode também ser usado para
mudar o grupo.

chown [opções] [dono.grupo] [diretório/arquivo]

onde:

dono.grupo

    Nome do dono.grupo que será atribuído ao diretório/arquivo. O grupo é
    opcional.

diretório/arquivo

    Diretório/arquivo que o dono.grupo será modificado.

opções, -v, --verbose

    Mostra os arquivos enquanto são alterados.

-f, --supress

    Não mostra mensagens de erro durante a execução do programa.

-c, --changes

    Mostra somente arquivos que forem alterados.

-R, --recursive

    Altera dono e grupo de arquivos no diretório atual e sub-diretórios.

O dono.grupo pode ser especificado usando o nome de grupo ou o código numérico
correspondente ao grupo (GID).

Você deve ter permissões de gravação no diretório/arquivo para alterar seu dono
/grupo.

  • chown gleydson teste.txt - Muda o dono do arquivo teste.txt para gleydson.

  • chown gleydson.foca teste.txt - Muda o dono do arquivo teste.txt para
    gleydson e seu grupo para foca.

  • chown -R gleydson.focalinux * - Muda o dono/grupo dos arquivos do diretório
    atual e sub-diretórios para gleydson/focalinux (desde que você tenha
    permissões de gravação no diretórios e sub-diretórios).

Modo de permissão octal

Ao invés de utilizar os modos de permissão +r, -r, etc, pode ser usado o modo
octal para se alterar a permissão de acesso a um arquivo. O modo octal é um
conjunto de oito números onde cada número define um tipo de acesso diferente.

É mais flexível gerenciar permissões de acesso usando o modo octal ao invés do
comum, pois você especifica diretamente a permissão do dono, grupo, outros ao
invés de gerenciar as permissões de cada um separadamente. Abaixo a lista de
permissões de acesso octal:

  • 0 - Nenhuma permissão de acesso. Equivalente a -rwx.

  • 1 - Permissão de execução (x).

  • 2 - Permissão de gravação (w).

  • 3 - Permissão de gravação e execução (wx). Equivalente a permissão 2+1

  • 4 - Permissão de leitura (r).

  • 5 - Permissão de leitura e execução (rx). Equivalente a permissão 4+1

  • 6 - Permissão de leitura e gravação (rw). Equivalente a permissão 4+2

  • 7 - Permissão de leitura, gravação e execução. Equivalente a +rwx (4+2+1).

O uso de um deste números define a permissão de acesso do dono, grupo ou outros
usuários. Um modo fácil de entender como as permissões de acesso octais
funcionam, é através da seguinte tabela:

1 = Executar
2 = Gravar
4 = Ler

* Para Dono e Grupo, multiplique as permissões acima por x100 e x10.

e para as permissões de acesso especiais:

1000 = Salva imagem do texto no dispositivo de troca
2000 = Ajusta o bit setgid na execução
4000 = Ajusta o bit setuid na execução

Basta agora fazer o seguinte:

  • Somente permissão de execução, use 1.

  • Somente a permissão de leitura, use 4.

  • Somente permissão de gravação, use 2.

  • Permissão de leitura/gravação, use 6 (equivale a 2+4 / Gravar+Ler).

  • Permissão de leitura/execução, use 5 (equivale a 1+4 / Executar+Ler).

  • Permissão de execução/gravação, use 3 (equivale a 1+2 / Executar+Gravar).

  • Permissão de leitura/gravação/execução, use 7 (equivale a 1+2+4 /
    Executar+Gravar+Ler).

  • Salvar texto no dispositivo de troca, use 1000.

  • Ajustar bit setgid, use 2000.

  • Ajustar bip setuid, use 4000.

  • Salvar texto e ajustar bit setuid, use 5000 (equivale a 1000+4000 / Salvar
    texto + bit setuid).

  • Ajustar bit setuid e setgid, use 6000 (equivale a 4000+2000 / setuid +
    setgid).

Vamos a prática com alguns exemplos:

"chmod 764 teste"

Os números são interpretados da direita para a esquerda como permissão de
acesso aos outros usuários (4), grupo (6), e dono (7). O exemplo acima faz os 
outros usuários (4) terem acesso somente leitura (r) ao arquivo teste, o grupo
(6) ter a permissão de leitura e gravação (w), e o dono (7) ter permissão de
leitura, gravação e execução (rwx) ao arquivo teste.

Outro exemplo:

"chmod 40 teste"

O exemplo acima define a permissão de acesso dos outros usuários (0) como
nenhuma, e define a permissão de acesso do grupo (4) como somente leitura (r).
Note usei somente dois números e então a permissão de acesso do dono do arquivo
não é modificada (leia as permissões de acesso da direita para a esquerda!).
Para detalhes veja a lista de permissões de acesso em modo octal no inicio
desta seção.

"chmod 751 teste"

O exemplo acima define a permissão de acesso dos outros usuários (1) para
somente execução (x), o acesso do grupo (5) como leitura e execução (rx) e o
acesso do dono (7) como leitura, gravação e execução (rwx).

"chmod 4751 teste"

O exemplo acima define a permissão de acesso dos outros usuários (1) para
somente execução (x), acesso do grupo (5) como leitura e execução (rx), o
acesso do dono (7) como leitura, gravação e execução (rwx) e ajusta o bit
setgid (4) para o arquivo teste.

umask

A umask (user mask) são 3 números que definem as permissões iniciais do dono,
grupo e outros usuários que o arquivo/diretório receberá quando for criado ou
copiado para um novo local. Digite umask sem parâmetros para retornar o valor
de sua umask atual.

A umask tem efeitos diferentes caso o arquivo que estiver sendo criado for 
binário (um programa executável) ou texto (“Arquivo texto e binário”) . Veja a
tabela a seguir para ver qual é a mais adequada a sua situação:

---------------------------------------------
|       |        ARQUIVO       | DIRETÓRIO  |
| UMASK |----------------------|            |
|       |   Binário  |  Texto  |            |
|------------------------------|------------|
|   0   |    r-x     |   rw-   |    rwx     |
|   1   |    r--     |   rw-   |    rw-     |
|   2   |    r-x     |   r--   |    r-x     |
|   3   |    r--     |   r--   |    r--     |
|   4   |    --x     |   -w-   |    -wx     |
|   5   |    ---     |   -w-   |    -w-     |
|   6   |    --x     |   ---   |    --x     |
|   7   |    ---     |   ---   |    ---     |
---------------------------------------------

Um arquivo texto criado com o comando umask 012;touch texto.txt receberá as
permissões -rw-rw-r--, pois 0 (dono) terá permissões rw-, 1 (grupo), terá
permissões rw- e 2 (outros usuários) terão permissões r--. Um arquivo binário
copiado com o comando umask 012;cp /bin/ls /tmp/ls receberá as permissões
-r-xr--r-x (confira com a tabela acima).

Por este motivo é preciso atenção antes de escolher a umask, um valor mal
escolhido poderia causar problemas de acesso a arquivos, diretórios ou
programas não sendo executados. O valor padrão da umask na maioria das
distribuições atuais é 022. A umask padrão no sistema Debian é a 022.

A umask é de grande utilidade para programas que criam arquivos/diretórios
temporários, desta forma pode-se bloquear o acesso de outros usuários desde a
criação do arquivo, evitando recorrer ao chmod.

Capítulo 12. Redirecionamentos e Pipe

Índice

>
>>
<
<<
| (pipe)
Diferença entre o "|" e o ">"
tee

Esta seção explica o funcionamento dos recursos de direcionamento de entrada e
saída do sistema GNU/Linux.

>

Redireciona a saída padrão de um programa/comando/script para algum dispositivo
ou arquivo ao invés do dispositivo de saída padrão (tela). Quando é usado com
arquivos, este redirecionamento cria ou substitui o conteúdo do arquivo.

Por exemplo, você pode usar o comando ls para listar arquivos e usar ls >
listagem para enviar a saída do comando para o arquivo listagem. Use o comando 
cat para visualizar o conteúdo do arquivo listagem.

O mesmo comando pode ser redirecionado para o segundo console /dev/tty2 usando:
ls >/dev/tty2, o resultado do comando ls será mostrado no segundo console
(pressione ALT e F2 para mudar para o segundo console e ALT e F1 para retornar
ao primeiro). O mesmo resultado pode ser obtido com o comando ls 1>/dev/tty2,
sendo que o número 1 indica que será capturada a saída padrão do comando.

Para redirecionar somente a saída de erros do comando ls, use a sintaxe: ls 2>/
tmp/erros-do-ls

>>

Redireciona a saída padrão de um programa/comando/script para algum dispositivo
ou adiciona as linhas ao final de arquivo ao invés do dispositivo de saída
padrão (tela). A diferença entre este redirecionamento duplo e o simples, é se
caso for usado com arquivos, adiciona a saída do comando ao final do arquivo
existente ao invés de substituir seu conteúdo.

Por exemplo, você pode acrescentar a saída do comando ls ao arquivo listagem do
capítulo anterior usando ls / >>listagem. Use o comando cat para visualizar o
conteúdo do arquivo listagem.

<

Direciona a entrada padrão de arquivo/dispositivo para um comando. Este comando
faz o contrário do anterior, ele envia dados ao comando.

Você pode usar o comando cat <teste.txt para enviar o conteúdo do arquivo
teste.txt ao comando cat que mostrará seu conteúdo (é claro que o mesmo
resultado pode ser obtido com cat teste.txt mas este exemplo serviu para
mostrar a funcionalidade do <).

<<

Este redirecionamento serve principalmente para marcar o fim de exibição de um
bloco. Este é especialmente usado em conjunto com o comando cat, mas também tem
outras aplicações. Por exemplo:

 cat << final
este arquivo
será mostrado
até que a palavra final seja
localizada no inicio da linha
final

| (pipe)

Envia a saída de um comando para a entrada do próximo comando para continuidade
do processamento. Os dados enviados são processados pelo próximo comando que
mostrará o resultado do processamento.

Por exemplo: ls -la | more, este comando faz a listagem longa de arquivos que é
enviado ao comando more (que tem a função de efetuar uma pausa a cada 25 linhas
do arquivo).

Outro exemplo é o comando locate find | grep "bin/", neste comando todos os
caminhos/arquivos que contém find na listagem serão mostrados (inclusive man
pages, bibliotecas, etc.), então enviamos a saída deste comando para grep "bin/
" para mostrar somente os diretórios que contém binários. Mesmo assim a
listagem ocupe mais de uma tela, podemos acrescentar o more: locate find | grep
"bin/" | more.

Podem ser usados mais de um comando de redirecionamento (<, >, |) em um mesmo
comando.

Diferença entre o "|" e o ">"

A principal diferença entre o "|" e o ">", é que o Pipe envolve processamento
entre comandos, ou seja, a saída de um comando é enviado a entrada do próximo e
o ">" redireciona a saída de um comando para um arquivo/dispositivo.

Você pode notar pelo exemplo acima (ls -la | more) que ambos ls e more são
comandos porque estão separados por um "|". Se um deles não existir ou estiver
digitado incorretamente, será mostrada uma mensagem de erro.

Um resultado diferente seria obtido usando um ">" no lugar do "|"; A saída do
comando ls -la > more seria gravada em um arquivo chamado more.

tee

Envia ao mesmo tempo o resultado do programa para a saída padrão (tela) e para
um arquivo. Este comando deve ser usado com o pipe "|".

comando | tee [arquivo]

Exemplo: ls -la | tee listagem.txt, a saída do comando será mostrada
normalmente na tela e ao mesmo tempo gravada no arquivo listagem.txt.

Capítulo 13. Impressão

Índice

Portas de impressora
Imprimindo diretamente para a porta de impressora
Imprimindo via spool
Impressão em modo gráfico

    Ghost Script

Magic Filter

    Instalação e configuração do Magic Filter
    Outros detalhes técnicos sobre o Magic Filter

Este capitulo descreve como imprimir em seu sistema GNU/Linux e as formas de
impressão via spool, rede, gráfica, etc.

Antes de seguir os passos descritos neste capítulo, tenha certeza que seu
kernel foi compilado com o suporte a impressora USB e/ou paralela ativado, caso
contrário até mesmo a impressão direta para a porta de impressora falhará. Para
detalhes veja ???.

Portas de impressora

Uma porta de impressora é o local do sistema usado para se comunicar com a
impressora. Em sistemas GNU/Linux, a porta de impressora paralela é
identificada como lp0, lp1, lp2 no diretório /dev, caso a impressora seja USB,
o dispositivo será o mesmo, mas estará disponível no diretório /dev/usb. Os
dispositivos lp0, lp1 e lp2 correspondem respectivamente a LPT1, LPT2 e LPT3 no
DOS e Windows. Recomendo que o suporte a porta paralela esteja compilado como
módulo no kernel.

Imprimindo diretamente para a porta de impressora

Isto é feito direcionando a saída ou o texto com > diretamente para a porta de
impressora no diretório /dev.

Supondo que você quer imprimir o texto contido do arquivo trabalho.txt e a
porta de impressora em seu sistema é /dev/usb/lp0, você pode usar os seguintes
comandos:

  • cat trabalho.txt >/dev/usb/lp0 - Direciona a saída do comando cat para a
    impressora USB conectada em lp0.

  • cat <trabalho.txt >/dev/usb/lp0. Faz a mesma coisa que o acima.

  • cat -n trabalho.txt >/dev/usb/lp0 - Numera as linhas durante a impressão.

  • head -n 30 trabalho.txt >/dev/usb/lp0 - Imprime as 30 linhas iniciais do
    arquivo.

  • cat trabalho.txt|tee /dev/usb/lp0 - Mostra o conteúdo do cat na tela e
    envia também para a impressora USB.

Os métodos acima servem somente para imprimir em modo texto (letras, números e
caracteres semi-gráficos).

OBS: Note que a impressora somente imprimirá diretamente a partir da porta,
caso ela seja uma impressora com firmware interna (impressora inteligente).
Algumas impressoras mais recentes (principalmente os modelos mais baratos)
somente imprimem caso estejam configuradas com o respectivo driver (Win
Printers ou impressoras via software), e nunca aceitarão o comando diretamente
para a porta de impressão. Para Win Printers, a melhor alternativa de
configuração de funcionamento será através do CUPS (Common Unix Print System).

Imprimindo via spool

A impressão via spool (fila de impressão) tem por objetivo liberar logo o
programa do serviço que está fazendo a impressão deixando um outro programa
especifico tomar conta.

Este programa é chamado de daemon de impressão, normalmente é o lpr ou o lprng
(recomendado) em sistemas GNU/Linux.

Logo após receber o arquivo que será impresso, o programa de spool gera um
arquivo temporário (normalmente localizado em /var/spool/lpd) que será colocado
em fila para a impressão (um trabalho será impresso após o outro, em
seqüência). O arquivo temporário gerado pelo programa de spool é apagado logo
após concluir a impressão.

Antes de se imprimir qualquer coisa usando os daemons de impressão, é preciso
configurar os parâmetros de sua impressora no arquivo /etc/printcap. Um arquivo
/etc/printcap para uma impressora local padrão se parece com o seguinte:

lp|Impressora compatível com Linux
 :lp=/dev/lp0
 :sd=/var/spool/lpd/lp
 :af=/var/log/lp-acct
 :lf=/var/log/lp-errs
 :pl#66
 :pw#80
 :pc#150
 :mx#0
 :sh

É possível também compartilhar a impressora para a impressão em sistemas
remotos, isto será visto em uma seção separada neste guia.

Usando os exemplos anteriores da seção Imprimindo diretamente para uma porta de
impressora, vamos acelerar as coisas:

  • cat trabalho.txt |lpr - Direciona a saída do comando cat para o programa de
    spool lpr.

  • cat <trabalho.txt |lpr. Faz a mesma coisa que o acima.

  • cat -n trabalho.txt |lpr - Numera as linhas durante a impressão.

  • head -n 30 trabalho.txt |lpr - Imprime as 30 linhas iniciais do arquivo.

A fila de impressão pode ser controlada com os comandos:

  • lpq - Mostra os trabalhos de impressão atuais

  • lprm - Remove um trabalho de impressão

Ou usado o programa de administração lpc para gerenciar a fila de impressão
(veja a página de manual do lpc ou digite ? ao iniciar o programa para
detalhes).

OBS1: Se a impressora não imprimir ou não for possível compartilhar a porta de
impressora paralela com outros dispositivos (tal como o plip), verifique se o
módulo parport_pc foi carregado e com os valores de irq e I/O corretos (por
exemplo, modprobe parport_pc io=0x378 irq=7). Muitas vezes sua porta paralela
pode funcionar sem problemas durante a impressão, mas se ao utilizar plip
ocorrerem erros, a causa pode ser essa. Na distribuição Debian, use o programa 
modconf para configurar os valores permanentemente para o módulo parport_pc.

OBS2: Se tiver mais de uma impressora instalada na máquina, será necessário
especificar a opção "-P impressora" para especificar qual impressora deseja
imprimir/controlar.

Impressão em modo gráfico

A impressão em modo gráfico requer que conheça a marca e modelo de sua
impressora e os métodos usados para imprimir seus documentos. Este guia
abordará somente a segunda recomendação :-)

Ghost Script

O método mais usados pelos aplicativos do GNU/Linux para a impressão de
gráficos do Ghost Script. O Ghost Script (chamado de gs) é um interpretador do
formato Pos Script (arquivos .ps) e pode enviar o resultado de processamento
tanto para a tela como impressora. Ele está disponível para diversas
plataformas e sistema operacionais além do GNU/Linux, inclusive o DOS, Windows,
OS/2, etc.

O formato .ps esta se tornando uma padronização para a impressão de gráficos em
GNU/Linux devido a boa qualidade da impressão, liberdade de configuração,
gerenciamento de impressão feito pelo gs e por ser um formato universal,
compatíveis com outros sistemas operacionais.

Para imprimir um documento via Ghost Script, você precisará do pacote , (para a
distribuição Debian e distribuições baseadas, ou outros de acordo com sua
distribuição Linux) e suas dependências. A distribuição Debian vem com vários
exemplos Pos Script no diretório /usr/share/doc/gs/example que são úteis para o
aprendizado e testes com o Ghost Script.

Hora da diversão:

  • Copie os arquivos tiger.ps.gz e alphabet.ps.gz do diretório /usr/share/doc/
    gs/examples (sistemas Debian) para /tmp e descompacte-os com o comando gzip
    -d tiger.ps.gz e gzip -d alphabet.ps.gz. Se a sua distribuição não possui
    arquivos de exemplo ou você não encontra nenhuma referência de onde se
    localizam, mande um e-mail que os envio os 2 arquivos acima (são 32Kb).

  • O Ghost Script requer um monitor EGA, VGA ou superior para a visualização
    dos seus arquivos (não tenho certeza se ele funciona com monitores CGA ou
    Hércules Monocromático) .

    Para visualizar os arquivos na tela digite:

    gs tiger.ps
    gs alphabet.ps

    Para sair do Ghost Script pressione CTRL+C. Neste ponto você deve ter visto
    um desenho de um tigre e (talvez) letras do alfabeto.

    Se o comando gs alphabet.ps mostrou somente uma tela em branco, você se
    esqueceu de instalar as fontes do Ghost Script (estão localizadas no pacote
    na distribuição Debian).

  • Para imprimir o arquivo alphabet.ps use o comando:

    gs -q -dSAFER -dNOPAUSE -sDEVICE=epson -r240x72 -sPAPERSIZE=legal -sOutputFile=/dev/lp0
    alphabet.ps

    O arquivo alphabet.ps deve ser impresso. Caso aparecerem mensagens como
    Error: /invalidfont in findfont no lugar das letras, você se esqueceu de
    instalar ou configurar as fontes do Ghost Script. Instale o pacote de
    fontes ( na Debian) ou verifique a documentação sobre como configurar as
    fontes.

    Cada uma das opções acima descrevem o seguinte:

      □ -q, -dQUIET - Não mostra mensagens de inicialização do Ghost Script.

      □ -dSAFER - É uma opção para ambientes seguros, pois desativa a operação
        de mudança de nome e deleção de arquivo e permite somente a abertura
        dos arquivos no modo somente leitura.

      □ -dNOPAUSE - Desativa a pausa no final de cada página processada.

      □ -sDEVICE=dispositivo - Dispositivo que receberá a saída do Ghost
        Script. Neste local pode ser especificada a marca o modelo de sua
        impressora ou um formato de arquivo diferente (como pcxmono, bmp256)
        para que o arquivo .ps seja convertido para o formato designado.

        Para detalhes sobre os dispositivos disponíveis em seu Ghost Script,
        digite gs --help|less ou veja a página de manual. Normalmente os nomes
        de impressoras e modelos são concatenados, por exemplo, bjc600 para a
        impressora Canon BJC 600, epson para impressoras padrão epson, stcolor
        para Epson Stylus color, etc.

        O Hardware-HOWTO contém referências sobre hardware suportados pelo GNU/
        Linux, tal como impressoras e sua leitura pode ser útil.

      □ -r<ResH>x<ResV> - Define a resolução de impressão (em dpi) Horizontal e
        Vertical. Os valores dependem de sua impressora.

      □ -sPAPERSIZE=tamanho - Tamanho do papel. Podem ser usados a4, legal,
        letter, etc. Veja a página de manual do gs para ver os outros tipos
        suportados e suas medidas.

      □ -sOutputFile=dispositivo - Dispositivo que receberá a saída de
        processamento do gs. Você pode especificar

          ☆ arquivo.epson - Nome do arquivo que receberá todo o resultado do
            processamento. O arquivo.epson terá toda a impressão codificada no
            formato entendido por impressoras epson e poderá ser impresso com o
            comando cat arquivo.epson >/dev/lp0.

            Uma curiosidade útil: É possível imprimir este arquivo em outros
            sistemas operacionais, tal como o DOS digitando: copy /b
            arquivo.eps prn (lembre-se que o DOS tem um limite de 8 letras no
            nome do arquivo e 3 na extensão. Você deve estar compreendendo a
            flexibilidade que o GNU/Linux e suas ferramentas permitem, isso é
            só o começo.

          ☆ impressao%d.epson - Nome do arquivo que receberá o resultado do
            processamento. Cada página será gravada em arquivos separados como
            impressao1.epson, impressao2.epson.

            Os arquivos podem ser impressos usando os mesmos métodos acima.

          ☆ /dev/lp0 para uma impressora em /dev/lp0

          ☆ - para redirecionar a saída de processamento do gs para a saída
            padrão. É útil para usar o gs com pipes |.

          ☆ \|lpr - Envia a saída do Ghost Script para o daemon de impressão. O
            objetivo é deixar a impressão mais rápida.

        Se você é curioso ou não esta satisfeito com as opções mostradas acima,
        veja a página de manual do gs.

Magic Filter

O Magic Filter é um filtro de impressão inteligente. Ele funciona acionado pelo
spool de impressão (mais especificamente o arquivo /etc/printcap) e permite
identificar e imprimir arquivos de diversos tipos diretamente através do
comando lpr arquivo.

É um ótimo programa e ALTAMENTE RECOMENDADO se você deseja apenas clicar no
botão imprimir e deixar os programas fazerem o resto :-) A intenção do programa
é justamente automatizar os trabalhos de impressão e spool.

A maioria dos programas para ambiente gráfico X11, incluindo o Netscape, Word
Perfect, Gimp e Star Office trabalham nativamente com o magicfilter.

Instalação e configuração do Magic Filter

O Magic Filter é encontrado no pacote da distribuição Debian e baseadas.

Sua configuração pode ser feita com o programa magicfilterconfig que torna o
processo de configuração rápido e fácil para quem não conhece a sintaxe do
arquivo /etc/printcap ou não tem muitas exigências sobre a configuração
detalhada da impressora.

Após instalar o magicfilter reinicie o daemon de impressão (se estiver usando a
Debian, entre no diretório /etc/init.d e como usuário root digite ./lpr restart
ou ./lprng restart).

Para testar o funcionamento do magicfilter, digite lpr alphabet.ps e lpr
tiger.ps, os arquivos serão enviados para o magicfilter que identificará o
arquivo como Pos Script, executará o Ghost Script e retornará o resultado do
processamento para o daemon de impressão. O resultado será visto na impressora.

Se tiver problemas, verifique se a configuração feita com o magicfilterconfig
está correta. Caso precise re-configurar o magicfilter, digite
magicfilterconfig --force (lembre-se que a opção --force substitui qualquer
configuração personalizada que tenha adicionado ao arquivo /etc/printcap).

Outros detalhes técnicos sobre o Magic Filter

Durante a configuração do magicfilter, a seguinte linha é adicionada ao arquivo
/etc/printcap:

:if=/etc/magicfilter/epson9-filter

Não tenho nenhum contrato de divulgação com a epson :-) estou usando esta marca
de impressora porque é a mais tradicional e facilmente encontrada. A linha que
começa com :if no magicfilter identifica um arquivo de filtro de impressão.

O arquivo /etc/magicfilter/epson9-filter é criado usando o formato do
magicfilter, e não é difícil entender seu conteúdo e fazer algumas
modificações:

#! /usr/sbin/magicfilter
#
# Magic filter setup file for 9-pin Epson (or compatible) printers
#
# This file is in the public domain.
#
# This file has been automatically adapted to your system.
#
# wild guess: native control codes start with ESC
0       \033            cat

# PostScript
0 %! filter /usr/bin/gs -q -dSAFER -dNOPAUSE -r120x72 -sDEVICE=epson -sOutputFile=- - -c quit
0 \004%! filter /usr/bin/gs -q -dSAFER -dNOPAUSE -r120x72 -sDEVICE=epson -sOutputFile=- - -c quit

# PDF
0 %PDF fpipe /usr/bin/gs -q -dSAFER -dNOPAUSE -r120x72 -sDEVICE=epson -sOutputFile=- $FILE -c quit

# TeX DVI
0 \367\002 fpipe /usr/bin/dvips -X 120  -Y 72  -R -q -f

# compress'd data
0 \037\235 pipe /bin/gzip  -cdq

# packed, gzipped, frozen and SCO LZH data
0 \037\036 pipe /bin/gzip  -cdq
0 \037\213 pipe /bin/gzip  -cdq
0 \037\236 pipe /bin/gzip  -cdq
0 \037\240 pipe /bin/gzip  -cdq

0 BZh   pipe    /usr/bin/bzip2  -cdq

# troff documents
0 .\?\?\040     fpipe   `/usr/bin/grog  -Tps $FILE`
0 .\\\"         fpipe   `/usr/bin/grog  -Tps $FILE`
0 '\\\"         fpipe   `/usr/bin/grog  -Tps $FILE`
0 '.\\\"                fpipe   `/usr/bin/grog  -Tps $FILE`
0  \\\"         fpipe   `/usr/bin/grog  -Tps $FILE`

Você deve ter notado que para cada tipo de arquivo existe o respectivo programa
que é executado, basta você modificar as opções usadas nos programas neste
arquivo (como faria na linha de comando) para afetar o comportamento da
impressão.

Por exemplo, modificando a resolução para -r240x72 no processamento de arquivos
Pos Script (gs), a impressora passará a usar esta resolução.

Capítulo 14. Configuração do sistema

Índice

Acentuação

    Acentuação em modo Texto
    Acentuação em modo gráfico

Número de Cores do ambiente gráfico

    Configurando o número de cores para quem inicia pelo prompt
    Configurando o número de cores para quem inicia pelo XDM
    Ajustando o alinhamento da imagem no X e outras configurações

Este capítulo traz explicações sobre algumas configurações úteis que podem ser
feitas no sistema. Neste documento assumimos que o kernel do seus sistema já
possui suporte a página de código 860 (Portuguesa) e o conjunto de caracteres
ISO-8859-1.

Acentuação

Permite que o GNU/Linux use a acentuação. A acentuação do modo texto é
independente do modo gráfico; você pode configurar tanto um como o outro ou
ambos. Para maiores detalhes veja “Acentuação em modo Texto” e/ou “Acentuação
em modo gráfico”.

Note que os mapas de teclado usados em modo texto são diferentes dos usados em
modo gráfico. Geralmente os mapas de teclados para o modo gráfico tem uma letra
X no nome.

Acentuação em modo Texto

Caso sua distribuição Debian esteja acentuando corretamente no modo texto você
não precisará ler esta seção. Antes de prosseguir, verifique se você possui o
pacote instalado em seu sistema com o comando: dpkg -l console-data. Caso não
existam, alguns programas de configuração e arquivos de fontes não estarão
disponíveis.

Siga os passos abaixo para colocar e acentuação em funcionamento para o modo
Texto na Debian:

Mapa de Teclados

    Debian 4 ou 5

        Digite dpkg-reconfigure console-data. Após a tela inicial, selecione a
        opção Selecionar o mapa de teclados da lista de arquiteturas, qwerty e
        selecione os passos seguintes de acordo com seu tipo de teclado:

          ☆ US american - Selecione US American na lista de opções e em seguida
            Standard e US International (ISO-8859-1).

          ☆ ABNT2 (com cedilha) - Selecione Brazilian na lista de opções.

    Após isso, o mapa de teclados correto será carregado de /usr/share/keymaps
    e será ativado no sistema.

    Se desejar usar o comando loadkeys manualmente , você precisa copiar o mapa
    de teclados para um local conhecido no sistema, então copie o arquivo
    arquivo.kmap para /usr/share/keymaps/i386/qwerty (em sistemas Debian) ou
    algum outro local apropriado. Note que o arquivo pode ser compactado pelo 
    gzip e copiado para /usr/share/keymaps/i386/qwerty que será lido sem
    problemas pelo sistema encarregado de configurar o teclado e acentuação.

Configurando a fonte de Tela

    Descomente a linha SCREEN_FONT=LatArCyrHeb-16 e modifique-a para
    CONSOLE_FONT=lat1u-16.psf no arquivo /etc/console-tools/config.

    Esta linha diz ao sistema que fonte deve carregar para mostrar os
    caracteres na tela. A fonte de caracteres deve ser compatível com o idioma
    local, pois nem todas suportam caracteres acentuados. A fonte preferível
    para exibir os caracteres acentuados usando padrão ISO é a lat1u-16, o -16
    no nome do arquivo significa o tamanho da fonte. As fontes de tela estão
    disponíveis no diretório /usr/share/consolefonts.

    Neste ponto você pode verificar se o seu sistema esta reconhecendo
    corretamente a acentuação entrando no editor de textos ae e digitando:
    áãâà. Se todos os acentos apareceram corretamente, parabéns! você já passou
    pela parte mais difícil. Agora o próximo passo é a acentuação no Bash.

Acentuação no aviso de comando (bash)

    Para acentuar no Bash (interpretador de comandos) é necessário alterar o
    arquivo /etc/inputrc e fazer as seguintes modificações:

     1. Descomente a linha: "#set convert-meta off" você faz isto apagando o
        símbolo "#" antes do nome.

        Um comentário faz com que o programa ignore linha(s) de comando. É
        muito útil para descrever o funcionamento de comandos/programas (você
        vai encontrar muito isso no sistema GNU/Linux, tudo é muito bem
        documentado).

     2. Inclua a seguinte linha no final do arquivo:

        set meta-flag on

     3. O conteúdo deste arquivo deve ficar assim:

        set convert-meta off
        set input-meta on
        set output-meta on

     4. Digite exit ou pressione CTRL+D para fazer o logout. Entre novamente no
        sistema para que as alterações façam efeito.

Pronto! você já esta acentuando em modo texto!. Talvez seja necessário que faça
alguma alteração em arquivos de configuração de outros programas para que possa
acentuar corretamente (veja se existe algum arquivo com o nome correspondente
ao programa no diretório /etc).

A distribuição Debian também traz o utilitário kbdconfig que também faz a
configuração do mapa de teclados de forma interativa e gravando automaticamente
o mapa de teclados em /etc/kbd/default.map.gz. Se preferir usar o kbdconfig
ainda será necessário executar os passos acima para habilitação da fonte
lat1u-16 e acentuação no bash.

Acentuação em modo gráfico

A acentuação no modo gráfico é feita de maneira simples:

Configuração do mapa de teclados

    Execute o comando dpkg-reconfigure xserver-xorg e informe o tipo de teclado
    quando perguntado pelo sistema de configuração. A configuração será gravada
    na seção InputDevice do arquivo /etc/X11/xorg.conf e poderá ser modificada
    manualmente se necessário.

Número de Cores do ambiente gráfico

O número de cores do ambiente gráfico pode ser alterado facilmente. Normalmente
as distribuições realizam a instalação usando o padrão VESA (que é compatível
com qualquer placa de vídeo) usando 65.000 cores (16 bits), mas por usar VESA
são deixados de lado recursos como aceleração de hardware, XV, e recursos 3D
necessário pela maioria dos jogos e aplicativos de vídeo atuais.

A configuração apropriada do driver exige que você execute novamente o
procedimento de configuração da distribuição usando o comando dpkg-reconfigure
xserver-xorg.

Por exemplo, para configurar minha placa de vídeo Intel 810, é necessário
selecionar o driver i810 na tela de seleção do driver de video do
dpkg-reconfigure xserver-xorg. O programa xresprobe pode ser útil caso deseja
fazer manualmente ajustes finos na configuração do /etc/X11/xorg.conf. O
monitor também poderá ser configurado de acordo com o tamanho da tela (em
polegadas).

Com uma configuração correta é possível atingir até 32 bits de cores (pocket
pixel) no X. A configuração do X utiliza o número de bits ao invés do número de
cores na sua configuração. Abaixo uma tabela comparativa:

  Bits      Número Max. Cores  Memória mínima requerida na Placa de Vídeo
-------     -----------------  -----------------------------------------
 4 bits         16 cores                          256Kb
 8 bits        256 cores                          512Kb
16 bits      32.384/65536 cores                   1MB
24 bits      16 milhões de cores (pixel menor)    1MB
32 bits      16 milhões de cores                  1MB

Lembre-se que a tabela acima leva em consideração a resolução de vídeo de
640x480. Caso utilizar uma resolução de 800x600, 1024x768 ou superior, os
requerimentos de memória de vídeo para mostrar o número de cores da tabela
acima serão maiores. Para mostrar 1024x768 - 16 milhões de cores serão
necessários 2MB de memória de vídeo, por exemplo. A resolução de 24 bits
normalmente traz problemas em alguns chipsets, considere a utilização da
resolução de 16 ou 32 bits.

O uso de uma resolução de vídeo como 800x600 ou superior, também depende do
monitor de vídeo. Nem todos os monitores VGA e SVGAs do mercado suportam
resoluções acima de 640x480.

OBS: Se tiver escolha, prefira placas de vídeo independentes da placa mãe.
Normalmente as placas de vídeo on-board usam parte da memória RAM como memória
de vídeo (memória compartilhada) e isto diminui a performance de vídeo e a
performance do sistema porque se você estiver usando 2MB de memória de vídeo,
terá 2 MB a menos para executar seus programas. O preço destas placas
geralmente diminui na proporção do desempenho que oferecem.

Uma boa escolha para uma melhor qualidade e maior velocidade é 16 bits. O
motivo disto é que quanto maior a qualidade e a resolução, mais tempo será
levado para os pixels serem atualizados no monitor. Veja abaixo como configurar
o número de cores para quem esta iniciando o X-Window pelo modo texto e XDM.

Configurando o número de cores para quem inicia pelo prompt

Após configurar corretamente a resolução de vídeo aceita pelo seu servidor X
com dpkg-reconfigure xserver-xorg (Debian 4.0) use o comando startx -- -bpp 8
no lugar de startx. Note que estou usando 256 cores como exemplo (veja a tabela
acima), se quiser usar mais cores e sua placa de vídeo tiver memória
suficiente, use 16, 24 ou 32.

Uma maneira mais prática de iniciar sempre com uma mesma resolução é incluir um
alias no arquivo .bashrc em seu diretório: alias startx='startx -- -bpp 8'

Desta forma toda a vez que se digitar startx, será executado o comando da
direita do sinal de igual.

OBS: Se alguma coisa der errado e a imagem aparecer distorcida ou simplesmente
não aparecer, não se desespere! Pressione simultaneamente CTRL+ALT+Back Space,
esta é a combinação de teclas finaliza imediatamente o servidor X.

Configurando o número de cores para quem inicia pelo XDM

Assumindo que o seu arquivo /etc/X11/xorg.conf foi gerado corretamente,
modifique o arquivo /etc/X11/xdm/Xservers e altere o final da linha colocando
-bpp resolução. Por exemplo, a última linha de meu arquivo Xservers era:

:0 local /usr/bin/X11/X vt7

 eu a modifiquei para

:0 local /usr/bin/X11/X vt7 -bpp 16

Pronto, basta reiniciar o servidor X (usando CTRL+ALT+Back Space) ou
reiniciando através do arquivo /etc/init.d/xdm usando xdm restart e seu sistema
passará a usar 65.000 cores de vídeo.

OBS: Lembre-se de salvar todos os seus arquivos antes de reiniciar o servidor
X, pois todos os programas que estiverem abertos no sistema serão imediatamente
fechados.

Ajustando o alinhamento da imagem no X e outras configurações

Após você ter criado o arquivo de configuração do X com o dpkg-reconfigure
xserver-xorg, é possível que a configuração precise de um ajuste fino para o
alinhamento correto da imagem no monitor. Muitos monitores modernos possuem
teclas para esta função, mas desde que monitor esteja com sua imagem aparecendo
corretamente em modo texto, o ajuste deverá ser feito no servidor X. Este
ajuste é feito através do utilitário xvidtune.

Entre no modo gráfico como usuário root, abra o xterm e digite xvidtune uma
tela aparecerá com um aviso sobre o uso do programa, clique em OK. Recomendo
que ative o botão AUTO para que a tela vá se ajustando na medida que você mexe
nos ajustes.

Para restaurar a configuração anterior, pressione o botão Restore (não faz
efeito caso o botão Apply tenha sido pressionado). Clicando em Quit, você sai
do xvidtune sem salvar a configuração. Quando estiver satisfeito com a sua
configuração/alinhamento da imagem, clique em Apply, a configuração escolhida
estará salva.

Capítulo 15. X Window (ambiente gráfico)

Índice

O que é X Window?
A organização do ambiente gráfico X Window
Iniciando o X
Servidor X

Este capítulo do guia traz explicações sobre o ambiente gráfico X Window
System.

O que é X Window?

É um sistema gráfico de janelas que roda em uma grande faixa de computadores,
máquinas gráficas e diferentes tipos de máquinas e plataformas Unix. Pode tanto
ser executado em máquinas locais como remotas através de conexão em rede.

A organização do ambiente gráfico X Window

Em geral o ambiente gráfico X Window é dividido da seguinte forma:

  • O Servidor X - É o programa que controla a exibição dos gráficos na tela,
    mouse e teclado. Ele se comunica com os programas cliente através de
    diversos métodos de comunicação.

    O servidor X pode ser executado na mesma máquina que o programa cliente
    esta sendo executado de forma transparente ou através de uma máquina remota
    na rede.

  • O gerenciador de Janelas - É o programa que controla a aparência da
    aplicação. Os gerenciadores de janelas (window managers) são programas que
    atuam entre o servidor X e a aplicação. Você pode alternar de um
    gerenciador para outro sem fechar seus aplicativos.

    Existem vários tipos de gerenciadores de janelas disponíveis no mercado
    entre os mais conhecidos posso citar o Window Maker (feito por um
    Brasileiro), o After Step, Gnome, KDE, twm (este vem por padrão quando o
    servidor X é instalado), Enlightenment, IceWm, etc.

    A escolha do seu gerenciador de janelas é pessoal, depende muito do gosto
    de cada pessoa e dos recursos que deseja utilizar.

  • A aplicação cliente - É o programa sendo executado.

Esta organização do ambiente gráfico X traz grandes vantagens de gerenciamento
e recursos no ambiente gráfico UNIX, uma vez que tem estes recursos você pode
executar seus programas em computadores remotos, mudar totalmente a aparência
de um programa sem ter que fecha-lo (através da mudança do gerenciador de
janelas), etc.

Iniciando o X

O sistema gráfico X pode ser iniciado de duas maneiras:

  • Automática - Usando um gerenciador de seção como xdm, gdm ou wdm que
    apresenta uma tela pedindo nome e senha para entrar no sistema (login).
    Após entrar no sistema, o X executará um dos gerenciadores de janelas
    configurados.

  • Manual - Através do comando startx, ou xinit (note que o startx e xstart
    são scripts que fazem uma configuração completa do ambiente e em algumas
    distribuições também o procedimento de configuração de autenticação do
    ambiente antes de executar o xinit) . Neste caso o usuário deve entrar com
    seu nome e senha para entrar no modo texto e então executar um dos comandos
    acima. Após executar um dos comandos acima, o servidor X será iniciado e
    executará um dos gerenciadores de janelas configurados no sistema.

Servidor X

Como dito acima, o servidor X controla o teclado, mouse e a exibição dos
gráficos em sua tela. Para ser executado, precisa ser configurado através do
arquivo /etc/X11/xorg.conf , usando dpkg-reconfigure xserver-xorg, ou usando o
utilitário xf86cfg (modo texto).

A finalização do servidor X é feita através do pressionamento simultâneo das
teclas CTRL, ALT, Back Space. O servidor X é imediatamente terminado e todos os
gerenciadores de janelas e programas clientes são fechados.

CUIDADO: Sempre utilize a opção de saída de seu gerenciador de janelas para
encerrar normalmente uma seção X11 e salve os trabalhos que estiver fazendo
antes de finalizar uma seção X11. A finalização do servidor X deve ser feita em
caso de emergência quando não se sabe o que fazer para sair de um gerenciador
de janelas ou de um programa mal comportado.

Recomendo fazer a leitura de “Fechando um programa quando não se sabe como
sair” caso estiver em dúvidas de como finalizar um programa mal comportado ou
que não sabe como sair.

Capítulo 16. Como obter ajuda

Índice

Páginas de Manual
Info Pages
Ajuda na própria linha de comandos
help
apropos
whatis
locate
which
Documentos HOWTO's
Documentação de Programas
FAQ
Internet

    Páginas Internet de Referência
    Listas de discussão

Netiqueta

    Recomendações Gerais sobre a Comunicação Eletrônica
    Email
    Telegram/Whatsapp/Messenger/Gtalk/Skype
    Talk
    Listas de Discussão via Email

Dúvidas são comuns durante o aprendizado e uso do Linux e existem várias
maneiras de se obter ajuda e encontrar a resposta para algum problema. O GNU/
Linux é um sistema bem documentado, e ter um programa bem documentado é o
princípio para seu sucesso junto a utilizadores e desenvolvedores, pois
demonstra a dedicação de seu desenvolvedor em garantir boa usabilidade. Abaixo
segue algumas formas úteis para encontrar a solução de sua dúvida, vale a pena
conhece-las.

Páginas de Manual

As páginas de manual acompanham quase todos os programas GNU/Linux. Elas trazem
uma descrição básica do comando/programa e detalhes sobre o funcionamento de
opção.

É mais comum fazer a visualização de uma página de manual em modo texto, com
rolagem vertical, em geral com a aparência de arquivos visualizados com os
comandos less e more. Também documenta parâmetros usados em alguns arquivos de
configuração.

A utilização da página de manual é simples, digite:

man [seção] [comando/arquivo]

onde:

seção

    É a seção de manual que será aberta, se omitido, mostra a primeira seção
    sobre o comando encontrada (em ordem crescente).

comando/arquivo

    Comando/arquivo que deseja pesquisar.

A navegação dentro das páginas de manual é feita usando-se as teclas abaixo:

  • q - Sai da página de manual

  • PageDown ou f - Rola uma página abaixo (25 linhas em consoles tradicionais
    80x25)

  • PageUP ou w - Rola uma página acima (25 linhas em consoles tradicionais
    80x25)

  • SetaAcima ou k - Rola 1 linha acima

  • SetaAbaixo ou e - Rola 1 linha abaixo

  • r - Redesenha a tela (refresh)

  • p ou g - Inicio da página

  • h - Ajuda sobre as teclas e atalhes da página de manual

  • s - Salva a página de manual em formato texto no arquivo especificado (por
    exemplo: /tmp/ls).

Cada seção da página de manual contém explicações sobre uma determinada parte
do sistema. As seções são organizadas em diretórios separados e localizadas no
diretório /usr/man . Os programas/arquivos são classificados nas seguintes
seções:

 1. Programas executáveis ou comandos internos

 2. Chamadas do sistema (funções oferecidas pelo kernel)

 3. Chamadas de Bibliotecas (funções dentro de bibliotecas do sistema)

 4. Arquivos especiais (normalmente encontrados no diretório /dev)

 5. Formatos de arquivos e convenções (/etc/inittab por exemplo).

 6. Jogos

 7. Pacotes de macros e convenções (por exemplo man)

 8. Comandos de Administração do sistema (normalmente usados pelo root)

 9. Rotinas do kernel (não padrões)

A documentação de um programa também pode ser encontrada em 2 ou mais
categorias, como é o caso do arquivo host_access que é documentado na seção 3
(bibliotecas) e 5 (formatos de arquivo e convenções). Por este motivo é
necessário digitar man 5 hosts_access para ler a página sobre o formato do
arquivo, porque o comando man procura a página de manual nas seções em ordem
crescente e a digitação do comando man hosts_access abriria a seção 3.

As páginas de manual contém algumas regras para facilitar a compreensão do
comando:

  • Texto Negrito - Deve ser digitado exatamente como é mostrado

  • [bla bla bla] - Qualquer coisa dentro de [] são opcionais

Exemplo, man ls, man 5 hosts_access.

Info Pages

Idêntico as páginas de manual, mas utiliza a ligação (links) em textos
indicados por um '*', levando diretamente a ítens da infopage, ou para outras
info pages relacionadas com o tópico estudado. Se pressionarmos <Enter> em cima
de uma palavra destacada, a infopages nos levará a seção correspondente.

A info pages é útil quando sabemos o nome do comando e queremos saber para o
que ele serve. Assim como o man, também traz explicações detalhadas sobre uso,
opções e comandos.

Para usar a info pages, digite:

info [comando/programa]

Se o nome do comando/programa não for digitado, a info pages mostra a lista de
todos os manuais de comandos/programas disponíveis. A info pages possui algumas
teclas de navegação úteis:

  • q - Sai da info pages

  • ? - Mostra a tela de ajuda (que contém a lista completa de teclas de
    navegação e muitos outras opções).

  • n - Avança para a próxima página

  • p - Volta uma página

  • u - Sobre um nível do conteúdo (até checar ao índice de documentos)

  • m - Permite usar a localização para encontrar uma página do info. Pressione
    m, digite o comando e tecle <Enter> que será levado automaticamente a
    página correspondente. Caso não digite nada e aperte a tecla TAB, o info
    lhe mostrará todas as opções disponíveis de busca.

  • d - Volta ao índice de documentos.

Existem muitos outras teclas de navegação úteis na info pages, mas estas são as
mais usadas. Para mais detalhes, entre no programa info e pressione ?.

Exemplo, info cvs.

Ajuda na própria linha de comandos

Ajuda rápida, sendo útil para sabermos quais opções podem ser usadas com o
comando/programa.

Quase todos os comandos/programas GNU/Linux oferecem este recurso útil para
consultas rápidas (e quando não precisamos dos detalhes das páginas de manual).
Deve quando se sabe o nome do programa. Para acionar a ajuda on line, digite:

[comando] --help

comando - é o comando/programa que desejamos ter uma explicação rápida.

O Help on Line não funciona com comandos internos (embutidos no Bash), devendo
ser usado o comando man builtins ou o help comando para obter ajuda.

Por exemplo, ls --help.

help

Ajuda rápida, útil para saber que opções podem ser usadas com os comandos
internos do interpretador de comandos. O comando help somente mostra a ajuda
para comandos internos, para ter uma ajuda similar para comandos externos, veja
“Ajuda na própria linha de comandos”. Para usar o help digite:

help [comando]

Por exemplo, help echo, help exit

apropos

Apropos procura por programas/comandos através da descrição. É útil quando
precisamos fazer alguma coisa mas não sabemos qual comando usar. Ele faz sua
pesquisa nas páginas de manual existentes no sistema e lista os comandos/
programas que atendem a consulta. Para usar o comando apropos digite:

apropos [descrição]

Digitando apropos copy, será mostrado todos os comandos que tem a palavra copy
em sua descrição (provavelmente os programas que copiam arquivos, mas podem ser
mostrados outros também).

whatis

O whatis exibe a função do comando especificado como argumento. Útil quando
estamos na dúvida sobre o que determinado programa faz. Para usar o comando 
whatis digite:

whatis [programa/comando]

Digitando whatis ls, lhe será mostrada a descrição do comando ls.

locate

Localiza uma palavra na estrutura de arquivos/diretórios do sistema. É útil
quando queremos localizar onde um comando ou programa se encontra (para
copia-lo, curiosidade, etc). A pesquisa é feita em um banco de dados construído
com o comando updatedb sendo feita a partir do diretório raíz / e
sub-diretórios. Para fazer uma consulta com o locate usamos:

locate [expressão]

A expressão deve ser o nome de um arquivo diretório ou ambos que serão
procurados na estrutura de diretórios do sistema. Como a consulta por um
programa costuma localizar também sua página de manual, é recomendável usar 
"pipes" para filtrar a saída do comando (para detalhes veja “| (pipe)” .

Por exemplo, para listar os diretórios que contém o nome "cp": locate cp. Agora
mostrar somente arquivos binários, usamos: locate cp|grep bin/

which

Localiza um programa na estrutura de diretórios do path. É muito semelhante ao 
locate, mas a busca é feita no path do sistema e somente são mostrados arquivos
executáveis.

which [programa/comando].

Documentos HOWTO's

São documentos em formato texto, html, etc, que explicam como fazer determinada
tarefa ou como um programa funciona. Normalmente são feitos na linguagem SGML e
convertidos para outros formatos (como o texto, HTML, Pos Script) depois de
prontos.

Estes trazem explicações detalhadas desde como usar o bash até sobre como
funciona o modem ou como montar um servidor internet completo. Os HOWTO´s podem
ser encontrados no diretório do projeto de documentação do GNU/Linux (LDP) em
ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/ ou traduzidos para o Português pelo
LDP-BR em http://www.tldp.org/projetos/howto/traduzidos.php. Caso tenha optado
por instalar o pacote de HOWTO's de sua distribuição GNU/Linux, eles podem ser
encontrados em: /usr/doc/how-to

Documentação de Programas

São documentos instalados junto com os programas. Alguns programas também
trazem o aviso de copyright, changelogs, modelos, scripts, exemplos e FAQs
(perguntas freqüêntes) junto com a documentação normal.

Seu princípio é o mesmo do How-to; documentar o programa. Estes arquivos estão
localizados em:

/usr/share/doc/[programa].

Programa é o nome do programa ou comando procurado.

FAQ

FAQ é um arquivo de perguntas e respostas mais freqüêntes sobre o programa.
Normalmente os arquivos de FAQ estão localizados junto com a documentação
principal do programa em /usr/share/doc/[programa].

Internet

Certamente o melhor suporte ao GNU/Linux é via Internet, veja abaixo alguns
locais úteis de onde pode obter ajuda ou se atualizar.

Páginas Internet de Referência

Existem boas páginas Internet Nacionais e Internacionais sobre o GNU/Linux e
assuntos relacionados com este sistema. A maioria trazem documentos e
explicações sobre configuração, instalação, manutenção, documentação, suporte,
etc.

Estas páginas podem ser encontradas através de ferramentas de busca. Entre
outras páginas, posso citar as seguintes:

  • http://www.debianbrasil.org/ Projeto Debian-Br. A Debian é uma distribuição
    de Linux conhecida por sua qualidade, grande número de pacotes,
    estabilidade, facilidade de atualização, desenvolvimento aberto, segurança,
    ferramentas de gerenciamento de servidores e comprometimento com o software
    livre.

    A Debian é feita originalmente em inglês e traduzida por grupos em vários
    lugares do mundo. O projeto Debian-br destina-se a colaborar na tradução da
    Debian para o Português (nossa língua-mãe). Através desse projeto, todos
    poderão, da forma colaborativa como na Debian, trazer essa excelente
    distribuição em nosso idioma!

    Participe:

      □ Você pode pegar um documento pra traduzir

      □ Reformular a página do projeto

      □ Programando para o projeto

      □ Sendo um desenvolvedor da Debian

      □ A pagina do projeto é a http://www.debianbrasil.org/

      □ Revisar documentação

      □ Ou participar de outras tarefas do seu interesse!

    Entre em contato com o responsável pelo projeto pelo email <
    debian-br@listas.cipsga.org.br> para saber como entrar no projeto ou visite
    a página http://www.debianbrasil.org/. Todos os interessados estão
    convidados a participar do projeto!

  • http://www.tldp.org/ - Projeto de documentação do GNU/Linux no Brasil. Toda
    a documentação traduzida para o Português do Brasil pode ser encontrada lá.

    Responsável pela página: <ricardo@conectiva.com.br> endereço: http://
    www.tldp.org/.

  • http://www.linux.org/ - Página oficial do GNU/Linux mantida pela Transmeta
    (a empresa que Linus Torvalds vem trabalhando atualmente). Muita referência
    sobre GNU/Linux, distribuições, hardwares, softwares, downloads, etc.

    Responsável pela página: <webmaster@linux.org> endereço: http://
    www.linux.org/.

  • http://www.oreill.com/safari/ - Neste site você encontra os livros
    publicados sobre a licença OpenBook da Orreil. Na maioria livros que não
    atende mais propósitos atualmente e livros em que os autores concordaram em
    licenciar sob os termos OpenBook.

    Endereço: http://www.oreill.com/safari/.

Caso conhecer uma página de Internet que contenha materiais úteis a comunidade 
GNU/Linux ou desejar incluir a sua, entre em contato para sua inclusão na
próxima versão do guia junto com uma descrição da página.

Listas de discussão

São grupos de usuários que trocam mensagens entre si, resolvem dúvidas, ajudam
na configuração de programas, instalação, etc. É considerado o melhor suporte
ao GNU/Linux pois qualquer participante pode ser beneficiar das soluções
discutidas. Existem milhares de listas de discussões sobre o GNU/Linux
espalhadas pelo mundo, em Português existem algumas dezenas.

Algumas listas são específicas a um determinado assunto do sistema, algumas são
feitas para usuários iniciantes ou avançados, outras falam praticamente de
tudo. Existem desde usuários iniciantes, hackers, consultores, administradores
de redes experientes e gurus participando de listas e oferecendo suporte de
graça a quem se aventurar em instalar e usar o sistema GNU/Linux.

A lista de discussão funciona da seguinte forma: você se inscreve na lista
enviando uma mensagem ao endereço de inscrição, será enviada um pedido de
confirmação por e-mail, simplesmente dê um reply na mensagem para ser
cadastrado. Pronto! agora você estará participando do grupo de usuários e
receberá todas as mensagens dos participantes do grupo. Assim você poderá
enviar sua mensagem e ela será vista por todos os participantes da lista.

Da mesma forma, você pode responder uma dúvida de outro usuário da lista ou
discutir algum assunto, tirar alguma dúvida sobre a dúvida de outra pessoa,
etc.

Não tenha vergonha de enviar sua pergunta, participar de listas de discussão é
uma experiência quase obrigatório de um Linuxer. Abaixo segue uma relação de
listas de discussão em Português com a descrição, endereço de inscrição, e o
que você deve fazer para ser cadastrado:

<debian-user-portuguese@lists.debian.org>

    Lista de discussão para usuários Portugueses da Debian. Também são
    discutidos assuntos relacionados ao Linux em geral. A inscrição é aberta a
    todos os interessados.

    Para se inscrever, envie uma mensagem para <
    debian-user-portuguese-request@lists.debian.org> contendo a palavra
    subscribe no assunto da mensagem. Será enviada uma mensagem a você pedindo
    a confirmação da inscrição na lista de discussão, simplesmente dê um reply
    na mensagem (responder) e você estará cadastrado e poderá enviar e receber
    mensagens dos participantes.

<debian-news-portuguese@lists.debian.org>

    A Debian é extremamente bem estruturada quanto a divulgações e notícias,
    várias listas de email e várias páginas compõe essa base. A Debian Weekly
    News é especialmente importante pois dá uma visão geral do que se passou na
    Debian durante a semana. E não traz apenas traduções mas também adições dos
    acontecimentos atuais da Debian no Brasil, ou projetos concluídos ou
    lançados pela equipe Debian-br (http://www.debianbrasil.org/).

    Essa lista NÃO é usada para resolução de dúvidas e problemas, apenas para o
    RECEBIMENTO de notícias relacionadas a Debian. Não poste mensagens nela!

    Para se inscrever, envie uma mensagem para <
    debian-news-portuguese-request@lists.debian.org> contendo a palavra
    subscribe no assunto da mensagem. Será enviada uma mensagem a você pedindo
    a confirmação da inscrição na lista de discussão, simplesmente dê um reply
    na mensagem (responder) e você passará a receber as notícias sobre a Debian
    em Português.

<linux-br@unicamp.br>

    Lista de discussão que cobre assuntos diversos. Esta lista é voltada para
    usuários com bons conhecimentos no GNU/Linux, são abordados assuntos como
    redes, configurações, etc. Esta é uma lista moderada, o que significa que a
    mensagem que envia passam por uma pessoa que verifica (modera) e a libera
    caso estejam dentro das normas adotada na lista. É uma lista de alto nível
    e recomendada para quem deseja fugir de mensagens como não consigo instalar
    o Linux, não sei compilar o kernel, o que eu faço quando vejo uma tela com
    o nome login:?, etc.

    Para se inscrever nesta lista, envie uma mensagem para: <
    linux-br-request@unicamp.br> contendo a palavra subscribe no assunto da
    mensagem e aguarde o recebimento da confirmação da inscrição. Apenas
    responda a mensagem de confirmação para se inscrever. Para se descadastrar
    envie uma mensagem para o mesmo endereço mas use a palavra unsubscribe.

<dicas-l@unicamp.br>

    Esta lista envia diariamente uma dica de Unix, sistemas da Microsoft ou
    novidades da Internet.

    Para se inscreve nesta lista de discussão, envie uma mensagem para: <
    dicas-l-request@unicamp.br> contendo a palavra subscribe no corpo da
    mensagem e aguarde o recebimento da confirmação da inscrição. Apenas
    responda a mensagem de confirmação para confirmar sua inscrição na lista.
    Para se descadastrar envie uma mensagem para o mesmo endereço mas use a
    palavra unsubscribe.

Esta listagem deveria estar mais completa, mas eu não lembro de todas as
listas!. Também recomendo dar uma olhada em “Listas de Discussão via Email” que
descreve recomendações de comportamento em listas de discussão.

Netiqueta

São recomendações que tem como objetivo facilitar a comunicação através dos
recursos de uma rede. O nome Netiqueta vem de "Etiqueta de Rede" (Net Etiquete
). O material desta seção foi escrito com base nos anos de observação que tive
via internet e também com referência a rfc 1855.

Recomendações Gerais sobre a Comunicação Eletrônica

  • Como recomendação geral, lembre-se que a conversa via internet é feita
    sempre de uma para outra pessoa ou de uma para várias pessoas, e que a
    forma de comunicação é a mesma que utilizaria se estivesse de frente a
    frente com a pessoa. Nunca diga algo que não diria se estivesse diante da
    outra pessoa. Existem pessoas que por estar atrás de um monitor, se sentem
    "maiores" se esquecendo disso e causando prejuízos de comunicação (e sem
    imaginar que a pessoa do outro lado da linha existe).

    Apesar do modo que as frases são escritas expressarem o jeito que a outra
    pessoa está do outro lado da linha e seu tom de comunicação no decorrer da
    conversa, existem algumas coisas que não podem ser totalmente expressadas
    através da Internet, como por exemplo a expressão da "face" das pessoas.
    Para isto foram criados símbolos chamados smileys que expressam a face da
    outra pessoa em determinado momento, e dependendo do sentido da conversa,
    um smiley pode expressar corretamente a intenção de sua frase. Os mais
    usados são os seguintes:

    :-)   --> Sorriso

    :-(   --> Triste

    ;-)   --> Piscadinha

    :-O   --> De boca aberta

    :-|   --> Sem graça

    8-)   --> De óculos

    |-)   --> Com sono e feliz

    &:-)  --> Bobo

    Para entender o sentido do smiley, veja ele de lado (45 graus). Use os
    smileys em suas conversas, mas com cautela. Não espere que a inclusão de um
    smiley sorridente ":-)" deixe o destinatário da mensagem contente com um
    comentário rude ou insulto.

  • ESCREVER EM MAIÚSCULAS significa gritar quando escrever mensagens
    eletrônicas.

  • Use *asteriscos* para destacar uma palavra ou frase. _Isso_ indica uma
    palavra/frase sublinhada.

  • Se você troca mensagens com pessoas do mundo todo, não espere que um
    japonês responda logo seu e-mail que enviou as 15:00 da tarde. A essa hora
    no país dele, ele está roncando forte na cama e sonhando com a placa 3D que
    vai ganhar para melhorar o desempenho de seus jogos de Linux.

  • Durante a comunicação com pessoas de diferentes regiões (ou países), evite
    a utilização de gírias, ou expressões regionais. Uma interpretação em uma
    determinada região não garante que ela tenha o mesmo significado para seu
    destinatário, as vezes pode ser até ofensiva.

  • Assuma que sua mensagem está trafegando sobre uma via não segura, desta
    forma não envie informações pessoais que não enviaria em uma carta comum. O
    uso de criptografia pode garantir melhor segurança na transmissão de dados.

Email

  • Tenha o hábito de colocar sempre um assunto na mensagem que envia para
    identificar seu conteúdo.

  • Respeite os direitos autorais das mensagens de e-mail. Se precisar
    encaminhar mensagens, preserve seu conteúdo original.

  • Procure limitar o tamanho da linha a 70 caracteres. Muitos usuários
    utilizam cliente de e-mail em modo texto, e nem todo mundo usa a mesma
    resolução que você.

  • Caso o e-mail que responda tenha mais que 100 linhas, é recomendável
    colocar a palavra "LONGA" no assunto da mensagem. Se possível corte as
    partes não necessárias da mensagens de respostas tendo o cuidado de não
    "cortar" de forma mal educada a mensagem de outra pessoa.

  • Caso utiliza um editor programa de e-mails com suporte a HTML, envie o
    e-mail utilizando ambos os formatos TEXTO e HTML, muitos administradores
    Linux utilizam sistemas que não suportam HTML.

  • Não espere que o espaçamento ou desenhos ASCII usados em uma mensagem sejam
    mostrados corretamente em todos os sistemas.

  • Utilize sempre uma assinatura no final da mensagem para identificar você e
    principalmente seu endereço de e-mail. Em alguns clientes de e-mail, o
    campo Reply-to é bagunçado, e em e-mails redirecionados o endereço de
    resposta é excluído. A assinatura facilita encontrar o remetente da
    mensagem. Tente manter a assinatura em um tamanho de no máximo 4 linhas.

  • Não repasse mensagens de corrente por e-mail. Elas tem somente o objetivo
    de espalhar boatos na Internet e se espalhar. Normalmente elas vem com uma
    história bonita e no final diz se não repassar acontecerá tudo ao contrário
    com você ou algo do tipo. Não vai acontecer nada! ignore isso e não entre
    na corrente!

    Pelas políticas da Internet, você pode ter sua conta de e-mail perdida se
    fizer mal uso dele.

Telegram/Whatsapp/Messenger/Gtalk/Skype

Ferramentas de mensagens instantâneas são eficientes, alertando a presença
on-line do usuário, auxiliando na redução de custos, etc. Este documento inclui
algumas recomendações etiqueta para os usuários aproveitarem melhor as
ferramentas de comunicação que seguem o padrão IM:

  • De atenção ao status da outra pessoa. Se ela estiver "on-line" ou "free for
    chat" significa que ela está desocupada e que pode conversar naquele
    instante. Se estiver como não perturbe, envie somente mensagens se for
    mesmo preciso.

  • EVITE colocar nicks chamativos e caracteres exóticos. Nem todos os usuários
    vêem o nick da mesma forma que a pessoa que os colocou.

  • Seja também sensato ao usar ferramentas de mensagem instantanea. Não entre
    nele caso não possa conversar, ou avise isso mudando seu status para o mais
    adequado para a situação, assim os outros poderão entender que está longe
    do computador, não disponível ou ocupado.

  • É recomendável ser prudente quanto ao envio de mensagens, não envie mais do
    que 4 mensagens seguidas, pois a outra pessoa terá dificuldades para
    responder a todas elas mais outra que talvez possa estar recebendo de
    outras (ou nem tenha recebido, caso exista algum problema temporário no
    servidor).

  • Guarde seu login e senha em lugar seguro. Caso ela seja perdida, você terá
    trabalho para avisar a todos de sua lista de contato.

  • Sempre que enviar uma URL, procure do que se trata na mensagem.

  • No modo de chat, use as recomendações descritas sobre o talk (em “Talk”).

  • Como em toda comunicação on-line, seja cauteloso quando a pessoa que
    conversa. Nem sempre quem conversamos do outro lado é a pessoa que
    esperamos encontrar. Lembre-se que um registro falso e uma identidade pode
    ser criada sem dificuldades por qualquer pessoa.

Talk

  • Use sempre quebra de linhas ao escrever suas mensagens, use pelo menos 70
    caracteres para escrever suas mensagens de talk. Evita escrever
    continuamente até a borda para fazer quebra de linha automática, alguns
    clientes de talk não aceitam isso corretamente.

  • Sempre que termina uma frase, deixe uma linha em branco (tecle enter 2
    vezes) para indicar que a outra pessoa pode iniciar a digitação.

  • Sempre se despeça da outra pessoa e espere ela responder antes de fechar
    uma seção de conversação. O respeito mútuo durante um diálogo é essencial
    :-)

  • Lembre-se que o talk normalmente interrompe as pessoas que trabalham
    nativamente no console. Evite dar talk para estranhos, pois podem fazer uma
    má impressão de você. Tente antes estabelecer outros meios de comunicação.

  • Se a outra pessoa não responder, não assuma de cara que ela está ignorando
    você ou não levando sua conversa muito bem. Ela pode simplesmente estar
    ocupada, trabalhando, ou com problemas no cliente de talk. Alguns cliente
    de talk dão problemas durante a comunicação remota, lembre-se também que
    sua comunicação é via UDP :-)

  • Se a pessoa não responder seus talks durante certo tempo, não deixe ele
    infinitamente beepando a pessoa. Tente mais tarde :-)

  • Seja atencioso caso utilize mais de uma seção de talk ao mesmo tempo.

  • O talk também leva em consideração sua habilidade de digitação. Muitos
    erros e correções contínuas fazem a outra pessoa ter uma noção de você,
    suas experiências, etc ;-)

Listas de Discussão via Email

  • Tente se manter dentro do assunto quando responder mensagens de listas.
    Seja claro e explicativo ao mesmo tempo :-)

  • Sempre coloque um assunto (subject) na mensagem. O assunto serve como um
    resumo do problema ou dúvida que tem. Alguns usuários, principalmente os
    que participam de várias listas de discussão, verificam o assunto da
    mensagem e podem simplesmente descartar a mensagem sem lê-la porque as
    vezes ele não conhece sobre aquele assunto.

  • Nunca use "Socorro!", "Help!" ou coisa do gênero como assunto, seja
    objetivo sobre o problema/dúvida que tem: "Falha ao carregar módulo no do
    kernel", "SMAIL retorna a mensagem Access denied", "Novidades: Nova versão
    do guia Foca Linux" ;-).

  • Procure enviar mensagens em formato texto ao invés de HTML para as listas
    de discussão pois isto faz com que a mensagem seja vista por todos os
    participantes (muitos dos usuários GNU/Linux usam leitores de e-mail que
    não suportam formato html) e diminui drásticamente o tamanho da mensagem
    porque o formato texto não usa tags e outros elementos que a linguagem HTML
    contém (muitos dos usuários costumam participar de várias listas de
    discussão, e mensagens em HTML levam a um excesso de tráfego e tempo de
    conexão).

  • Tenha cautela e bom censo em suas mensagens para listas e grupos de
    discussão, considere que cada mensagem que posta é são arquivadas para
    futura referência.

  • Quando o conteúdo das mensagem tomar outro rumo, é ético modificar o
    assunto do e-mail para se adequar ao novo conteúdo da mensagem. Por
    exemplo, Correção nas regras de Netiqueta para Conversa de pessoa para
    pessoa (Era: Correção das regras de Netiqueta).

  • Quando a conversa em grupo sair do assunto e envolver apenas duas pessoas,
    é conveniente retirar os endereços das pessoas/listas do CC.

  • Não mande arquivos grandes para as listas, principalmente se eles tiverem
    mais que 40Kb de tamanho. Se precisar enviar arquivos maiores que isso,
    envie diretamente para os e-mails dos interessados depois de perguntar.

  • Quando enviar mensagens para listas de discussão, seja educado e cordial
    quanto ao conteúdo de sua mensagem. Envie CC's para as pessoas que dizem
    respeito ao assunto, assim com a lista.

  • Tente ignorar ou não responda mensagens de "Guerras" em listas (Flame Wars
    ), caso queira reponde-la por algum tipo de agressão de quem mandou a
    mensagem, esperar para responde-la a noite (nunca é garantida uma boa
    resposta no momento que está de cabeça quente). Lembre-se de quando
    responde uma mensagem de "Flame War" a "altura" de quem mandou seus
    ataques, está sendo igualmente tão baixo quando o "nível" dessa pessoa.

  • Caso se desentenda com alguma pessoa em uma lista de discussão, não envie
    mensagens agressivas para a listas, se precisar, faça isso diretamente para
    a pessoa! Você pode se arrepender disso mais tarde.

  • Não culpe o administrador da lista pelos usuários que participam dela.
    Notifique somente usuários que não estejam colaborando com a lista e outras
    coisas que prejudiquem seu funcionamento. Administradores preservam o
    funcionamento das listas, e não o comportamento dos usuários.

  • Não use auto respostas para listas de discussão. Pelos inconvenientes
    causados, você pode ser descadastrado ou banido de se inscrever na lista/
    newsgroup.

  • Salve as mensagens de inscrição que recebe da lista. Ela contém detalhes
    sobre seus recursos, e a senha usada muitas vezes para se descadastrar dela
    ou modificar suas permissões de usuário. O administrador pode te ajudar
    nessa tarefa, mas não espere que ele esteja sempre disponível para realizar
    tarefas que podem ser feitas pelo próprio usuário.

  • Muitas pessoas reclamam do excesso de mensagens recebidas das listas de
    discussão. Se você recebe muitas mensagens, procure usar os filtros de
    mensagens para organiza-las. O que eles fazem é procurar por campos na
    mensagem, como o remetente, e enviar para um local separado. No final da
    filtragem, todas as mensagens de listas de discussão estarão em locais
    separados e as mensagens enviadas diretamente a você entrarão na caixa de
    correio principal, por exemplo.

    Um filtro de mensagens muito usado no GNU/Linux é o procmail, para maiores
    detalhes consulte a documentação deste programa.

    O Netscape também tem recursos de filtros de mensagem que podem ser criadas
    facilmente através da opção "Arquivo/Nova SubPasta" ("File/New Subfolder")
    do programa de E-mail. Então defina as regras através do menu "Editar/
    Filtros de Mensagens" ("Edit/Message filters") clicando no botão "Novo"
    ("New").

Capítulo 17. Apêndice

Índice

Sobre este guia
Sobre o Autor
Referências de auxílio ao desenvolvimento do guia
Onde encontrar a versão mais nova do guia?
Colaboradores do Guia
Marcas Registradas
Futuras versões
Guia do Linux
Chave Pública PGP

Este capítulo contém considerações sobre o guia Foca Linux.

Sobre este guia

O Guia Foca foi lançado pela primeira vez em 12 de Novembro de 1999. A versão
que está lendo contém o(s) nível(is) de aprendizdo (Iniciante, Intermediario,
Avançado):

  • Iniciante

A versão que esta lendo agora foi gerada com as seguintes opções:

  • Descrição detalhada de comandos

  • Opções usadas em comandos e programas

  • Observações sobre comandos e configurações

  • Exemplos para a melhor compreensão do assunto discutido.

A versão que está lendo tem o objetivo de servir como referência a usuários:

  • Iniciante - e que estão tendo o primeiro contato com o sistema operacional 
    GNU/Linux

Uma versão que abrange um diferente nível de aprendizado ou mais completa pode
ser baixada de Página Oficial do guia Foca Linux.

O Foca GNU/Linux é atualizado frequentemente, por este motivo recomendo que
assine um dos canais de comunicação (ou todos :-))para ser informado de novas
versões:

  • Siga o Guia Foca no Twitter @guiafoca

  • Siga os avisos do Guia Foca no Telegram: Avisos de Atualização do Guia Foca
    no Telegram

  • Assinar o RSS presente na página do guia, e avisos de atualizações.

  • Siga a página do @guiafoca no Facebook: Página do Guia Foca no Facebook

  • Preencha o formulário no link Novidades na página web em Página Oficial do
    guia Foca Linux no fim da página principal. Após se cadastrar, você será
    notificado sobre novidades envolvendo o Guia Foca e novas versões.

Versões diferentes deste guia podem ser geradas a partir do código fonte XML ou
obtidas através da home page principal (para detalhes veja “Onde encontrar a
versão mais nova do guia?”).

Sobre o Autor

Gleydson Mazioli da Silva é Capixaba, nascido em Vila Velha. Amante de
eletrônica desde criança, foi atraido para a informática através da curiosidade
em funcionamento e reparo de hardware.

Se dedica ao sistema Linux desde 1997. determinado na realização de testes de
ferramentas e sistemas avaliando pontos fortes e fracos de cada uma. Logo que
iniciou em Linux passou a estudar exaustivamente aspectos técnicos de
distribuições e rede em Linux/BSD.

Entre coisas que gosta de fazer/implementar em Linux: possibilidade de pesquisa
e atualização de conhecimento constante, automatização e tomada inteligente de
decisões, níveis de segurança da informação (tanto físico e lógico), firewalls,
virtualização, redes virtuais, integração de sistemas, forense computacional,
documentação de processos, desenvolvimento de ferramentas GPL para a
comunidade, depuração, desenvolvimento de documentações, etc.

Um dos desenvolvedores da distribuição Liberdade, CAETECT, Debian-BR e
desenvolvedor oficial da distribuição Debian. Atuou como tradutor do LDP-BR,
traduzindo vários HOW-TOs importantes para a comunidade Linux Brasileira.
Também é um tdos administradores do projeto CIPSGA, cuidando de uma infinidade
de serviços que o projeto oferece a comunidade que deseja estrutura para
hospedar, fortalecer e manter projetos em software livre.

Trabalhou para algumas empresas do Espírito Santo, no Governo Federal e de
estados na implantação de sistemas em software livre. Atualmente atua como
gerente de tecnologia da Spirit Linux, uma empresa focada na inovação,
avaliação e integração de ferramentas de código aberto junto a seus clientes.

Concorda com certificações, mas destaca que o mais importante é aproveitar a
oportunidade dada pela certificação para estudo e auto avaliação de seus pontos
fracos e assim procurar melhora-los. Possui certificação LPI nível 3 e um
ISO9001 internacional em Administração Linux, como primeiro no ranking
Brasileiro.

E-mail: E-mail: <gleydson@guiafoca.org>, Twitter: @gleydsonmazioli.

Referências de auxílio ao desenvolvimento do guia

  • As seções sobre comandos/programas foram construídas após uso, teste e
    observação do comportamento das opções dos comandos/programas, help on
    line, páginas de manual, info pages e documentação técnica do sistema.

  • How-tos do Linux (principalmente o Networking Howto, Security-Howto)
    ajudaram a formar a base de desenvolvimento do guia e desenvolver algumas
    seções (versões Intermediário e Avançado somente).

  • Todos os exemplos de comandos e seções descritivas do guia são de minha
    autoria. Quanto a exemplos de configurações e utilização de programas, será
    citada a origem que foram baseados em cada capítulo, valorizando trabalho
    de seus respectivos autores.

  • Uso de programas e macetes aprendidos no dia a dia para gerenciar máquinas,
    controlar redes e automatizar sistemas.

  • As seções do nível avançado foram construídas com base em testes e usando
    metodologia própria com o objetivo de oferecer uma documentação objetiva e
    clara ao administrador de rede, auxiliando-o na tomada de decisões para
    solução de problemas. Partes extraidas de outras documentações no nível
    Avançado terão as referências explicitamente citadas em seus respectivos
    capítulos.

  • Manual de Instalação da Debian GNU/Linux - Os capítulos contendo materiais
    extraídos do manual de instalação da Debian são muito úteis e explicativos,
    seria desnecessário reescrever um material como este. O texto é claro e
    didaticamente organizado, o documento aborda detalhes técnicos úteis sobre
    hardware em geral e o Linux ausentes nos manuais de outras distribuições
    Linux.

Onde encontrar a versão mais nova do guia?

Novas versões deste guia, avisos de lançamento, outros níveis de aprendizado
(Iniciante, Intermediário e Avançado), versões para outras distribuições Linux
podem ser encontradas em: Página Oficial do guia Foca Linux.

Se quiser receber notificações de novas versões, use uma das formas a seguir:

  • Siga a página do @guiafoca no Facebook: Página do Guia Foca no Facebook

  • Siga os avisos do Guia Foca no Telegram: Avisos de Atualização do Guia Foca
    no Telegram

  • A ficha do aviso de atualizações na página web em Página Oficial do guia
    Foca Linux no fim da página principal. Após preencher a ficha do aviso de
    atualizações, você será notificado sobre novidades do Guia Foca.

  • por E-Mail: envie uma mensagem para <gleydson@guiafoca.org> pedindo para
    ser incluído na lista de atualizações do guia ou preencha o formulário
    encontrado no final da Home Page do guia.

  • Twitter: Assine o Twitter do guia Foca: @focalinux

  • RSS: Assine o RSS na página oficial do guia (citado acima) para receber
    atualizações e novidades.

Colaboradores do Guia

Entre as principais colaborações até a versão atual, posso citar as seguintes
(classificação cronológica):

  • Djalma Valois <djalma@cipsga.org.br> - Pela atual hospedagem do Foca GNU/
    Linux. Estou muito feliz vendo o Foca GNU/Linux fazendo parte de um projeto
    tão positivo como o CIPSGA é para o crescimento e desenvolvimento do
    software livre nacional.

  • Bakurih <bakurih@yahoo.com> - Revisão inicial do guia, após suas primeiras
    versões.

  • Eduardo Marcel Maçan <macan@debian.org> - Pela antiga hospedagem, na época
    do site metainfo.

  • Michelle Ribeiro <michellemazioli@gmail.com> - Por dispensar parte de seu
    atencioso tempo enviando revisões e sugestões que estão melhorando bastante
    a qualidade do guia. Entre eles detalhes que passaram despercebidos durante
    muito tempo no guia e página principal.

    E também por cuidar do fonte do guia ;-)

  • Augusto Campos <brain@matrix.com.br> - Descrição sobre a distribuição Suse
    e constantes divulgações do guia no antigo site br-linux.org

  • Helio Loureiro https://www.facebook.com/helio.loureiro - Grande Hacker BSD/
    Linux evangelizador do Guia Foca em todas as mídias sociais, desde seu
    surgimento.

  • Paulo Henrique Baptista de Oliveira <baptista@linuxsolutions.com.br> - Pelo
    apoio moral oferecido durante os freqüentes lançamentos do guia,
    acompanhamento e divulgação.

  • Diego Abadan <diego@hipernet.ufsc.br> - Envio de correções significativas,
    novos endereços de listas de discussão.

  • Alexandre Costa <alebyte@bol.com.br> - Envio de centenas de patches
    ortográficos nas versões Iniciante e Intermediário do guia que passaram
    desapercebidas durante várias versões do guia...

  • Christoph Simon <ciccio@prestonet.com.br> - Pela pesquisa e a gigantesca
    coletânea de textos sobre o Linux enviada. Eles estão sendo muito úteis
    tanto para mim quanto no desenvolvimento do guia.

  • Gustavo Noronha <dockov@zaz.com.br> - Vem enviando freqüentes correções,
    contribuições construtivas ao desenvolvimento além de apoio ao
    desenvolvimento do guia . Vale a pena destaca-lo por sua atual dedicação
    junto a distribuição Debian/GNU, tradução da distribuição e a comunidade
    Open Source.

  • Alessandro de Oliveira Faria (aka CABELO) https://www.vivaolinux.com.br/
    ~cabelo - O cara é fantástico, faz projetos avançados onde ninguém mais
    pensaria em fazer, especializado em programação C/C++ experiente em
    sistemas de biometria, visão computacional e redes neurais. Ele criou o
    formato e-PUB do Guia Foca e o disponibilizou numa época que não havia
    possibilidade de gera-lo automaticamente no ciclo de release automático do
    guia.

  • Pedro Zorzenon Neto <pzn@debian.org> - Envio de diversas atualizações para
    o nível Avançado, principalmente sobre o firewall iptables.

  • Rafael Gomes (Twitter @gomex) - Muito a agradecer a ele, mas em especial
    por me introduzir do jeito certo ao mundo DevOps, mostrando que a
    colaboração e espírito de comunidade se sobressaem acima de tudo e pelo
    incentivo a voltar a lançar atualizações do guia de forma colaborativa no
    github. Gomex (como é popularmente chamado) mantém um guia referencia
    Docker na Internet: https://github.com/gomex/docker-para-desenvolvedores.
    Merece uma visita para conhecer o conteúdo, extrema qualidade para quem
    deseja se aprofundar no Docker.

  • Jeferson Fernando Noronha (https://www.youtube.com/user/linuxtipscanal) -
    Pela divulgação do Guia Foca no canal LinuxTips (YouTube). O trabalho que o
    Jeferson realiza é extraordinário, mantendo a tradicional filosofia do
    Software Livre em uma época de desenvolvimento ágil, nuvem e
    orquestradores. Vários cursos e videos gratuitos no canal com qualidade de
    conteúdo que não se encontra em qualquer outro canal de YouTube. Conteúdo
    merece ser acessado pelos leitores do Guia Foca.

  • Andrea González - Dedicou horas revisando todo o conteúdo do guia
    Iniciante, o que mais impressionou foi o nível de detalhamento das
    correções e sugestões enviadas. Algumas passaram batidas por anos (talvez
    desde o inicio do guia).

Marcas Registradas

Todas as marcas registradas citadas neste guia são propriedades de seus
respectivos autores.

Futuras versões

Estes são os materiais que pretendo adicionar em futuras versões do guia:

  • Acrescentar mais detalhes sobre o sistema gráfico X-Window.

  • Entre outros ítens que venho estudando para verificar se encaixam no perfil
    do guia.

Esta é uma futura implementação que venho estudando para acompanhar o
crescimento do guia. Sugestões são bem vindas e podem ser enviadas para <
gleydson@guiafoca.org>.

Guia do Linux

O Guia do Linux é uma versão fork do guia Foca Linux 6.40 WikiLivros e 
Iniciante, Intermediário e Avançado. Ele foi portado para WikiLivros graças ao
dedicado trabalho de Raylton P. Souza e outros colaboradores.

A versão Guia do Linux atualmente encontra-se desatualizada, requerendo o
trabalho de voluntários para se igualar em conteúdo com o Guia Foca, pois os
mesmos possui em conteúdos não sincronizados automaticamente.

Acesse e confira mais este excelente lançamento: Wikibook do Guia do Linux.

Chave Pública PGP

Chaves PGP são usadas para criptografar arquivos, e-mails ou qualquer outra
coisa que desejamos que somente uma pessoa tenha acesso. O PGP segue o padrão
de chave pública/privada; a chave pública é distribuída a todos e a chave
privada permanece na posse do criador para que ele seja o único a ter acesso
aos dados criptografados após digitar a "frase de acesso" correta.

Minha chave PGP segue abaixo, ela também pode ser encontrada em http://
pgp.ai.mit.edu. Se você deseja saber mais sobre o PGP, recomendo um excelente
documento encontrado na seção Apostilas em http://www.cipsga.org.br/

-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF4NBqoBEAC//7HIpbF21OOrrFMBOISNNMvntdeEO4Ea4YmGF2epEQYWh+aC
8eOAP0+XrjTyZV0b4V6Q9vcTd2xw2qChHHVcp2jbVjlxjaTFTGNM8rAU1/2iFFPn
vJ29svh653MexpCzL/iDrI6F9mB+t1pQN7RwjnHRFiBcEk57SwjqIQzFHdk0W78V
ihmhNR/+wVTufy7noTfTB8MYHO3eLIzy66Ck/xQLFS+liPsXymZ5UFbbK8r43AOK
x987tnr1xL1sUMxjKPwMW/WtZTu21SoQmhEweOou0U2KedMX608/UyDQ6f1zyDXz
d8MUqNKDOI7RRJTn3fLAKhXASnQCbIC5nrA6HmUAsCrvg51ErE8aXvyHZaO8cRhs
2yb3Gn2/RL/mNmDxHpSmJ+iFK5ELGGqhIL7cUfvrOyPOsVt5ufEa7Poc94vBRJiv
awp178zkIefR7hOeTKRCbr0a7/7UvXc0nJ2crpWTG0/iFT6O7gHHH/COb7X/61Pn
Oefv9wxkc365iBIFN3Pg0fO4tXKHs3tUH2xhfc9/qXdVgJpme0wvJbZAzHG6piJo
0H17eijz/MWpf4o6PTJPpc9r6qBKmh9pezKnnBxNmrqgg9jms+CObWsziM7/tP22
i4Ywz17RTgd7j6EbCa3Vr6SL4HSLGcxikXpYJEFF1ZXxH+nn0y/jfZf0awARAQAB
tExHbGV5ZHNvbiBNYXppb2xpIGRhIFNpbHZhIChDaGF2ZSBNYXN0ZXIgUGVzc29h
bCkgPGdsZXlkc29ubWF6aW9saUBnbWFpbC5jb20+iQJNBBMBCgA3FiEEhdKAjm/j
o+PVj5Eq+T22P0ZikksFAl4NBqoCGwEECwkKBAUVCgkIAwUWAgMBAAIeAQIXgAAK
CRD5PbY/RmKSS7LxD/9aDxE8JSAKRgUrCjRMeCXTaCOryhQAZSl/V0HzTwrzSTeC
IHJfa1Vq7NoEE5shvttwrOIMK0UnjT8fXKJYnfCtjbQsFtnOd+mGsgh3H9/r1DhA
TqHrBXOUb4oxrLLyB8n11gAET+yLEYkPnrX2wyaFHpQTyJbrUsY6Nibs69eaZljY
4OtWx/eg8RiEX/GHh9SoM8BxXgxoJSLnOU+c0/QZeEoxVX1oZXE1E6lgRe9Kvv7r
6HiGC1lrauul5SZbSBQgJK+a0I96HK329C9+utDjSKrTuu7C1SmcCWbNjC0/Xxcs
SXcalMU3oj0/O+SgOxSypahjlxgYHYP1d36IhKsgqSHc8znORz0sprCtuGiMgjxm
2ENOikf0EM/FkICIS91fCfrumEm5CBrFXS0hokPh6GUFWGfhGJGAEoyi7591VKcv
254j0SytPDJzML1ETZydaIfS+3y+gxOibDo2Fn0sQ2mpFt3m8x2sAWVq/fhB5KwN
KdnFYPFwfUmerOPEXh2yamaOXEC7xMkl58x6vjTnE9uh6SlCpAqxBbrVJGMTPBTQ
jWv5Hbq4ux/zuraQbAnKBdhwggHD8sxkyqwxBLunR0PK9weT/lVeam9O5uBJXLoZ
xfOmhBL38PZmNkKEmKUHA+JvebBdFmQxLit8DqTVS7FhaAdR2QX9cfTHw/EvI7kC
DQReDQoeARAAwcQqN7oGokcrmL87uqiaEq0jpLLOfmcEUneqyE8i5ek2k4EvbUHs
8y3UIKfsAGzGvM5lLmZzQnYiUutiRZjYvVVZpImMY48Ss+8ilVw6HttjhJhwOOwn
2ZX8NED39gkdNY3XimtzyjS1DpsmixpilCRZLC103L8UzpH7kJHPSUvF/9wqLV6O
n9BGj7wa7EueTqsctKof7JEUFYMmdh1KRqQktoSu+ukRN5XQoH/vOqgkUP2BsPFN
m2pLZYFRFcL5dOZeeSzRWvOUwtdG8zHCQab7Ku6AYXih/qbBpzTX2Yiy5NnW/Ezg
6cjErC8OFOAumvtoV5xwPH2csv4aI3YapsRZ8xoNv+00TFgGBGm9w5CiRkriU9AR
nxnkIFDDO/C0Cb7dG/+MpJSLV03tNlXVxBhbG0UZa/1IupdtW+0uKv58PP7Nwsvw
1c6/Ejr9S63paJTv56jGyWasUIOpZXk23iqpxyHwmX3MIOey3H/qXRhgzdJreXlW
ywnaI0bZTybsLAHrE9KwukCS2mSi1PKOyGVhj/pDdA0w17sUFakFtipj60HswJjN
8ssqs85n6js3/nyGky02bNJEahFmQrCbTWQ3C4Wdn9h1wXpwM+KXLaBf5xjMX/rD
z/3M3b69Y2tsJoYhpW4B3u23Fuusg891GkvPvm0bKXerfVDONg7E4xMAEQEAAYkE
cgQYAQoAJhYhBIXSgI5v46Pj1Y+RKvk9tj9GYpJLBQJeDQoeAhsuBQku/geAAkAJ
EPk9tj9GYpJLwXQgBBkBCgAdFiEEuRHBS7LV8V4bMGoAghcsoyjAH2cFAl4NCh4A
CgkQghcsoyjAH2dLBg//fkh8JWdEXvd2M6RrU9V5mYLMXrzp5sCXnfjTKTLo8u3C
Soe02kTPHW2cBOzS6DL/fzUw0JTqEWXJUC3RLYmlcJ6+nx8cjH/AljaW8FZ6VMaV
BmQh36AtoNBp58Rl7RT+2qXjq1gqhNu7XaUwQHrYkhxSow3NueO7m3ZpGuWYyiGJ
ESbYw2sooBD5iHMLkYIjFQdsRKivurpF82JmD3mfif+eivINNNsI0c54Ls5ElM9a
P4KjLxkkXk+bTutzGG8JWq8FNYo+oVTTdZ1jb3TiulEVyKRum8FNZymEW6DADVF8
cAohyq94UUPbRErU7c43z5DOVcV95kDhFE/RzBEau4ry3Udz6KzFMSUMn23sY/bu
uGEugrxvTQcuoVfuNElsvivkhNEHDlTafD35PW4jVoqZAVMOkpM/ZF+pSt0Gt5We
sOoG3BVCB9tltjanY+PChySh1TKJzkk1lzIVp9PfTfUL/HZhsNxok/CjTr9dYzcL
G5jKkU5Gjp+1o2s4JNK1DtURX1ifJ5Gb2DN5pA2mGHgKBPxKbnXopjbZ9kJtGrul
lMRJ7QA68z3WmUUnELaoUSPINs1Al3eNzuH+8Y/CCKFxp+LLh0Hz8UL8nBEBIe+Q
aARrOY9TklZIx8JUqZWbI0n2rLrFyDXEeqcYbUdb9poy233Ucul/zE48i7n2bJw8
EBAAidlDMFSZbRjLvUIEoUfpqN9eKhmGMsmk/j7qi8qSrvZAg8Yev7nd7scuOjEo
H2b/q73MKDuEAZss6NkEEbfE4mKKczoGUkTIUKdFArzoL1Lgd1Mmvq0M2rt34q81
8qo0CNkR34HkYcIGcUoLsrl93WPTvk7P3GKQnP6MEKOigfezII3+1GzspG929J03
ayDmzCUz7hkNp/CjXD1DM+PmIqWWORbpAyYnBOLSfZVOwW31xHykZcm20UknZvt7
HHaHrxEs0grt4NmfX7Z0Z17RLfB88FoPPNbXVS1L/wjEvaIvPNURpfEArtCFl0tA
iQ0nA5ia7acluQc1CybLmCMfHuhlRHz9ZWS+l84On+o0pFGySzll2uq6XZnGHnlY
OEuV72g7hGNh78rUOJSM0WeZ1LaJ9iQqHSb1AbKgfJ1lKQIy7css25YQKe4MjC3/
Gahdr6njOovwALKyGB2YYTVACjdp8YCMFMMoJdb9RJsbTcAkoRMbpL2rS9T63dtM
Z1ufMuR4bYhhGGpAtHNJ2DlQFzMn/V3W7bUT3Im4MnCelFeuWBBZkuZZEVgW7ce2
l2k1Ftw9QjnLCNkJE10gKZqOzR9sHBdiORB0DTF0F++dzdQq1ugcjPvfcSL5Nx5a
70+F0YKM9onTVYfkr0N8uK3CQOECp6LFbIuy/pk6Ue/XQeo=
=DkuQ
-----END PGP PUBLIC KEY BLOCK-----


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Copyright © 1999-2020 - Gleydson Mazioli da Silva

